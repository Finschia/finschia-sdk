syntax = "proto3";
package finschia.or.da.v1;

import "gogoproto/gogo.proto";
import "google/protobuf/timestamp.proto";
import "finschia/or/da/v1/params.proto";

option go_package = "github.com/Finschia/finschia-sdk/x/or/da/types";

enum CompressionOption {
  option (gogoproto.goproto_enum_prefix) = false;

  // COMPRESSION_OPTION_UNSPECIFIED defines a no-op compress option.
  COMPRESSION_OPTION_UNSPECIFIED = 0 [(gogoproto.enumvalue_customname) = "OptionEmpty"];

  // Go standard library fo zlib compression (RFC 1950).
  COMPRESSION_OPTION_ZLIB = 1 [(gogoproto.enumvalue_customname) = "OptionZLIB"];

  // Zstandard is a fast compression algorithm, providing high compression ratios.
  // It also offers a special mode for small data, called dictionary compression.
  COMPRESSION_OPTION_ZSTD = 2 [(gogoproto.enumvalue_customname) = "OptionZSTD"];
}

// BatchContext denotes a range of transactions that belong the same batch.
// It is used to compress shared fields that would otherwise be repeated for each transaction.
message CCBatchHeader {
  // parent_hash is the parent L2 block hash
  bytes parent_hash = 1;

  // timestamp is the L2 block unix timestamp of the batch.
  google.protobuf.Timestamp timestamp = 2 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];

  uint64 l2_height = 3;

  // blockNumber is the L1 BlockNumber of the batch.
  uint64 l1_height = 4;
}

message CCBatchElement {
  // SEQUENCER TX ONLY
  bytes txraw = 1;

  // QUEUED TX ONLY
  uint64 queue_index = 2;
}

message CCBatchFrame {
  CCBatchHeader header = 1;
  repeated CCBatchElement elements = 2;
}

// CCBatch is a data unit per batch epoch.
message CCBatch {
  // previous total batch frames.
  uint64 should_start_at_frame = 1;

  // One batch frame matches one roll-up block.
  repeated CCBatchFrame frames = 2;
}

// // CompressedCCBatch is used  when the sequencer submits.
message CompressedCCBatch {
  // data is a byte array which is generated by compressing CCBatch using the option below.
  bytes data = 1;

  // compression is the compression algorithm used for the batch.
  CompressionOption compression = 2;
}

// L1toL2Queue is a queued tx for L2 batch.
// Sequencer must process this transaction on time in order.
// Queue index start from 1.
message L1toL2Queue {
  // timestamp is the L1 unix timestamp of the queue tx.
  google.protobuf.Timestamp timestamp = 1 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];

  // blockNumber is the L1 BlockNumber when this queue tx was submitted.
  // the queue tx will be expired based on this height.
  int64 l1_height = 2;

  bytes txraw = 3;
  QueueTxStatus status = 4;
}

enum QueueTxStatus {
  option (gogoproto.goproto_enum_prefix) = false;

  // QUEUE_TX_PENDING defines the status where the Tx has not been submitted to L1 batch yet.
  QUEUE_TX_PENDING = 0;

  // QUEUE_TX_SUBMITTED defines the status where the Tx has been submitted to L1 batch.
  QUEUE_TX_SUBMITTED = 1;

  // QUEUE_TX_EXPIRED defines the status where the Tx has not been submitted until the expiration deadline.
  // Sequencers get penalty if queued txs reach this status.
  QUEUE_TX_EXPIRED = 2;
}

// CCRef is a data type that forms an element of the reference chain of Rollup Canonical Chain.
message CCRef {
  // Reference for accessing batch data.
  bytes txhash = 1 [(gogoproto.customname) = "TxHash"];

  // Reference for accessing batch data.
  uint32 msg_index = 2;

  // Total number of batch frames submitted.
  // It is the same as the height of the L2 block submitted so far
  uint64 total_frames = 3;

  // Number of batch frames in the batch.
  uint32 batch_size = 4;

  // Hash of CompressedCCBatch data.
  bytes batch_root = 5;
}

// BatchChainState is the state of target batch chain.
message CCState {
  // Assumed to contain all contiguous batches between base and height (inclusive).
  // height is the latest batch height.
  uint64 base = 1;
  uint64 height = 2;

  // The latest batch timestamp.
  google.protobuf.Timestamp timestamp = 3 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];

  // The latest batch L1 blockNumber.
  uint64 l1_height = 4;

  // processed_l2block is the last l2block height that has been processed by L1.
  uint64 processed_l2block = 5;
}

message QueueTxState {
  // Index of the processed queue element.
  // Queue elements up to this index were submitted via CC batch or timeout.
  uint64 processed_queue_index = 1;

  // Index of the next queue element.
  uint64 next_queue_index = 2;
}

// Proposer use SCCBatch when they submit.
message SCCBatch {
  // previous total batch frames.
  uint64 should_start_at_frame = 1;

  // IntermediateStateRoots (a.k.a. apphash) for a specific range of CCs.
  // len(IntermediateStateRoots) = pre-state root + (N-1) + post-state root
  // N is the number of L2 blocks in the CC batch.
  repeated bytes IntermediateStateRoots = 2;
}

// SCCRef is a data type that forms an element of State Commitment Chain.
message SCCRef {
  // Reference for accessing batch data.
  uint64 total_frames = 1;

  // Number of AppHash(ISRs) in the batch.
  uint32 batch_size = 2;

  // timestamp is data to determine if this batch is within the challenge period.
  google.protobuf.Timestamp timestamp = 3 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];

  // Merkle Root of ISRs.
  bytes batch_root = 4;

  repeated bytes IntermediateStateRoots = 5;
}

// SCCRes is a data type including information on whether the corresponding SCC element is confirmed.
message SCCRes {
  SCCRef ref = 1 [(gogoproto.nullable) = false];
  bool is_confirmed = 2;
}

// BatchChainState is the state of target batch chain.
message SCCState {
  // Assumed to contain all contiguous batches between base and height (inclusive).
  uint64 base = 1;
  uint64 height = 2;

  // The latest batch timestamp when the sequencer submits.
  google.protobuf.Timestamp last_sequencer_submit = 3 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];
}
