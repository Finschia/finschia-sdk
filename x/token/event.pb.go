// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lbm/token/v1/event.proto

package token

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_line_lbm_sdk_types "github.com/line/lbm-sdk/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventType enumerates the valid event types on x/token.
// For the legacy events.
type EventType int32

const (
	EventType_Unspecified     EventType = 0
	EventType_IssueToken      EventType = 1
	EventType_MintToken       EventType = 2
	EventType_BurnToken       EventType = 3
	EventType_BurnTokenFrom   EventType = 4
	EventType_ModifyToken     EventType = 5
	EventType_Transfer        EventType = 6
	EventType_TransferFrom    EventType = 7
	EventType_GrantPermToken  EventType = 8
	EventType_RevokePermToken EventType = 9
	EventType_ApproveToken    EventType = 10
)

var EventType_name = map[int32]string{
	0:  "unspecified",
	1:  "issue",
	2:  "mint",
	3:  "burn",
	4:  "burn_from",
	5:  "modify_token",
	6:  "transfer",
	7:  "transfer_from",
	8:  "grant_perm",
	9:  "revoke_perm",
	10: "approve_token",
}

var EventType_value = map[string]int32{
	"unspecified":   0,
	"issue":         1,
	"mint":          2,
	"burn":          3,
	"burn_from":     4,
	"modify_token":  5,
	"transfer":      6,
	"transfer_from": 7,
	"grant_perm":    8,
	"revoke_perm":   9,
	"approve_token": 10,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{0}
}

// AttributeKey enumerates the valid attribute keys on x/token.
// For the legacy events.
type AttributeKey int32

const (
	AttributeKey_Unspecified AttributeKey = 0
	AttributeKey_Name        AttributeKey = 1
	AttributeKey_Symbol      AttributeKey = 2
	AttributeKey_Meta        AttributeKey = 3
	AttributeKey_ContractID  AttributeKey = 4
	AttributeKey_Owner       AttributeKey = 5
	AttributeKey_Amount      AttributeKey = 6
	AttributeKey_Decimals    AttributeKey = 7
	AttributeKey_ImageURI    AttributeKey = 8
	AttributeKey_Mintable    AttributeKey = 9
	AttributeKey_From        AttributeKey = 10
	AttributeKey_To          AttributeKey = 11
	AttributeKey_Perm        AttributeKey = 12
	AttributeKey_Approver    AttributeKey = 13
	AttributeKey_Proxy       AttributeKey = 14
)

var AttributeKey_name = map[int32]string{
	0:  "unspecified",
	1:  "name",
	2:  "symbol",
	3:  "meta",
	4:  "contract_id",
	5:  "owner",
	6:  "amount",
	7:  "decimals",
	8:  "img_uri",
	9:  "mintable",
	10: "from",
	11: "to",
	12: "perm",
	13: "approver",
	14: "proxy",
}

var AttributeKey_value = map[string]int32{
	"unspecified": 0,
	"name":        1,
	"symbol":      2,
	"meta":        3,
	"contract_id": 4,
	"owner":       5,
	"amount":      6,
	"decimals":    7,
	"img_uri":     8,
	"mintable":    9,
	"from":        10,
	"to":          11,
	"perm":        12,
	"approver":    13,
	"proxy":       14,
}

func (x AttributeKey) String() string {
	return proto.EnumName(AttributeKey_name, int32(x))
}

func (AttributeKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{1}
}

// EventSent is emitted on Msg/Send and Msg/OperatorSend.
// Since: finschia
type EventSent struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Operator string                            `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	From     string                            `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	To       string                            `protobuf:"bytes,4,opt,name=to,proto3" json:"to,omitempty"`
	Amount   github_com_line_lbm_sdk_types.Int `protobuf:"bytes,5,opt,name=amount,proto3,customtype=github.com/line/lbm-sdk/types.Int" json:"amount"`
}

func (m *EventSent) Reset()         { *m = EventSent{} }
func (m *EventSent) String() string { return proto.CompactTextString(m) }
func (*EventSent) ProtoMessage()    {}
func (*EventSent) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{0}
}
func (m *EventSent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSent.Merge(m, src)
}
func (m *EventSent) XXX_Size() int {
	return m.Size()
}
func (m *EventSent) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSent.DiscardUnknown(m)
}

var xxx_messageInfo_EventSent proto.InternalMessageInfo

func (m *EventSent) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventSent) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventSent) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *EventSent) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

// EventAuthorizedOperator is emitted on Msg/AuthorizeOperator.
// Since: finschia
type EventAuthorizedOperator struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the token holder of the authorization.
	Holder string `protobuf:"bytes,2,opt,name=holder,proto3" json:"holder,omitempty"`
	// address of the operator which the authorization is granted to.
	Operator string `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *EventAuthorizedOperator) Reset()         { *m = EventAuthorizedOperator{} }
func (m *EventAuthorizedOperator) String() string { return proto.CompactTextString(m) }
func (*EventAuthorizedOperator) ProtoMessage()    {}
func (*EventAuthorizedOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{1}
}
func (m *EventAuthorizedOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAuthorizedOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAuthorizedOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAuthorizedOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAuthorizedOperator.Merge(m, src)
}
func (m *EventAuthorizedOperator) XXX_Size() int {
	return m.Size()
}
func (m *EventAuthorizedOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAuthorizedOperator.DiscardUnknown(m)
}

var xxx_messageInfo_EventAuthorizedOperator proto.InternalMessageInfo

func (m *EventAuthorizedOperator) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventAuthorizedOperator) GetHolder() string {
	if m != nil {
		return m.Holder
	}
	return ""
}

func (m *EventAuthorizedOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// EventRevokedOperator is emitted on Msg/RevokeOperator.
// Since: finschia
type EventRevokedOperator struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the token holder of the authorization.
	Holder string `protobuf:"bytes,2,opt,name=holder,proto3" json:"holder,omitempty"`
	// address of the operator which the authorization is granted to.
	Operator string `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *EventRevokedOperator) Reset()         { *m = EventRevokedOperator{} }
func (m *EventRevokedOperator) String() string { return proto.CompactTextString(m) }
func (*EventRevokedOperator) ProtoMessage()    {}
func (*EventRevokedOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{2}
}
func (m *EventRevokedOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRevokedOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRevokedOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRevokedOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRevokedOperator.Merge(m, src)
}
func (m *EventRevokedOperator) XXX_Size() int {
	return m.Size()
}
func (m *EventRevokedOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRevokedOperator.DiscardUnknown(m)
}

var xxx_messageInfo_EventRevokedOperator proto.InternalMessageInfo

func (m *EventRevokedOperator) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventRevokedOperator) GetHolder() string {
	if m != nil {
		return m.Holder
	}
	return ""
}

func (m *EventRevokedOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// EventIssue is emitted on Msg/Issue.
// Since: finschia
type EventIssue struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// name defines the human-readable name of the token class.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// symbol is an abbreviated name for token class.
	Symbol string `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// uri is an uri for the resource of the token class stored off chain.
	Uri string `protobuf:"bytes,4,opt,name=uri,proto3" json:"uri,omitempty"`
	// meta is a brief description of token class.
	Meta string `protobuf:"bytes,5,opt,name=meta,proto3" json:"meta,omitempty"`
	// decimals is the number of decimals which one must divide the amount by to get its user representation.
	Decimals int32 `protobuf:"varint,6,opt,name=decimals,proto3" json:"decimals,omitempty"`
	// mintable represents whether the token is allowed to mint.
	Mintable bool `protobuf:"varint,7,opt,name=mintable,proto3" json:"mintable,omitempty"`
}

func (m *EventIssue) Reset()         { *m = EventIssue{} }
func (m *EventIssue) String() string { return proto.CompactTextString(m) }
func (*EventIssue) ProtoMessage()    {}
func (*EventIssue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{3}
}
func (m *EventIssue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventIssue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventIssue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventIssue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventIssue.Merge(m, src)
}
func (m *EventIssue) XXX_Size() int {
	return m.Size()
}
func (m *EventIssue) XXX_DiscardUnknown() {
	xxx_messageInfo_EventIssue.DiscardUnknown(m)
}

var xxx_messageInfo_EventIssue proto.InternalMessageInfo

func (m *EventIssue) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventIssue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventIssue) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *EventIssue) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *EventIssue) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

func (m *EventIssue) GetDecimals() int32 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *EventIssue) GetMintable() bool {
	if m != nil {
		return m.Mintable
	}
	return false
}

// EventGrant is emitted on Msg/Grant.
// Since: finschia
type EventGrant struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the granter.
	Granter string `protobuf:"bytes,2,opt,name=granter,proto3" json:"granter,omitempty"`
	// address of the grantee.
	Grantee string `protobuf:"bytes,3,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// permission on the token class.
	Permission string `protobuf:"bytes,4,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (m *EventGrant) Reset()         { *m = EventGrant{} }
func (m *EventGrant) String() string { return proto.CompactTextString(m) }
func (*EventGrant) ProtoMessage()    {}
func (*EventGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{4}
}
func (m *EventGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGrant.Merge(m, src)
}
func (m *EventGrant) XXX_Size() int {
	return m.Size()
}
func (m *EventGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGrant.DiscardUnknown(m)
}

var xxx_messageInfo_EventGrant proto.InternalMessageInfo

func (m *EventGrant) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventGrant) GetGranter() string {
	if m != nil {
		return m.Granter
	}
	return ""
}

func (m *EventGrant) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *EventGrant) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

// EventAbandon is emitted on Msg/Abandon.
// Since: finschia
type EventAbandon struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the grantee which abandons its grant.
	Grantee string `protobuf:"bytes,2,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// permission on the token class.
	Permission string `protobuf:"bytes,3,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (m *EventAbandon) Reset()         { *m = EventAbandon{} }
func (m *EventAbandon) String() string { return proto.CompactTextString(m) }
func (*EventAbandon) ProtoMessage()    {}
func (*EventAbandon) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{5}
}
func (m *EventAbandon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAbandon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAbandon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAbandon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAbandon.Merge(m, src)
}
func (m *EventAbandon) XXX_Size() int {
	return m.Size()
}
func (m *EventAbandon) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAbandon.DiscardUnknown(m)
}

var xxx_messageInfo_EventAbandon proto.InternalMessageInfo

func (m *EventAbandon) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventAbandon) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *EventAbandon) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

// EventMinted is emitted on Msg/Mint.
// Since: finschia
type EventMinted struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// the address of the operator.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// the address to send minted tokens to.
	To string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// the amount of minted tokens.
	Amount github_com_line_lbm_sdk_types.Int `protobuf:"bytes,4,opt,name=amount,proto3,customtype=github.com/line/lbm-sdk/types.Int" json:"amount"`
}

func (m *EventMinted) Reset()         { *m = EventMinted{} }
func (m *EventMinted) String() string { return proto.CompactTextString(m) }
func (*EventMinted) ProtoMessage()    {}
func (*EventMinted) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{6}
}
func (m *EventMinted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMinted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMinted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMinted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMinted.Merge(m, src)
}
func (m *EventMinted) XXX_Size() int {
	return m.Size()
}
func (m *EventMinted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMinted.DiscardUnknown(m)
}

var xxx_messageInfo_EventMinted proto.InternalMessageInfo

func (m *EventMinted) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventMinted) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventMinted) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

// EventBurned is emitted on Msg/Burn and Msg/OperatorBurn.
// Since: finschia
type EventBurned struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// address which the burnt tokens were from.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// the amount of burnt token.
	Amount github_com_line_lbm_sdk_types.Int `protobuf:"bytes,4,opt,name=amount,proto3,customtype=github.com/line/lbm-sdk/types.Int" json:"amount"`
}

func (m *EventBurned) Reset()         { *m = EventBurned{} }
func (m *EventBurned) String() string { return proto.CompactTextString(m) }
func (*EventBurned) ProtoMessage()    {}
func (*EventBurned) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{7}
}
func (m *EventBurned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBurned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBurned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBurned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBurned.Merge(m, src)
}
func (m *EventBurned) XXX_Size() int {
	return m.Size()
}
func (m *EventBurned) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBurned.DiscardUnknown(m)
}

var xxx_messageInfo_EventBurned proto.InternalMessageInfo

func (m *EventBurned) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventBurned) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventBurned) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

// EventModified is emitted on Msg/Modify.
// Since: finschia
type EventModified struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// changes on the metadata of the class.
	Changes []Pair `protobuf:"bytes,3,rep,name=changes,proto3" json:"changes"`
}

func (m *EventModified) Reset()         { *m = EventModified{} }
func (m *EventModified) String() string { return proto.CompactTextString(m) }
func (*EventModified) ProtoMessage()    {}
func (*EventModified) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{8}
}
func (m *EventModified) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventModified) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventModified.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventModified) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventModified.Merge(m, src)
}
func (m *EventModified) XXX_Size() int {
	return m.Size()
}
func (m *EventModified) XXX_DiscardUnknown() {
	xxx_messageInfo_EventModified.DiscardUnknown(m)
}

var xxx_messageInfo_EventModified proto.InternalMessageInfo

func (m *EventModified) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventModified) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventModified) GetChanges() []Pair {
	if m != nil {
		return m.Changes
	}
	return nil
}

// EventSpent is emitted on token spend.
// Since: finschia
type EventSpent struct {
	// contract id associated with the token class.
	ContractId string                            `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	Spender    string                            `protobuf:"bytes,2,opt,name=spender,proto3" json:"spender,omitempty"`
	Amount     github_com_line_lbm_sdk_types.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/line/lbm-sdk/types.Int" json:"amount"`
}

func (m *EventSpent) Reset()         { *m = EventSpent{} }
func (m *EventSpent) String() string { return proto.CompactTextString(m) }
func (*EventSpent) ProtoMessage()    {}
func (*EventSpent) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{9}
}
func (m *EventSpent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSpent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSpent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSpent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSpent.Merge(m, src)
}
func (m *EventSpent) XXX_Size() int {
	return m.Size()
}
func (m *EventSpent) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSpent.DiscardUnknown(m)
}

var xxx_messageInfo_EventSpent proto.InternalMessageInfo

func (m *EventSpent) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventSpent) GetSpender() string {
	if m != nil {
		return m.Spender
	}
	return ""
}

// EventReceived is emitted on token receipt.
// Since: finschia
type EventReceived struct {
	// contract id associated with the token class.
	ContractId string                            `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	Receiver   string                            `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Amount     github_com_line_lbm_sdk_types.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/line/lbm-sdk/types.Int" json:"amount"`
}

func (m *EventReceived) Reset()         { *m = EventReceived{} }
func (m *EventReceived) String() string { return proto.CompactTextString(m) }
func (*EventReceived) ProtoMessage()    {}
func (*EventReceived) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{10}
}
func (m *EventReceived) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReceived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReceived.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReceived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReceived.Merge(m, src)
}
func (m *EventReceived) XXX_Size() int {
	return m.Size()
}
func (m *EventReceived) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReceived.DiscardUnknown(m)
}

var xxx_messageInfo_EventReceived proto.InternalMessageInfo

func (m *EventReceived) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventReceived) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

func init() {
	proto.RegisterEnum("lbm.token.v1.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("lbm.token.v1.AttributeKey", AttributeKey_name, AttributeKey_value)
	proto.RegisterType((*EventSent)(nil), "lbm.token.v1.EventSent")
	proto.RegisterType((*EventAuthorizedOperator)(nil), "lbm.token.v1.EventAuthorizedOperator")
	proto.RegisterType((*EventRevokedOperator)(nil), "lbm.token.v1.EventRevokedOperator")
	proto.RegisterType((*EventIssue)(nil), "lbm.token.v1.EventIssue")
	proto.RegisterType((*EventGrant)(nil), "lbm.token.v1.EventGrant")
	proto.RegisterType((*EventAbandon)(nil), "lbm.token.v1.EventAbandon")
	proto.RegisterType((*EventMinted)(nil), "lbm.token.v1.EventMinted")
	proto.RegisterType((*EventBurned)(nil), "lbm.token.v1.EventBurned")
	proto.RegisterType((*EventModified)(nil), "lbm.token.v1.EventModified")
	proto.RegisterType((*EventSpent)(nil), "lbm.token.v1.EventSpent")
	proto.RegisterType((*EventReceived)(nil), "lbm.token.v1.EventReceived")
}

func init() { proto.RegisterFile("lbm/token/v1/event.proto", fileDescriptor_d7505f4c4cdec18e) }

var fileDescriptor_d7505f4c4cdec18e = []byte{
	// 962 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcf, 0x72, 0xdb, 0x44,
	0x18, 0xb7, 0x2c, 0xff, 0xfd, 0x6c, 0xa7, 0x8b, 0xc8, 0x50, 0x55, 0x07, 0x67, 0xeb, 0x72, 0x08,
	0x9d, 0xc1, 0x9e, 0x96, 0x13, 0x47, 0x87, 0x52, 0xc6, 0xc3, 0x84, 0x66, 0x9c, 0xf4, 0xc2, 0xc5,
	0x23, 0xd9, 0x1b, 0x67, 0x27, 0xd6, 0xae, 0x66, 0xb5, 0x32, 0x35, 0x27, 0xb8, 0xea, 0x02, 0x2f,
	0xa0, 0x03, 0x4f, 0xc0, 0x91, 0x57, 0xe8, 0xb1, 0x47, 0x86, 0x43, 0x87, 0x49, 0x1e, 0x80, 0x17,
	0xe0, 0xc0, 0xec, 0xae, 0xe4, 0xd8, 0x50, 0xa6, 0xa1, 0x09, 0xb7, 0xfd, 0xf6, 0xf7, 0x69, 0x7f,
	0xbf, 0xfd, 0xf6, 0xfb, 0x23, 0x70, 0x17, 0x41, 0x38, 0x90, 0xfc, 0x9c, 0xb0, 0xc1, 0xf2, 0xd1,
	0x80, 0x2c, 0x09, 0x93, 0xfd, 0x48, 0x70, 0xc9, 0x9d, 0xf6, 0x22, 0x08, 0xfb, 0x1a, 0xe9, 0x2f,
	0x1f, 0x79, 0xbb, 0x73, 0x3e, 0xe7, 0x1a, 0x18, 0xa8, 0x95, 0xf1, 0xf1, 0xb6, 0xbf, 0x36, 0xce,
	0x1a, 0xe9, 0xfd, 0x6c, 0x41, 0xf3, 0x73, 0x75, 0xda, 0x31, 0x61, 0xd2, 0xd9, 0x83, 0xd6, 0x94,
	0x33, 0x29, 0xfc, 0xa9, 0x9c, 0xd0, 0x99, 0x6b, 0x61, 0x6b, 0xbf, 0x39, 0x86, 0x62, 0x6b, 0x34,
	0x73, 0x3c, 0x68, 0xf0, 0x88, 0x08, 0x5f, 0x72, 0xe1, 0x96, 0x35, 0xba, 0xb6, 0x1d, 0x07, 0x2a,
	0xa7, 0x82, 0x87, 0xae, 0xad, 0xf7, 0xf5, 0xda, 0xd9, 0x81, 0xb2, 0xe4, 0x6e, 0x45, 0xef, 0x94,
	0x25, 0x77, 0x86, 0x50, 0xf3, 0x43, 0x9e, 0x30, 0xe9, 0x56, 0xd5, 0xde, 0xc1, 0x47, 0x2f, 0x5f,
	0xef, 0x95, 0x7e, 0x7b, 0xbd, 0x77, 0x7f, 0x4e, 0xe5, 0x59, 0x12, 0xf4, 0xa7, 0x3c, 0x1c, 0x2c,
	0x28, 0x23, 0x83, 0x45, 0x10, 0x7e, 0x1c, 0xcf, 0xce, 0x07, 0x72, 0x15, 0x91, 0xb8, 0x3f, 0x62,
	0x72, 0x9c, 0x7f, 0xd8, 0x63, 0x70, 0x57, 0x0b, 0x1e, 0x26, 0xf2, 0x8c, 0x0b, 0xfa, 0x2d, 0x99,
	0x3d, 0x2b, 0x14, 0xbc, 0x55, 0xfe, 0x07, 0x50, 0x3b, 0xe3, 0x8b, 0x19, 0x29, 0xc4, 0xe7, 0xd6,
	0xd6, 0xb5, 0xec, 0xed, 0x6b, 0xf5, 0xce, 0x61, 0x57, 0xf3, 0x8d, 0xc9, 0x92, 0x9f, 0xff, 0xdf,
	0x64, 0xbf, 0x58, 0x00, 0x9a, 0x6d, 0x14, 0xc7, 0x09, 0x79, 0x3b, 0x87, 0x03, 0x15, 0xe6, 0x87,
	0x24, 0x67, 0xd0, 0x6b, 0xc5, 0x1b, 0xaf, 0xc2, 0x80, 0x2f, 0xf2, 0xd3, 0x73, 0xcb, 0x41, 0x60,
	0x27, 0x82, 0xe6, 0x8f, 0xa1, 0x96, 0xea, 0xeb, 0x90, 0x48, 0xdf, 0xbc, 0xc5, 0x58, 0xaf, 0x95,
	0xba, 0x19, 0x99, 0xd2, 0xd0, 0x5f, 0xc4, 0x6e, 0x0d, 0x5b, 0xfb, 0xd5, 0xf1, 0xda, 0x56, 0x58,
	0x48, 0x99, 0xf4, 0x83, 0x05, 0x71, 0xeb, 0xd8, 0xda, 0x6f, 0x8c, 0xd7, 0x76, 0xef, 0xfb, 0x42,
	0xf9, 0x17, 0xc2, 0xbf, 0x4e, 0x26, 0xb9, 0x50, 0x9f, 0x2b, 0xcf, 0x75, 0x78, 0x0a, 0xf3, 0x0a,
	0x21, 0xf9, 0x05, 0x0a, 0xd3, 0xe9, 0x02, 0x44, 0x44, 0x84, 0x34, 0x8e, 0x29, 0x67, 0xf9, 0x45,
	0x36, 0x76, 0x7a, 0x14, 0xda, 0x26, 0x35, 0x02, 0x9f, 0xcd, 0x38, 0xfb, 0x0f, 0x22, 0xc8, 0xb6,
	0x88, 0xbf, 0x53, 0xd9, 0xff, 0xa0, 0xca, 0x2c, 0x68, 0x69, 0xae, 0x43, 0xca, 0x24, 0x99, 0xdd,
	0xac, 0x72, 0x4c, 0x95, 0xd8, 0x6f, 0xa8, 0x92, 0xca, 0xbb, 0x56, 0xc9, 0x4f, 0x85, 0xbe, 0x83,
	0x44, 0xb0, 0x9b, 0xea, 0x7b, 0x53, 0x65, 0xdf, 0x82, 0xc6, 0xef, 0x2c, 0xe8, 0x98, 0x18, 0xf2,
	0x19, 0x3d, 0xa5, 0x37, 0x55, 0xf9, 0x18, 0xea, 0xd3, 0x33, 0x9f, 0xcd, 0x49, 0xec, 0xda, 0xd8,
	0xde, 0x6f, 0x3d, 0x76, 0xfa, 0x9b, 0xad, 0xb1, 0x7f, 0xe4, 0x53, 0x71, 0x50, 0x51, 0x32, 0xc7,
	0x85, 0x63, 0x2f, 0x2d, 0xb2, 0xf6, 0x38, 0x22, 0xd7, 0xcc, 0xda, 0x38, 0x22, 0xec, 0xaa, 0xa8,
	0x0b, 0x73, 0x23, 0x1e, 0xf6, 0xbb, 0xc6, 0xe3, 0x87, 0x22, 0x1e, 0x63, 0x32, 0x25, 0x74, 0x79,
	0xcd, 0x78, 0x08, 0xe3, 0xbc, 0x8e, 0x47, 0x61, 0xdf, 0x82, 0xa2, 0x87, 0x7f, 0x94, 0xf3, 0xe9,
	0x70, 0xb2, 0x8a, 0x88, 0x83, 0xa1, 0x95, 0xb0, 0x38, 0x22, 0x53, 0xfd, 0x58, 0xa8, 0xe4, 0xdd,
	0x49, 0x33, 0xdc, 0x7a, 0x7e, 0xb5, 0xe5, 0xdc, 0x83, 0x2a, 0x55, 0x8d, 0x0b, 0x59, 0xde, 0x4e,
	0x9a, 0x61, 0xd0, 0x5d, 0xec, 0x44, 0x3d, 0x80, 0x73, 0x17, 0x2a, 0xaa, 0x57, 0xa0, 0xb2, 0xd7,
	0x49, 0x33, 0xdc, 0x54, 0x65, 0xb3, 0x06, 0x82, 0x44, 0x30, 0x64, 0x1b, 0x40, 0xe5, 0xab, 0x01,
	0x30, 0x34, 0x15, 0x30, 0x51, 0xe9, 0x86, 0x2a, 0xde, 0x7b, 0x69, 0x86, 0x3b, 0x6b, 0xf4, 0xa9,
	0xca, 0xc1, 0xfb, 0xd0, 0x0e, 0x55, 0xea, 0xac, 0x26, 0xfa, 0x91, 0x51, 0xd5, 0x28, 0xd2, 0xe9,
	0xb4, 0x32, 0x87, 0x78, 0xd0, 0x90, 0xc2, 0x67, 0xf1, 0x29, 0x11, 0xa8, 0xe6, 0xb5, 0xd3, 0x0c,
	0x37, 0x4e, 0x72, 0xdb, 0x79, 0x00, 0x9d, 0x02, 0x33, 0x24, 0x75, 0x0f, 0xa5, 0x19, 0x6e, 0x17,
	0x0e, 0x9a, 0xa3, 0x07, 0xa0, 0x7b, 0xc2, 0x44, 0x15, 0x3f, 0x6a, 0x78, 0x4e, 0x9a, 0xe1, 0x1d,
	0xdd, 0xe3, 0x8e, 0x88, 0x08, 0x0d, 0xc9, 0x87, 0xd0, 0x12, 0x7a, 0x3a, 0x18, 0xa7, 0xa6, 0xf7,
	0x7e, 0x9a, 0xe1, 0x3b, 0x66, 0x60, 0x5c, 0x79, 0x3d, 0x80, 0x8e, 0x1f, 0x45, 0x82, 0x2f, 0x49,
	0x2e, 0x17, 0x0c, 0xdd, 0xd0, 0x6c, 0x6a, 0xa7, 0x87, 0x7f, 0x96, 0xa1, 0x3d, 0x94, 0x52, 0xd0,
	0x20, 0x91, 0xe4, 0x4b, 0xb2, 0xba, 0x46, 0xd0, 0xf3, 0x19, 0x80, 0x2c, 0xaf, 0x91, 0x66, 0xb8,
	0xf2, 0xd5, 0xd6, 0x0c, 0x40, 0x65, 0x0f, 0xd2, 0x0c, 0xd7, 0x8e, 0xcd, 0x0c, 0xc8, 0x3b, 0x3e,
	0xb2, 0x8d, 0xef, 0xa1, 0xea, 0xf8, 0xdb, 0x49, 0x86, 0x2a, 0xe6, 0xe9, 0x3e, 0x2b, 0x92, 0xec,
	0x89, 0xb3, 0x0b, 0x55, 0xfe, 0x0d, 0x23, 0x02, 0x55, 0xbd, 0x66, 0x9a, 0xe1, 0xea, 0x33, 0x65,
	0x28, 0x0a, 0x93, 0x25, 0xa8, 0x66, 0x28, 0x86, 0xda, 0xda, 0x1c, 0x20, 0xa8, 0x6e, 0x22, 0xfe,
	0xa4, 0x18, 0x20, 0xf7, 0xa0, 0x4e, 0xc3, 0xf9, 0x24, 0x11, 0x14, 0x35, 0x0c, 0x34, 0x0a, 0xfd,
	0x39, 0x79, 0x3e, 0x1e, 0x6d, 0xce, 0x16, 0xd4, 0x34, 0xd8, 0x61, 0x6e, 0x17, 0xfd, 0x07, 0x81,
	0x51, 0xfd, 0x74, 0xfd, 0x67, 0x81, 0x5a, 0x5e, 0x2d, 0xcd, 0x70, 0xf9, 0x84, 0x2b, 0x1f, 0x1d,
	0xfc, 0xb6, 0xf1, 0x51, 0x61, 0x57, 0x67, 0xe6, 0x11, 0x17, 0xa8, 0x63, 0xce, 0xcc, 0x83, 0x2d,
	0xd4, 0xa5, 0x22, 0xc1, 0x5f, 0xac, 0xd0, 0x8e, 0xb9, 0xd4, 0x91, 0x32, 0x0e, 0x3e, 0x7d, 0x79,
	0xd1, 0xb5, 0x5e, 0x5d, 0x74, 0xad, 0xdf, 0x2f, 0xba, 0xd6, 0x8f, 0x97, 0xdd, 0xd2, 0xab, 0xcb,
	0x6e, 0xe9, 0xd7, 0xcb, 0x6e, 0xe9, 0xeb, 0xbd, 0x7f, 0xab, 0x9a, 0x17, 0xe6, 0x7f, 0x2a, 0xa8,
	0xe9, 0x1f, 0xaa, 0x4f, 0xfe, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xed, 0x6b, 0x45, 0x64, 0xaa, 0x09,
	0x00, 0x00,
}

func (m *EventSent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAuthorizedOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAuthorizedOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAuthorizedOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventRevokedOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRevokedOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRevokedOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventIssue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventIssue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventIssue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mintable {
		i--
		if m.Mintable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Decimals != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Meta) > 0 {
		i -= len(m.Meta)
		copy(dAtA[i:], m.Meta)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Meta)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Granter) > 0 {
		i -= len(m.Granter)
		copy(dAtA[i:], m.Granter)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Granter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAbandon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAbandon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAbandon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMinted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMinted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMinted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBurned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBurned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBurned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventModified) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventModified) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventModified) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSpent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSpent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSpent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Spender) > 0 {
		i -= len(m.Spender)
		copy(dAtA[i:], m.Spender)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Spender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventReceived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReceived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventReceived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventSent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *EventAuthorizedOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventRevokedOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventIssue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Meta)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovEvent(uint64(m.Decimals))
	}
	if m.Mintable {
		n += 2
	}
	return n
}

func (m *EventGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Granter)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventAbandon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventMinted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *EventBurned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *EventModified) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventSpent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Spender)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *EventReceived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func sovEvent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventSent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAuthorizedOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAuthorizedOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAuthorizedOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRevokedOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRevokedOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRevokedOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventIssue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventIssue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventIssue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meta = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mintable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mintable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Granter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAbandon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAbandon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAbandon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMinted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMinted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMinted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBurned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBurned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBurned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventModified) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventModified: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventModified: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, Pair{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSpent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSpent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSpent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReceived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReceived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReceived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvent = fmt.Errorf("proto: unexpected end of group")
)
