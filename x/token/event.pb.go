// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lbm/token/v1/event.proto

package token

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_line_lbm_sdk_types "github.com/line/lbm-sdk/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventType enumerates the valid event types on x/token.
// For the legacy events.
type EventType int32

const (
	EventTypeUnspecified     EventType = 0
	EventTypeIssueToken      EventType = 1
	EventTypeMintToken       EventType = 2
	EventTypeBurnToken       EventType = 3
	EventTypeBurnTokenFrom   EventType = 4
	EventTypeModifyToken     EventType = 5
	EventTypeTransfer        EventType = 6
	EventTypeTransferFrom    EventType = 7
	EventTypeGrantPermToken  EventType = 8
	EventTypeRevokePermToken EventType = 9
	EventTypeApproveToken    EventType = 10
)

var EventType_name = map[int32]string{
	0:  "EVENT_TYPE_UNSPECIFIED",
	1:  "issue",
	2:  "mint",
	3:  "burn",
	4:  "burn_from",
	5:  "modify_token",
	6:  "transfer",
	7:  "transfer_from",
	8:  "grant_perm",
	9:  "revoke_perm",
	10: "approve_token",
}

var EventType_value = map[string]int32{
	"EVENT_TYPE_UNSPECIFIED": 0,
	"issue":                  1,
	"mint":                   2,
	"burn":                   3,
	"burn_from":              4,
	"modify_token":           5,
	"transfer":               6,
	"transfer_from":          7,
	"grant_perm":             8,
	"revoke_perm":            9,
	"approve_token":          10,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{0}
}

// AttributeKey enumerates the valid attribute keys on x/token.
// For the legacy events.
type AttributeKey int32

const (
	AttributeKeyUnspecified AttributeKey = 0
	AttributeKeyName        AttributeKey = 1
	AttributeKeySymbol      AttributeKey = 2
	AttributeKeyMeta        AttributeKey = 3
	AttributeKeyContractID  AttributeKey = 4
	AttributeKeyOwner       AttributeKey = 5
	AttributeKeyAmount      AttributeKey = 6
	AttributeKeyDecimals    AttributeKey = 7
	AttributeKeyImageURI    AttributeKey = 8
	AttributeKeyMintable    AttributeKey = 9
	AttributeKeyFrom        AttributeKey = 10
	AttributeKeyTo          AttributeKey = 11
	AttributeKeyPerm        AttributeKey = 12
	AttributeKeyApprover    AttributeKey = 13
	AttributeKeyProxy       AttributeKey = 14
)

var AttributeKey_name = map[int32]string{
	0:  "ATTRIBUTE_KEY_UNSPECIFIED",
	1:  "name",
	2:  "symbol",
	3:  "meta",
	4:  "contract_id",
	5:  "owner",
	6:  "amount",
	7:  "decimals",
	8:  "img_uri",
	9:  "mintable",
	10: "from",
	11: "to",
	12: "perm",
	13: "approver",
	14: "proxy",
}

var AttributeKey_value = map[string]int32{
	"ATTRIBUTE_KEY_UNSPECIFIED": 0,
	"name":                      1,
	"symbol":                    2,
	"meta":                      3,
	"contract_id":               4,
	"owner":                     5,
	"amount":                    6,
	"decimals":                  7,
	"img_uri":                   8,
	"mintable":                  9,
	"from":                      10,
	"to":                        11,
	"perm":                      12,
	"approver":                  13,
	"proxy":                     14,
}

func (x AttributeKey) String() string {
	return proto.EnumName(AttributeKey_name, int32(x))
}

func (AttributeKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{1}
}

// EventSent is emitted when tokens are transferred.
//
// Since: 0.46.0 (finschia)
type EventSent struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggered the send.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// holder whose tokens were sent.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// recipient of the tokens
	To string `protobuf:"bytes,4,opt,name=to,proto3" json:"to,omitempty"`
	// number of tokens sent.
	Amount github_com_line_lbm_sdk_types.Int `protobuf:"bytes,5,opt,name=amount,proto3,customtype=github.com/line/lbm-sdk/types.Int" json:"amount"`
}

func (m *EventSent) Reset()         { *m = EventSent{} }
func (m *EventSent) String() string { return proto.CompactTextString(m) }
func (*EventSent) ProtoMessage()    {}
func (*EventSent) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{0}
}
func (m *EventSent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSent.Merge(m, src)
}
func (m *EventSent) XXX_Size() int {
	return m.Size()
}
func (m *EventSent) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSent.DiscardUnknown(m)
}

var xxx_messageInfo_EventSent proto.InternalMessageInfo

func (m *EventSent) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventSent) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventSent) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *EventSent) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

// EventAuthorizedOperator is emitted when a holder authorizes an operator to manipulate its tokens.
//
// Since: 0.46.0 (finschia)
type EventAuthorizedOperator struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of a holder which authorized the `operator` address as an operator.
	Holder string `protobuf:"bytes,2,opt,name=holder,proto3" json:"holder,omitempty"`
	// address which became an operator of `holder`.
	Operator string `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *EventAuthorizedOperator) Reset()         { *m = EventAuthorizedOperator{} }
func (m *EventAuthorizedOperator) String() string { return proto.CompactTextString(m) }
func (*EventAuthorizedOperator) ProtoMessage()    {}
func (*EventAuthorizedOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{1}
}
func (m *EventAuthorizedOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAuthorizedOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAuthorizedOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAuthorizedOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAuthorizedOperator.Merge(m, src)
}
func (m *EventAuthorizedOperator) XXX_Size() int {
	return m.Size()
}
func (m *EventAuthorizedOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAuthorizedOperator.DiscardUnknown(m)
}

var xxx_messageInfo_EventAuthorizedOperator proto.InternalMessageInfo

func (m *EventAuthorizedOperator) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventAuthorizedOperator) GetHolder() string {
	if m != nil {
		return m.Holder
	}
	return ""
}

func (m *EventAuthorizedOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// EventRevokedOperator is emitted when an authorization is revoked.
//
// Since: 0.46.0 (finschia)
type EventRevokedOperator struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of a holder which revoked the `operator` address as an operator.
	Holder string `protobuf:"bytes,2,opt,name=holder,proto3" json:"holder,omitempty"`
	// address which was revoked as an operator of `holder`.
	Operator string `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *EventRevokedOperator) Reset()         { *m = EventRevokedOperator{} }
func (m *EventRevokedOperator) String() string { return proto.CompactTextString(m) }
func (*EventRevokedOperator) ProtoMessage()    {}
func (*EventRevokedOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{2}
}
func (m *EventRevokedOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRevokedOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRevokedOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRevokedOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRevokedOperator.Merge(m, src)
}
func (m *EventRevokedOperator) XXX_Size() int {
	return m.Size()
}
func (m *EventRevokedOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRevokedOperator.DiscardUnknown(m)
}

var xxx_messageInfo_EventRevokedOperator proto.InternalMessageInfo

func (m *EventRevokedOperator) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventRevokedOperator) GetHolder() string {
	if m != nil {
		return m.Holder
	}
	return ""
}

func (m *EventRevokedOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// EventIssue is emitted when a new token class is created.
//
// Since: 0.46.0 (finschia)
type EventIssue struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// name defines the human-readable name of the token class.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// symbol is an abbreviated name for token class.
	Symbol string `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// uri is an uri for the resource of the token class stored off chain.
	Uri string `protobuf:"bytes,4,opt,name=uri,proto3" json:"uri,omitempty"`
	// meta is a brief description of token class.
	Meta string `protobuf:"bytes,5,opt,name=meta,proto3" json:"meta,omitempty"`
	// decimals is the number of decimals which one must divide the amount by to get its user representation.
	Decimals int32 `protobuf:"varint,6,opt,name=decimals,proto3" json:"decimals,omitempty"`
	// mintable represents whether the token is allowed to mint.
	Mintable bool `protobuf:"varint,7,opt,name=mintable,proto3" json:"mintable,omitempty"`
}

func (m *EventIssue) Reset()         { *m = EventIssue{} }
func (m *EventIssue) String() string { return proto.CompactTextString(m) }
func (*EventIssue) ProtoMessage()    {}
func (*EventIssue) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{3}
}
func (m *EventIssue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventIssue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventIssue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventIssue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventIssue.Merge(m, src)
}
func (m *EventIssue) XXX_Size() int {
	return m.Size()
}
func (m *EventIssue) XXX_DiscardUnknown() {
	xxx_messageInfo_EventIssue.DiscardUnknown(m)
}

var xxx_messageInfo_EventIssue proto.InternalMessageInfo

func (m *EventIssue) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventIssue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventIssue) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *EventIssue) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *EventIssue) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

func (m *EventIssue) GetDecimals() int32 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *EventIssue) GetMintable() bool {
	if m != nil {
		return m.Mintable
	}
	return false
}

// EventGrant is emitted when a granter grants its permission to a grantee.
//
// Info: `granter` would be empty if the permission is granted by an issuance.
//
// Since: 0.46.0 (finschia)
type EventGrant struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which granted the permission to `grantee`.
	// it would be empty where the event is triggered by the issuance.
	Granter string `protobuf:"bytes,2,opt,name=granter,proto3" json:"granter,omitempty"`
	// address of the grantee.
	Grantee string `protobuf:"bytes,3,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// permission on the token class.
	Permission Permission `protobuf:"varint,4,opt,name=permission,proto3,enum=lbm.token.v1.Permission" json:"permission,omitempty"`
}

func (m *EventGrant) Reset()         { *m = EventGrant{} }
func (m *EventGrant) String() string { return proto.CompactTextString(m) }
func (*EventGrant) ProtoMessage()    {}
func (*EventGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{4}
}
func (m *EventGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGrant.Merge(m, src)
}
func (m *EventGrant) XXX_Size() int {
	return m.Size()
}
func (m *EventGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGrant.DiscardUnknown(m)
}

var xxx_messageInfo_EventGrant proto.InternalMessageInfo

func (m *EventGrant) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventGrant) GetGranter() string {
	if m != nil {
		return m.Granter
	}
	return ""
}

func (m *EventGrant) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *EventGrant) GetPermission() Permission {
	if m != nil {
		return m.Permission
	}
	return PermissionUnspecified
}

// EventAbandon is emitted when a grantee abandons its permission.
//
// Since: 0.46.0 (finschia)
type EventAbandon struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the grantee which abandons its grant.
	Grantee string `protobuf:"bytes,2,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// permission on the token class.
	Permission string `protobuf:"bytes,3,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (m *EventAbandon) Reset()         { *m = EventAbandon{} }
func (m *EventAbandon) String() string { return proto.CompactTextString(m) }
func (*EventAbandon) ProtoMessage()    {}
func (*EventAbandon) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{5}
}
func (m *EventAbandon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAbandon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAbandon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAbandon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAbandon.Merge(m, src)
}
func (m *EventAbandon) XXX_Size() int {
	return m.Size()
}
func (m *EventAbandon) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAbandon.DiscardUnknown(m)
}

var xxx_messageInfo_EventAbandon proto.InternalMessageInfo

func (m *EventAbandon) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventAbandon) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *EventAbandon) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

// EventMinted is emitted when tokens are minted.
//
// Since: 0.46.0 (finschia)
type EventMinted struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggered the mint.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// recipient of the tokens.
	To string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// number of tokens minted.
	Amount github_com_line_lbm_sdk_types.Int `protobuf:"bytes,4,opt,name=amount,proto3,customtype=github.com/line/lbm-sdk/types.Int" json:"amount"`
}

func (m *EventMinted) Reset()         { *m = EventMinted{} }
func (m *EventMinted) String() string { return proto.CompactTextString(m) }
func (*EventMinted) ProtoMessage()    {}
func (*EventMinted) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{6}
}
func (m *EventMinted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMinted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMinted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMinted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMinted.Merge(m, src)
}
func (m *EventMinted) XXX_Size() int {
	return m.Size()
}
func (m *EventMinted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMinted.DiscardUnknown(m)
}

var xxx_messageInfo_EventMinted proto.InternalMessageInfo

func (m *EventMinted) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventMinted) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventMinted) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

// EventBurned is emitted when tokens are burnt.
//
// Since: 0.46.0 (finschia)
type EventBurned struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggered the burn.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// holder whose tokens were burned.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// number of tokens burned.
	Amount github_com_line_lbm_sdk_types.Int `protobuf:"bytes,4,opt,name=amount,proto3,customtype=github.com/line/lbm-sdk/types.Int" json:"amount"`
}

func (m *EventBurned) Reset()         { *m = EventBurned{} }
func (m *EventBurned) String() string { return proto.CompactTextString(m) }
func (*EventBurned) ProtoMessage()    {}
func (*EventBurned) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{7}
}
func (m *EventBurned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBurned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBurned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBurned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBurned.Merge(m, src)
}
func (m *EventBurned) XXX_Size() int {
	return m.Size()
}
func (m *EventBurned) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBurned.DiscardUnknown(m)
}

var xxx_messageInfo_EventBurned proto.InternalMessageInfo

func (m *EventBurned) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventBurned) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventBurned) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

// EventModified is emitted when the information of a token class is modified.
//
// Since: 0.46.0 (finschia)
type EventModified struct {
	// contract id associated with the token class.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggered the modify.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// changes on the metadata of the class.
	Changes []Pair `protobuf:"bytes,3,rep,name=changes,proto3" json:"changes"`
}

func (m *EventModified) Reset()         { *m = EventModified{} }
func (m *EventModified) String() string { return proto.CompactTextString(m) }
func (*EventModified) ProtoMessage()    {}
func (*EventModified) Descriptor() ([]byte, []int) {
	return fileDescriptor_d7505f4c4cdec18e, []int{8}
}
func (m *EventModified) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventModified) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventModified.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventModified) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventModified.Merge(m, src)
}
func (m *EventModified) XXX_Size() int {
	return m.Size()
}
func (m *EventModified) XXX_DiscardUnknown() {
	xxx_messageInfo_EventModified.DiscardUnknown(m)
}

var xxx_messageInfo_EventModified proto.InternalMessageInfo

func (m *EventModified) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventModified) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventModified) GetChanges() []Pair {
	if m != nil {
		return m.Changes
	}
	return nil
}

func init() {
	proto.RegisterEnum("lbm.token.v1.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("lbm.token.v1.AttributeKey", AttributeKey_name, AttributeKey_value)
	proto.RegisterType((*EventSent)(nil), "lbm.token.v1.EventSent")
	proto.RegisterType((*EventAuthorizedOperator)(nil), "lbm.token.v1.EventAuthorizedOperator")
	proto.RegisterType((*EventRevokedOperator)(nil), "lbm.token.v1.EventRevokedOperator")
	proto.RegisterType((*EventIssue)(nil), "lbm.token.v1.EventIssue")
	proto.RegisterType((*EventGrant)(nil), "lbm.token.v1.EventGrant")
	proto.RegisterType((*EventAbandon)(nil), "lbm.token.v1.EventAbandon")
	proto.RegisterType((*EventMinted)(nil), "lbm.token.v1.EventMinted")
	proto.RegisterType((*EventBurned)(nil), "lbm.token.v1.EventBurned")
	proto.RegisterType((*EventModified)(nil), "lbm.token.v1.EventModified")
}

func init() { proto.RegisterFile("lbm/token/v1/event.proto", fileDescriptor_d7505f4c4cdec18e) }

var fileDescriptor_d7505f4c4cdec18e = []byte{
	// 1018 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcf, 0x6f, 0xe3, 0xc4,
	0x17, 0x8f, 0x9b, 0x5f, 0xed, 0x34, 0xad, 0xe6, 0x3b, 0xdf, 0x6e, 0xeb, 0x35, 0xc8, 0x35, 0x41,
	0xa0, 0x6e, 0x77, 0x37, 0xd1, 0x16, 0x0e, 0xc0, 0x2d, 0xd9, 0x66, 0x51, 0xb4, 0x6a, 0xb7, 0x72,
	0x53, 0xa4, 0xe5, 0x12, 0xd9, 0xc9, 0x34, 0xb5, 0x1a, 0xcf, 0x44, 0xe3, 0x49, 0xd8, 0x70, 0xe2,
	0x88, 0x7c, 0xe2, 0x8e, 0x7c, 0x40, 0xfc, 0x01, 0x1c, 0xf9, 0x07, 0x38, 0xec, 0x71, 0x8f, 0x88,
	0xc3, 0x0a, 0xb5, 0xff, 0x08, 0x9a, 0x19, 0xdb, 0x75, 0xe2, 0x45, 0x0b, 0x14, 0x6e, 0xf3, 0xe6,
	0x7d, 0x66, 0xde, 0x67, 0xde, 0x7b, 0x9f, 0x67, 0x03, 0x7d, 0xec, 0xfa, 0x4d, 0x4e, 0x2f, 0x31,
	0x69, 0xce, 0x1e, 0x35, 0xf1, 0x0c, 0x13, 0xde, 0x98, 0x30, 0xca, 0x29, 0xaa, 0x8d, 0x5d, 0xbf,
	0x21, 0x3d, 0x8d, 0xd9, 0x23, 0x63, 0x6b, 0x44, 0x47, 0x54, 0x3a, 0x9a, 0x62, 0xa5, 0x30, 0xc6,
	0xe2, 0x69, 0x05, 0x96, 0x9e, 0xfa, 0x4f, 0x1a, 0x58, 0xeb, 0x88, 0xdb, 0x4e, 0x31, 0xe1, 0x68,
	0x17, 0xac, 0x0f, 0x28, 0xe1, 0xcc, 0x19, 0xf0, 0xbe, 0x37, 0xd4, 0x35, 0x4b, 0xdb, 0x5b, 0xb3,
	0x41, 0xb2, 0xd5, 0x1d, 0x22, 0x03, 0xac, 0xd2, 0x09, 0x66, 0x0e, 0xa7, 0x4c, 0x5f, 0x91, 0xde,
	0xd4, 0x46, 0x08, 0x94, 0xce, 0x19, 0xf5, 0xf5, 0xa2, 0xdc, 0x97, 0x6b, 0xb4, 0x09, 0x56, 0x38,
	0xd5, 0x4b, 0x72, 0x67, 0x85, 0x53, 0xd4, 0x02, 0x15, 0xc7, 0xa7, 0x53, 0xc2, 0xf5, 0xb2, 0xd8,
	0x6b, 0xdf, 0x7b, 0xf9, 0x7a, 0xb7, 0xf0, 0xdb, 0xeb, 0xdd, 0xf7, 0x46, 0x1e, 0xbf, 0x98, 0xba,
	0x8d, 0x01, 0xf5, 0x9b, 0x63, 0x8f, 0xe0, 0xe6, 0xd8, 0xf5, 0x1f, 0x06, 0xc3, 0xcb, 0x26, 0x9f,
	0x4f, 0x70, 0xd0, 0xe8, 0x12, 0x6e, 0xc7, 0x07, 0xeb, 0x04, 0xec, 0x48, 0xc2, 0xad, 0x29, 0xbf,
	0xa0, 0xcc, 0xfb, 0x1a, 0x0f, 0x9f, 0x25, 0x0c, 0xde, 0x4a, 0x7f, 0x1b, 0x54, 0x2e, 0xe8, 0x78,
	0x88, 0x13, 0xf2, 0xb1, 0xb5, 0xf0, 0xac, 0xe2, 0xe2, 0xb3, 0xea, 0x97, 0x60, 0x4b, 0xc6, 0xb3,
	0xf1, 0x8c, 0x5e, 0xfe, 0xd7, 0xc1, 0x7e, 0xd6, 0x00, 0x90, 0xd1, 0xba, 0x41, 0x30, 0xc5, 0x6f,
	0x8f, 0x81, 0x40, 0x89, 0x38, 0x3e, 0x8e, 0x23, 0xc8, 0xb5, 0x88, 0x1b, 0xcc, 0x7d, 0x97, 0x8e,
	0xe3, 0xdb, 0x63, 0x0b, 0x41, 0x50, 0x9c, 0x32, 0x2f, 0x2e, 0x86, 0x58, 0x8a, 0xd3, 0x3e, 0xe6,
	0x8e, 0xaa, 0x85, 0x2d, 0xd7, 0x82, 0xdd, 0x10, 0x0f, 0x3c, 0xdf, 0x19, 0x07, 0x7a, 0xc5, 0xd2,
	0xf6, 0xca, 0x76, 0x6a, 0x0b, 0x9f, 0xef, 0x11, 0xee, 0xb8, 0x63, 0xac, 0x57, 0x2d, 0x6d, 0x6f,
	0xd5, 0x4e, 0xed, 0xfa, 0xf7, 0x09, 0xf3, 0xcf, 0x99, 0xf3, 0x57, 0x3a, 0x49, 0x07, 0xd5, 0x91,
	0x40, 0xa6, 0xe9, 0x49, 0xcc, 0x1b, 0x0f, 0x8e, 0x1f, 0x90, 0x98, 0xe8, 0x13, 0x00, 0x26, 0x98,
	0xf9, 0x5e, 0x10, 0x78, 0x94, 0xc8, 0x87, 0x6c, 0x1e, 0xe8, 0x8d, 0x6c, 0xff, 0x37, 0x4e, 0x52,
	0xbf, 0x9d, 0xc1, 0xd6, 0x3d, 0x50, 0x53, 0x4d, 0xe3, 0x3a, 0x64, 0x48, 0xc9, 0xdf, 0xa0, 0x87,
	0x17, 0xe9, 0x61, 0x64, 0x2e, 0x90, 0x50, 0x0c, 0xb3, 0xa1, 0x22, 0x0d, 0xac, 0xcb, 0x58, 0x47,
	0x1e, 0xe1, 0x78, 0x78, 0x3b, 0x4d, 0x29, 0xfd, 0x14, 0xdf, 0xa0, 0x9f, 0xd2, 0x3f, 0xd5, 0xcf,
	0x0f, 0x09, 0xbf, 0xf6, 0x94, 0x91, 0xdb, 0xf2, 0x7b, 0x93, 0xe6, 0xff, 0x05, 0x8e, 0xdf, 0x68,
	0x60, 0x43, 0xe5, 0x90, 0x0e, 0xbd, 0x73, 0xef, 0xb6, 0x2c, 0x0f, 0x40, 0x75, 0x70, 0xe1, 0x90,
	0x11, 0x0e, 0xf4, 0xa2, 0x55, 0xdc, 0x5b, 0x3f, 0x40, 0x4b, 0x4d, 0xe3, 0x78, 0xac, 0x5d, 0x12,
	0x34, 0xed, 0x04, 0xb8, 0x7f, 0x5d, 0x8c, 0x07, 0x63, 0x6f, 0x3e, 0xc1, 0xe8, 0x63, 0xb0, 0xdd,
	0xf9, 0xa2, 0x73, 0xdc, 0xeb, 0xf7, 0x9e, 0x9f, 0x74, 0xfa, 0x67, 0xc7, 0xa7, 0x27, 0x9d, 0xc7,
	0xdd, 0x27, 0xdd, 0xce, 0x21, 0x2c, 0x18, 0x7a, 0x18, 0x59, 0x5b, 0x29, 0xf4, 0x8c, 0x04, 0x13,
	0x3c, 0x50, 0xa4, 0xeb, 0xa0, 0xec, 0x09, 0x1d, 0x43, 0xcd, 0xd8, 0x09, 0x23, 0xeb, 0xff, 0x29,
	0x48, 0xaa, 0xbb, 0x27, 0xc2, 0x23, 0x0b, 0x94, 0x84, 0x86, 0xe0, 0x8a, 0xb1, 0x1d, 0x46, 0x16,
	0x4a, 0x21, 0xa2, 0x7b, 0x52, 0x84, 0x3b, 0x65, 0x04, 0x16, 0x97, 0x10, 0xa2, 0x7e, 0x0a, 0x71,
	0x0f, 0xac, 0x09, 0x44, 0x5f, 0xa4, 0x1f, 0x96, 0x0c, 0x23, 0x8c, 0xac, 0xed, 0x3c, 0xec, 0x89,
	0x28, 0xce, 0x3e, 0xa8, 0xf9, 0x22, 0xa7, 0xf3, 0xbe, 0x7c, 0x3d, 0x2c, 0x2f, 0xd1, 0x97, 0x09,
	0x9f, 0xab, 0x6b, 0xdf, 0x07, 0xab, 0x9c, 0x39, 0x24, 0x38, 0xc7, 0x0c, 0x56, 0x8c, 0x3b, 0x61,
	0x64, 0xfd, 0x2f, 0xc5, 0xf5, 0x62, 0x07, 0x7a, 0x00, 0x36, 0x12, 0x90, 0x8a, 0x5f, 0x35, 0xee,
	0x86, 0x91, 0x75, 0x27, 0x87, 0x94, 0xe1, 0xef, 0x03, 0x20, 0x75, 0xd4, 0x17, 0x82, 0x81, 0xab,
	0xc6, 0x3b, 0x61, 0x64, 0xed, 0xa4, 0x50, 0x39, 0x3a, 0x84, 0x82, 0x55, 0xfc, 0x87, 0x60, 0x9d,
	0xc9, 0xa1, 0xab, 0xd0, 0x6b, 0xc6, 0xbb, 0x61, 0x64, 0xe9, 0x29, 0x5a, 0x0d, 0xe4, 0x1b, 0xf8,
	0x03, 0xb0, 0xe1, 0x4c, 0x26, 0x8c, 0xce, 0x70, 0xfc, 0x36, 0xb0, 0xc4, 0xa4, 0xa5, 0xbc, 0x12,
	0x6d, 0x94, 0xbe, 0xfd, 0xd1, 0x2c, 0xec, 0xff, 0x52, 0x02, 0xb5, 0x16, 0xe7, 0xcc, 0x73, 0xa7,
	0x1c, 0x3f, 0xc5, 0x73, 0xf4, 0x19, 0xb8, 0xdb, 0xea, 0xf5, 0xec, 0x6e, 0xfb, 0xac, 0xd7, 0xe9,
	0x3f, 0xed, 0x3c, 0x5f, 0xaa, 0xb5, 0xe4, 0x9b, 0x3d, 0x90, 0x2d, 0xb7, 0xa9, 0x86, 0x31, 0xd4,
	0x8c, 0xad, 0x30, 0xb2, 0x60, 0x16, 0x76, 0x2c, 0x06, 0x73, 0x3d, 0x19, 0xcc, 0x49, 0xb1, 0xb3,
	0x88, 0x53, 0x35, 0xa4, 0x4d, 0x35, 0x92, 0x61, 0x31, 0x7f, 0xc7, 0x91, 0x18, 0xcf, 0xf7, 0x17,
	0x74, 0x90, 0x14, 0x3b, 0x0b, 0x7b, 0x9c, 0x68, 0xe2, 0x10, 0x59, 0xa0, 0x4c, 0xbf, 0x22, 0x98,
	0xc1, 0xb2, 0xaa, 0x5e, 0x16, 0xf6, 0x4c, 0x38, 0x04, 0x25, 0x25, 0x39, 0x58, 0xc9, 0x53, 0x6a,
	0x49, 0x0f, 0xfa, 0xf0, 0xe6, 0x8b, 0x00, 0xab, 0xaa, 0x5d, 0xb2, 0xa8, 0xc3, 0xe4, 0xeb, 0xf0,
	0x01, 0xa8, 0x7a, 0xfe, 0xa8, 0x3f, 0x65, 0x1e, 0x5c, 0xcd, 0xc3, 0xba, 0xbe, 0x33, 0xc2, 0x67,
	0x76, 0x57, 0x5c, 0x97, 0x7c, 0x34, 0xe0, 0x5a, 0x1e, 0x77, 0x14, 0xfb, 0x44, 0x26, 0x64, 0x3f,
	0x81, 0x7c, 0x26, 0x64, 0x2b, 0x19, 0x62, 0x34, 0xc2, 0x75, 0x03, 0x85, 0x91, 0xb5, 0x99, 0xf5,
	0xf6, 0xa8, 0x38, 0x2b, 0x5b, 0xa6, 0x96, 0x3f, 0x2b, 0xfa, 0x45, 0x70, 0x88, 0x5b, 0x85, 0xc1,
	0x8d, 0x3c, 0x87, 0xb8, 0x51, 0x98, 0x48, 0xe0, 0x84, 0xd1, 0x17, 0x73, 0xb8, 0x99, 0x4f, 0xe0,
	0x89, 0x70, 0xa8, 0x36, 0x6a, 0x7f, 0xfa, 0xf2, 0xca, 0xd4, 0x5e, 0x5d, 0x99, 0xda, 0xef, 0x57,
	0xa6, 0xf6, 0xdd, 0xb5, 0x59, 0x78, 0x75, 0x6d, 0x16, 0x7e, 0xbd, 0x36, 0x0b, 0x5f, 0xee, 0xfe,
	0xd9, 0xd0, 0x7b, 0xa1, 0x7e, 0xc3, 0xdc, 0x8a, 0xfc, 0x0f, 0xfb, 0xe8, 0x8f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xcf, 0xf2, 0xf6, 0x1a, 0xe1, 0x09, 0x00, 0x00,
}

func (m *EventSent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAuthorizedOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAuthorizedOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAuthorizedOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventRevokedOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRevokedOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRevokedOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventIssue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventIssue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventIssue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mintable {
		i--
		if m.Mintable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Decimals != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Meta) > 0 {
		i -= len(m.Meta)
		copy(dAtA[i:], m.Meta)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Meta)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permission != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.Permission))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Granter) > 0 {
		i -= len(m.Granter)
		copy(dAtA[i:], m.Granter)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Granter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAbandon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAbandon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAbandon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMinted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMinted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMinted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBurned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBurned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBurned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventModified) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventModified) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventModified) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventSent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *EventAuthorizedOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventRevokedOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventIssue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Meta)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovEvent(uint64(m.Decimals))
	}
	if m.Mintable {
		n += 2
	}
	return n
}

func (m *EventGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Granter)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.Permission != 0 {
		n += 1 + sovEvent(uint64(m.Permission))
	}
	return n
}

func (m *EventAbandon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventMinted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *EventBurned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *EventModified) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func sovEvent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventSent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAuthorizedOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAuthorizedOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAuthorizedOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRevokedOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRevokedOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRevokedOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventIssue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventIssue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventIssue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meta = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mintable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mintable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Granter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			m.Permission = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permission |= Permission(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAbandon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAbandon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAbandon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMinted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMinted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMinted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBurned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBurned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBurned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventModified) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventModified: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventModified: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, Pair{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvent = fmt.Errorf("proto: unexpected end of group")
)
