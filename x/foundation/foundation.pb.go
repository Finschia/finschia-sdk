// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lbm/foundation/v1/foundation.proto

package foundation

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/line/lbm-sdk/codec/types"
	github_com_line_lbm_sdk_types "github.com/line/lbm-sdk/types"
	_ "github.com/regen-network/cosmos-proto"
	_ "google.golang.org/protobuf/types/known/durationpb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// VoteOption enumerates the valid vote options for a given proposal.
type VoteOption int32

const (
	// VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
	VOTE_OPTION_UNSPECIFIED VoteOption = 0
	// VOTE_OPTION_YES defines a yes vote option.
	VOTE_OPTION_YES VoteOption = 1
	// VOTE_OPTION_ABSTAIN defines an abstain vote option.
	VOTE_OPTION_ABSTAIN VoteOption = 2
	// VOTE_OPTION_NO defines a no vote option.
	VOTE_OPTION_NO VoteOption = 3
	// VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
	VOTE_OPTION_NO_WITH_VETO VoteOption = 4
)

var VoteOption_name = map[int32]string{
	0: "VOTE_OPTION_UNSPECIFIED",
	1: "VOTE_OPTION_YES",
	2: "VOTE_OPTION_ABSTAIN",
	3: "VOTE_OPTION_NO",
	4: "VOTE_OPTION_NO_WITH_VETO",
}

var VoteOption_value = map[string]int32{
	"VOTE_OPTION_UNSPECIFIED":  0,
	"VOTE_OPTION_YES":          1,
	"VOTE_OPTION_ABSTAIN":      2,
	"VOTE_OPTION_NO":           3,
	"VOTE_OPTION_NO_WITH_VETO": 4,
}

func (x VoteOption) String() string {
	return proto.EnumName(VoteOption_name, int32(x))
}

func (VoteOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{0}
}

// ProposalStatus defines proposal statuses.
type ProposalStatus int32

const (
	// An empty value is invalid and not allowed.
	PROPOSAL_STATUS_UNSPECIFIED ProposalStatus = 0
	// Initial status of a proposal when persisted.
	PROPOSAL_STATUS_SUBMITTED ProposalStatus = 1
	// Final status of a proposal when the final tally was executed.
	PROPOSAL_STATUS_CLOSED ProposalStatus = 2
	// Final status of a proposal when the group was modified before the final tally.
	PROPOSAL_STATUS_ABORTED ProposalStatus = 3
	// A proposal can be deleted before the voting start time by the owner. When this happens the final status
	// is Withdrawn.
	PROPOSAL_STATUS_WITHDRAWN ProposalStatus = 4
)

var ProposalStatus_name = map[int32]string{
	0: "PROPOSAL_STATUS_UNSPECIFIED",
	1: "PROPOSAL_STATUS_SUBMITTED",
	2: "PROPOSAL_STATUS_CLOSED",
	3: "PROPOSAL_STATUS_ABORTED",
	4: "PROPOSAL_STATUS_WITHDRAWN",
}

var ProposalStatus_value = map[string]int32{
	"PROPOSAL_STATUS_UNSPECIFIED": 0,
	"PROPOSAL_STATUS_SUBMITTED":   1,
	"PROPOSAL_STATUS_CLOSED":      2,
	"PROPOSAL_STATUS_ABORTED":     3,
	"PROPOSAL_STATUS_WITHDRAWN":   4,
}

func (x ProposalStatus) String() string {
	return proto.EnumName(ProposalStatus_name, int32(x))
}

func (ProposalStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{1}
}

// ProposalResult defines types of proposal results.
type ProposalResult int32

const (
	// An empty value is invalid and not allowed
	PROPOSAL_RESULT_UNSPECIFIED ProposalResult = 0
	// Until a final tally has happened the status is unfinalized
	PROPOSAL_RESULT_UNFINALIZED ProposalResult = 1
	// Final result of the tally
	PROPOSAL_RESULT_ACCEPTED ProposalResult = 2
	// Final result of the tally
	PROPOSAL_RESULT_REJECTED ProposalResult = 3
)

var ProposalResult_name = map[int32]string{
	0: "PROPOSAL_RESULT_UNSPECIFIED",
	1: "PROPOSAL_RESULT_UNFINALIZED",
	2: "PROPOSAL_RESULT_ACCEPTED",
	3: "PROPOSAL_RESULT_REJECTED",
}

var ProposalResult_value = map[string]int32{
	"PROPOSAL_RESULT_UNSPECIFIED": 0,
	"PROPOSAL_RESULT_UNFINALIZED": 1,
	"PROPOSAL_RESULT_ACCEPTED":    2,
	"PROPOSAL_RESULT_REJECTED":    3,
}

func (x ProposalResult) String() string {
	return proto.EnumName(ProposalResult_name, int32(x))
}

func (ProposalResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{2}
}

// ProposalExecutorResult defines types of proposal executor results.
type ProposalExecutorResult int32

const (
	// An empty value is not allowed.
	PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED ProposalExecutorResult = 0
	// We have not yet run the executor.
	PROPOSAL_EXECUTOR_RESULT_NOT_RUN ProposalExecutorResult = 1
	// The executor was successful and proposed action updated state.
	PROPOSAL_EXECUTOR_RESULT_SUCCESS ProposalExecutorResult = 2
	// The executor returned an error and proposed action didn't update state.
	PROPOSAL_EXECUTOR_RESULT_FAILURE ProposalExecutorResult = 3
)

var ProposalExecutorResult_name = map[int32]string{
	0: "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED",
	1: "PROPOSAL_EXECUTOR_RESULT_NOT_RUN",
	2: "PROPOSAL_EXECUTOR_RESULT_SUCCESS",
	3: "PROPOSAL_EXECUTOR_RESULT_FAILURE",
}

var ProposalExecutorResult_value = map[string]int32{
	"PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED": 0,
	"PROPOSAL_EXECUTOR_RESULT_NOT_RUN":     1,
	"PROPOSAL_EXECUTOR_RESULT_SUCCESS":     2,
	"PROPOSAL_EXECUTOR_RESULT_FAILURE":     3,
}

func (x ProposalExecutorResult) String() string {
	return proto.EnumName(ProposalExecutorResult_name, int32(x))
}

func (ProposalExecutorResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{3}
}

// Params defines the parameters for the foundation module.
type Params struct {
	Enabled       bool                              `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	FoundationTax github_com_line_lbm_sdk_types.Dec `protobuf:"bytes,2,opt,name=foundation_tax,json=foundationTax,proto3,customtype=github.com/line/lbm-sdk/types.Dec" json:"foundation_tax"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

// ValidatorAuth defines authorization info of a validator.
type ValidatorAuth struct {
	OperatorAddress string `protobuf:"bytes,1,opt,name=operator_address,json=operatorAddress,proto3" json:"operator_address,omitempty"`
	CreationAllowed bool   `protobuf:"varint,2,opt,name=creation_allowed,json=creationAllowed,proto3" json:"creation_allowed,omitempty"`
}

func (m *ValidatorAuth) Reset()         { *m = ValidatorAuth{} }
func (m *ValidatorAuth) String() string { return proto.CompactTextString(m) }
func (*ValidatorAuth) ProtoMessage()    {}
func (*ValidatorAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{1}
}
func (m *ValidatorAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorAuth.Merge(m, src)
}
func (m *ValidatorAuth) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorAuth.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorAuth proto.InternalMessageInfo

func (m *ValidatorAuth) GetOperatorAddress() string {
	if m != nil {
		return m.OperatorAddress
	}
	return ""
}

func (m *ValidatorAuth) GetCreationAllowed() bool {
	if m != nil {
		return m.CreationAllowed
	}
	return false
}

// UpdateFoundationParamsProposal details a proposal to update params of foundation module.
type UpdateFoundationParamsProposal struct {
	Title       string  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string  `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Params      *Params `protobuf:"bytes,3,opt,name=params,proto3" json:"params,omitempty"`
}

func (m *UpdateFoundationParamsProposal) Reset()      { *m = UpdateFoundationParamsProposal{} }
func (*UpdateFoundationParamsProposal) ProtoMessage() {}
func (*UpdateFoundationParamsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{2}
}
func (m *UpdateFoundationParamsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateFoundationParamsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateFoundationParamsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateFoundationParamsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateFoundationParamsProposal.Merge(m, src)
}
func (m *UpdateFoundationParamsProposal) XXX_Size() int {
	return m.Size()
}
func (m *UpdateFoundationParamsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateFoundationParamsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateFoundationParamsProposal proto.InternalMessageInfo

// UpdateValidatorAuthsProposal details a proposal to update validator auths on foundation.
type UpdateValidatorAuthsProposal struct {
	Title       string          `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Description string          `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Auths       []ValidatorAuth `protobuf:"bytes,3,rep,name=auths,proto3" json:"auths"`
}

func (m *UpdateValidatorAuthsProposal) Reset()      { *m = UpdateValidatorAuthsProposal{} }
func (*UpdateValidatorAuthsProposal) ProtoMessage() {}
func (*UpdateValidatorAuthsProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{3}
}
func (m *UpdateValidatorAuthsProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateValidatorAuthsProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateValidatorAuthsProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateValidatorAuthsProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateValidatorAuthsProposal.Merge(m, src)
}
func (m *UpdateValidatorAuthsProposal) XXX_Size() int {
	return m.Size()
}
func (m *UpdateValidatorAuthsProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateValidatorAuthsProposal.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateValidatorAuthsProposal proto.InternalMessageInfo

// Member represents a foundation member with an account address and metadata.
type Member struct {
	// address is the member's account address.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// participating is the flag which allows one to remove the member by setting the flag to false.
	Participating bool `protobuf:"varint,2,opt,name=participating,proto3" json:"participating,omitempty"`
	// metadata is any arbitrary metadata to attached to the member.
	Metadata string `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// added_at is a timestamp specifying when a member was added.
	AddedAt time.Time `protobuf:"bytes,4,opt,name=added_at,json=addedAt,proto3,stdtime" json:"added_at"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{4}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Member) GetParticipating() bool {
	if m != nil {
		return m.Participating
	}
	return false
}

func (m *Member) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Member) GetAddedAt() time.Time {
	if m != nil {
		return m.AddedAt
	}
	return time.Time{}
}

// ThresholdDecisionPolicy implements the DecisionPolicy interface
type ThresholdDecisionPolicy struct {
	// threshold is the minimum sum of yes votes that must be met or exceeded for a proposal to succeed.
	Threshold github_com_line_lbm_sdk_types.Dec `protobuf:"bytes,1,opt,name=threshold,proto3,customtype=github.com/line/lbm-sdk/types.Dec" json:"threshold"`
	// windows defines the different windows for voting and execution.
	Windows *DecisionPolicyWindows `protobuf:"bytes,2,opt,name=windows,proto3" json:"windows,omitempty"`
}

func (m *ThresholdDecisionPolicy) Reset()         { *m = ThresholdDecisionPolicy{} }
func (m *ThresholdDecisionPolicy) String() string { return proto.CompactTextString(m) }
func (*ThresholdDecisionPolicy) ProtoMessage()    {}
func (*ThresholdDecisionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{5}
}
func (m *ThresholdDecisionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdDecisionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdDecisionPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdDecisionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdDecisionPolicy.Merge(m, src)
}
func (m *ThresholdDecisionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdDecisionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdDecisionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdDecisionPolicy proto.InternalMessageInfo

func (m *ThresholdDecisionPolicy) GetWindows() *DecisionPolicyWindows {
	if m != nil {
		return m.Windows
	}
	return nil
}

// PercentageDecisionPolicy implements the DecisionPolicy interface
type PercentageDecisionPolicy struct {
	// percentage is the minimum percentage the sum of yes votes must meet for a proposal to succeed.
	Percentage github_com_line_lbm_sdk_types.Dec `protobuf:"bytes,1,opt,name=percentage,proto3,customtype=github.com/line/lbm-sdk/types.Dec" json:"percentage"`
	// windows defines the different windows for voting and execution.
	Windows *DecisionPolicyWindows `protobuf:"bytes,2,opt,name=windows,proto3" json:"windows,omitempty"`
}

func (m *PercentageDecisionPolicy) Reset()         { *m = PercentageDecisionPolicy{} }
func (m *PercentageDecisionPolicy) String() string { return proto.CompactTextString(m) }
func (*PercentageDecisionPolicy) ProtoMessage()    {}
func (*PercentageDecisionPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{6}
}
func (m *PercentageDecisionPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PercentageDecisionPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PercentageDecisionPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PercentageDecisionPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PercentageDecisionPolicy.Merge(m, src)
}
func (m *PercentageDecisionPolicy) XXX_Size() int {
	return m.Size()
}
func (m *PercentageDecisionPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_PercentageDecisionPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_PercentageDecisionPolicy proto.InternalMessageInfo

func (m *PercentageDecisionPolicy) GetWindows() *DecisionPolicyWindows {
	if m != nil {
		return m.Windows
	}
	return nil
}

// DecisionPolicyWindows defines the different windows for voting and execution.
type DecisionPolicyWindows struct {
	// voting_period is the duration from submission of a proposal to the end of voting period
	// Within this times votes can be submitted with MsgVote.
	VotingPeriod time.Duration `protobuf:"bytes,1,opt,name=voting_period,json=votingPeriod,proto3,stdduration" json:"voting_period"`
	// min_execution_period is the minimum duration after the proposal submission
	// where members can start sending MsgExec. This means that the window for
	// sending a MsgExec transaction is:
	// `[ submission + min_execution_period ; submission + voting_period + max_execution_period]`
	// where max_execution_period is a app-specific config, defined in the keeper.
	// If not set, min_execution_period will default to 0.
	//
	// Please make sure to set a `min_execution_period` that is smaller than
	// `voting_period + max_execution_period`, or else the above execution window
	// is empty, meaning that all proposals created with this decision policy
	// won't be able to be executed.
	MinExecutionPeriod time.Duration `protobuf:"bytes,2,opt,name=min_execution_period,json=minExecutionPeriod,proto3,stdduration" json:"min_execution_period"`
}

func (m *DecisionPolicyWindows) Reset()         { *m = DecisionPolicyWindows{} }
func (m *DecisionPolicyWindows) String() string { return proto.CompactTextString(m) }
func (*DecisionPolicyWindows) ProtoMessage()    {}
func (*DecisionPolicyWindows) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{7}
}
func (m *DecisionPolicyWindows) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DecisionPolicyWindows) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DecisionPolicyWindows.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DecisionPolicyWindows) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecisionPolicyWindows.Merge(m, src)
}
func (m *DecisionPolicyWindows) XXX_Size() int {
	return m.Size()
}
func (m *DecisionPolicyWindows) XXX_DiscardUnknown() {
	xxx_messageInfo_DecisionPolicyWindows.DiscardUnknown(m)
}

var xxx_messageInfo_DecisionPolicyWindows proto.InternalMessageInfo

func (m *DecisionPolicyWindows) GetVotingPeriod() time.Duration {
	if m != nil {
		return m.VotingPeriod
	}
	return 0
}

func (m *DecisionPolicyWindows) GetMinExecutionPeriod() time.Duration {
	if m != nil {
		return m.MinExecutionPeriod
	}
	return 0
}

// FoundationInfo represents the high-level on-chain information for the foundation.
type FoundationInfo struct {
	// operator is the account address of the foundation's operator.
	Operator string `protobuf:"bytes,1,opt,name=operator,proto3" json:"operator,omitempty"`
	// version is used to track changes to the foundation's membership structure that
	// would break existing proposals. Whenever any member is added or removed,
	// this version is incremented and will cause proposals based on older versions
	// of the foundation to fail
	Version uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// total_weight is the number of the foundation members.
	TotalWeight github_com_line_lbm_sdk_types.Dec `protobuf:"bytes,3,opt,name=total_weight,json=totalWeight,proto3,customtype=github.com/line/lbm-sdk/types.Dec" json:"total_weight"`
	// decision_policy specifies the foundation's decision policy.
	DecisionPolicy *types.Any `protobuf:"bytes,4,opt,name=decision_policy,json=decisionPolicy,proto3" json:"decision_policy,omitempty"`
}

func (m *FoundationInfo) Reset()         { *m = FoundationInfo{} }
func (m *FoundationInfo) String() string { return proto.CompactTextString(m) }
func (*FoundationInfo) ProtoMessage()    {}
func (*FoundationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{8}
}
func (m *FoundationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FoundationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FoundationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FoundationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FoundationInfo.Merge(m, src)
}
func (m *FoundationInfo) XXX_Size() int {
	return m.Size()
}
func (m *FoundationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FoundationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FoundationInfo proto.InternalMessageInfo

// Proposal defines a foundation proposal. Any member of the foundation can submit a proposal
// for a group policy to decide upon.
// A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal
// passes as well as some optional metadata associated with the proposal.
type Proposal struct {
	// id is the unique id of the proposal.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// metadata is any arbitrary metadata to attached to the proposal.
	Metadata string `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// proposers are the account addresses of the proposers.
	Proposers []string `protobuf:"bytes,3,rep,name=proposers,proto3" json:"proposers,omitempty"`
	// submit_time is a timestamp specifying when a proposal was submitted.
	SubmitTime time.Time `protobuf:"bytes,4,opt,name=submit_time,json=submitTime,proto3,stdtime" json:"submit_time"`
	// foundation_version tracks the version of the foundation that this proposal corresponds to.
	// When foundation info is changed, existing proposals from previous foundation versions will become invalid.
	FoundationVersion uint64 `protobuf:"varint,5,opt,name=foundation_version,json=foundationVersion,proto3" json:"foundation_version,omitempty"`
	// status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
	Status ProposalStatus `protobuf:"varint,6,opt,name=status,proto3,enum=lbm.foundation.v1.ProposalStatus" json:"status,omitempty"`
	// result is the final result based on the votes and election rule. Initial value is unfinalized.
	// The result is persisted so that clients can always rely on this state and not have to replicate the logic.
	Result ProposalResult `protobuf:"varint,7,opt,name=result,proto3,enum=lbm.foundation.v1.ProposalResult" json:"result,omitempty"`
	// final_tally_result contains the sums of all votes for this
	// proposal for each vote option, after tallying. When querying a proposal
	// via gRPC, this field is not populated until the proposal's voting period
	// has ended.
	FinalTallyResult TallyResult `protobuf:"bytes,8,opt,name=final_tally_result,json=finalTallyResult,proto3" json:"final_tally_result"`
	// voting_period_end is the timestamp before which voting must be done.
	// Unless a successfull MsgExec is called before (to execute a proposal whose
	// tally is successful before the voting period ends), tallying will be done
	// at this point, and the `final_tally_result`, as well
	// as `status` and `result` fields will be accordingly updated.
	VotingPeriodEnd time.Time `protobuf:"bytes,9,opt,name=voting_period_end,json=votingPeriodEnd,proto3,stdtime" json:"voting_period_end"`
	// executor_result is the final result based on the votes and election rule. Initial value is NotRun.
	ExecutorResult ProposalExecutorResult `protobuf:"varint,10,opt,name=executor_result,json=executorResult,proto3,enum=lbm.foundation.v1.ProposalExecutorResult" json:"executor_result,omitempty"`
	// messages is a list of Msgs that will be executed if the proposal passes.
	Messages []*types.Any `protobuf:"bytes,11,rep,name=messages,proto3" json:"messages,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{9}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

// TallyResult represents the sum of votes for each vote option.
type TallyResult struct {
	// yes_count is the sum of yes votes.
	YesCount github_com_line_lbm_sdk_types.Dec `protobuf:"bytes,1,opt,name=yes_count,json=yesCount,proto3,customtype=github.com/line/lbm-sdk/types.Dec" json:"yes_count"`
	// abstain_count is the sum of abstainers.
	AbstainCount github_com_line_lbm_sdk_types.Dec `protobuf:"bytes,2,opt,name=abstain_count,json=abstainCount,proto3,customtype=github.com/line/lbm-sdk/types.Dec" json:"abstain_count"`
	// no is the sum of no votes.
	NoCount github_com_line_lbm_sdk_types.Dec `protobuf:"bytes,3,opt,name=no_count,json=noCount,proto3,customtype=github.com/line/lbm-sdk/types.Dec" json:"no_count"`
	// no_with_veto_count is the sum of veto.
	NoWithVetoCount github_com_line_lbm_sdk_types.Dec `protobuf:"bytes,4,opt,name=no_with_veto_count,json=noWithVetoCount,proto3,customtype=github.com/line/lbm-sdk/types.Dec" json:"no_with_veto_count"`
}

func (m *TallyResult) Reset()         { *m = TallyResult{} }
func (m *TallyResult) String() string { return proto.CompactTextString(m) }
func (*TallyResult) ProtoMessage()    {}
func (*TallyResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{10}
}
func (m *TallyResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TallyResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TallyResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TallyResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TallyResult.Merge(m, src)
}
func (m *TallyResult) XXX_Size() int {
	return m.Size()
}
func (m *TallyResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TallyResult.DiscardUnknown(m)
}

var xxx_messageInfo_TallyResult proto.InternalMessageInfo

// Vote represents a vote for a proposal.
type Vote struct {
	// proposal is the unique ID of the proposal.
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	// voter is the account address of the voter.
	Voter string `protobuf:"bytes,2,opt,name=voter,proto3" json:"voter,omitempty"`
	// option is the voter's choice on the proposal.
	Option VoteOption `protobuf:"varint,3,opt,name=option,proto3,enum=lbm.foundation.v1.VoteOption" json:"option,omitempty"`
	// metadata is any arbitrary metadata to attached to the vote.
	Metadata string `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// submit_time is the timestamp when the vote was submitted.
	SubmitTime time.Time `protobuf:"bytes,5,opt,name=submit_time,json=submitTime,proto3,stdtime" json:"submit_time"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_1980496a233f02f4, []int{11}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *Vote) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *Vote) GetOption() VoteOption {
	if m != nil {
		return m.Option
	}
	return VOTE_OPTION_UNSPECIFIED
}

func (m *Vote) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *Vote) GetSubmitTime() time.Time {
	if m != nil {
		return m.SubmitTime
	}
	return time.Time{}
}

func init() {
	proto.RegisterEnum("lbm.foundation.v1.VoteOption", VoteOption_name, VoteOption_value)
	proto.RegisterEnum("lbm.foundation.v1.ProposalStatus", ProposalStatus_name, ProposalStatus_value)
	proto.RegisterEnum("lbm.foundation.v1.ProposalResult", ProposalResult_name, ProposalResult_value)
	proto.RegisterEnum("lbm.foundation.v1.ProposalExecutorResult", ProposalExecutorResult_name, ProposalExecutorResult_value)
	proto.RegisterType((*Params)(nil), "lbm.foundation.v1.Params")
	proto.RegisterType((*ValidatorAuth)(nil), "lbm.foundation.v1.ValidatorAuth")
	proto.RegisterType((*UpdateFoundationParamsProposal)(nil), "lbm.foundation.v1.UpdateFoundationParamsProposal")
	proto.RegisterType((*UpdateValidatorAuthsProposal)(nil), "lbm.foundation.v1.UpdateValidatorAuthsProposal")
	proto.RegisterType((*Member)(nil), "lbm.foundation.v1.Member")
	proto.RegisterType((*ThresholdDecisionPolicy)(nil), "lbm.foundation.v1.ThresholdDecisionPolicy")
	proto.RegisterType((*PercentageDecisionPolicy)(nil), "lbm.foundation.v1.PercentageDecisionPolicy")
	proto.RegisterType((*DecisionPolicyWindows)(nil), "lbm.foundation.v1.DecisionPolicyWindows")
	proto.RegisterType((*FoundationInfo)(nil), "lbm.foundation.v1.FoundationInfo")
	proto.RegisterType((*Proposal)(nil), "lbm.foundation.v1.Proposal")
	proto.RegisterType((*TallyResult)(nil), "lbm.foundation.v1.TallyResult")
	proto.RegisterType((*Vote)(nil), "lbm.foundation.v1.Vote")
}

func init() {
	proto.RegisterFile("lbm/foundation/v1/foundation.proto", fileDescriptor_1980496a233f02f4)
}

var fileDescriptor_1980496a233f02f4 = []byte{
	// 1413 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x4d, 0x6f, 0x1b, 0xc5,
	0x1b, 0xf7, 0x3a, 0x4e, 0x62, 0x3f, 0x4e, 0x1c, 0x77, 0x9a, 0x7f, 0xeb, 0xa6, 0xa9, 0xed, 0x5a,
	0x39, 0xa4, 0x95, 0x6a, 0xff, 0x1b, 0xc4, 0x81, 0x0a, 0x09, 0xf9, 0x65, 0x43, 0x8d, 0x52, 0xdb,
	0xac, 0xd7, 0x09, 0xf4, 0xb2, 0x1a, 0x7b, 0x27, 0xce, 0x8a, 0xf5, 0xce, 0x6a, 0x77, 0x9c, 0x97,
	0x6f, 0xd0, 0x1b, 0x3d, 0x70, 0x28, 0xb7, 0x0a, 0x84, 0xc4, 0x89, 0x13, 0x07, 0x54, 0x89, 0x7b,
	0xe1, 0x54, 0x71, 0x01, 0x71, 0x28, 0x28, 0xbd, 0x70, 0xe1, 0xc2, 0x27, 0x40, 0x3b, 0xb3, 0x6b,
	0xaf, 0x5d, 0xb7, 0x60, 0x10, 0xb7, 0x3c, 0x2f, 0xbf, 0x67, 0x7e, 0xcf, 0xab, 0x37, 0x50, 0x30,
	0xbb, 0x83, 0xd2, 0x21, 0x1d, 0x5a, 0x3a, 0x66, 0x06, 0xb5, 0x4a, 0xc7, 0xb7, 0x43, 0x52, 0xd1,
	0x76, 0x28, 0xa3, 0xe8, 0x82, 0xd9, 0x1d, 0x14, 0x43, 0xda, 0xe3, 0xdb, 0x1b, 0xeb, 0x7d, 0xda,
	0xa7, 0xdc, 0x5a, 0xf2, 0xfe, 0x12, 0x8e, 0x1b, 0xd9, 0x3e, 0xa5, 0x7d, 0x93, 0x94, 0xb8, 0xd4,
	0x1d, 0x1e, 0x96, 0xf4, 0xa1, 0x13, 0x0a, 0xb4, 0x91, 0x9b, 0xb6, 0x33, 0x63, 0x40, 0x5c, 0x86,
	0x07, 0xb6, 0xef, 0x70, 0x65, 0xda, 0x01, 0x5b, 0x67, 0x81, 0xa9, 0x47, 0xdd, 0x01, 0x75, 0x35,
	0xf1, 0xa8, 0x10, 0x84, 0xa9, 0xc0, 0x60, 0xa9, 0x85, 0x1d, 0x3c, 0x70, 0x51, 0x06, 0x96, 0x89,
	0x85, 0xbb, 0x26, 0xd1, 0x33, 0x52, 0x5e, 0xda, 0x8e, 0x2b, 0x81, 0x88, 0x5a, 0x90, 0x1a, 0x67,
	0xa0, 0x31, 0x7c, 0x9a, 0x89, 0xe6, 0xa5, 0xed, 0x44, 0xe5, 0xc6, 0xd3, 0xe7, 0xb9, 0xc8, 0xcf,
	0xcf, 0x73, 0xd7, 0xfb, 0x06, 0x3b, 0x1a, 0x76, 0x8b, 0x3d, 0x3a, 0x28, 0x99, 0x86, 0x45, 0x4a,
	0x66, 0x77, 0x70, 0xcb, 0xd5, 0x3f, 0x2a, 0xb1, 0x33, 0x9b, 0xb8, 0xc5, 0x1a, 0xe9, 0x29, 0xab,
	0xe3, 0x00, 0x2a, 0x3e, 0x2d, 0x10, 0x58, 0xdd, 0xc7, 0xa6, 0xa1, 0x63, 0x46, 0x9d, 0xf2, 0x90,
	0x1d, 0xa1, 0x1b, 0x90, 0xa6, 0x36, 0x71, 0x3c, 0x59, 0xc3, 0xba, 0xee, 0x10, 0xd7, 0xe5, 0x2c,
	0x12, 0xca, 0x5a, 0xa0, 0x2f, 0x0b, 0xb5, 0xe7, 0xda, 0x73, 0x88, 0xe0, 0x82, 0x4d, 0x93, 0x9e,
	0x10, 0x9d, 0xf3, 0x89, 0x2b, 0x6b, 0x81, 0xbe, 0x2c, 0xd4, 0x85, 0x4f, 0x25, 0xc8, 0x76, 0x6c,
	0x1d, 0x33, 0xb2, 0x3b, 0x7a, 0x5e, 0x64, 0xdb, 0x72, 0xa8, 0x4d, 0x5d, 0x6c, 0xa2, 0x75, 0x58,
	0x64, 0x06, 0x33, 0x89, 0xff, 0x9a, 0x10, 0x50, 0x1e, 0x92, 0x3a, 0x71, 0x7b, 0x8e, 0x61, 0x7b,
	0x10, 0x91, 0xae, 0x12, 0x56, 0xa1, 0xdb, 0xb0, 0x64, 0xf3, 0x48, 0x99, 0x85, 0xbc, 0xb4, 0x9d,
	0xdc, 0xb9, 0x52, 0x7c, 0xa9, 0xd1, 0x45, 0xf1, 0x94, 0xe2, 0x3b, 0xde, 0x59, 0x79, 0xf0, 0x38,
	0x17, 0x79, 0xf4, 0x38, 0x17, 0xf9, 0xed, 0x71, 0x2e, 0x52, 0xf8, 0x4c, 0x82, 0x4d, 0xc1, 0x6d,
	0xa2, 0x12, 0xff, 0x9e, 0xd9, 0xdb, 0xb0, 0x88, 0xbd, 0x40, 0x99, 0x85, 0xfc, 0xc2, 0x76, 0x72,
	0x27, 0x3f, 0x83, 0xd8, 0xc4, 0x8b, 0x95, 0x98, 0xd7, 0x46, 0x45, 0x80, 0xa6, 0x48, 0x7e, 0x21,
	0xc1, 0xd2, 0x3d, 0x32, 0xe8, 0x12, 0xc7, 0x1b, 0x8f, 0xc9, 0xc6, 0x04, 0x22, 0xda, 0x82, 0x55,
	0x1b, 0x3b, 0xcc, 0xe8, 0x19, 0x36, 0x66, 0x86, 0xd5, 0xf7, 0xbb, 0x31, 0xa9, 0x44, 0x1b, 0x10,
	0x1f, 0x10, 0x86, 0x75, 0xcc, 0x30, 0x2f, 0x59, 0x42, 0x19, 0xc9, 0xe8, 0x1d, 0x88, 0x63, 0x5d,
	0x27, 0xba, 0x86, 0x59, 0x26, 0xc6, 0xcb, 0xb9, 0x51, 0x14, 0xd3, 0x5c, 0x0c, 0xa6, 0xb9, 0xa8,
	0x06, 0xe3, 0x5e, 0x89, 0x7b, 0x7c, 0x1f, 0xfe, 0x92, 0x93, 0x38, 0x05, 0xa2, 0x97, 0x59, 0xe1,
	0x89, 0x04, 0x97, 0xd5, 0x23, 0x87, 0xb8, 0x47, 0xd4, 0xd4, 0x6b, 0xa4, 0x67, 0xb8, 0x5e, 0xa7,
	0xa9, 0x69, 0xf4, 0xce, 0xd0, 0xbb, 0x90, 0x60, 0x81, 0x49, 0x50, 0x9f, 0x67, 0x70, 0xc7, 0x58,
	0x54, 0x81, 0xe5, 0x13, 0xc3, 0xd2, 0xe9, 0x89, 0xcb, 0x33, 0x4c, 0xee, 0x6c, 0xcf, 0x28, 0xed,
	0xe4, 0xe3, 0x07, 0xc2, 0x5f, 0x09, 0x80, 0x77, 0xd0, 0x0f, 0x5f, 0xdf, 0x4a, 0x4d, 0xfa, 0x14,
	0xbe, 0x95, 0x20, 0xd3, 0x22, 0x4e, 0x8f, 0x58, 0x0c, 0xf7, 0xc9, 0x14, 0xfb, 0x3a, 0x80, 0x3d,
	0xb2, 0xcd, 0x4f, 0x3f, 0x04, 0xfe, 0xcf, 0xf8, 0x7f, 0x23, 0xc1, 0xff, 0x66, 0xc2, 0xd0, 0x5d,
	0x58, 0x3d, 0xa6, 0x5e, 0xf7, 0x35, 0x9b, 0x38, 0x06, 0x15, 0xe5, 0xf7, 0x76, 0x65, 0xba, 0xb9,
	0x35, 0xff, 0xd6, 0x89, 0xde, 0x3e, 0xf2, 0x7a, 0xbb, 0x22, 0x90, 0x2d, 0x0e, 0x44, 0x1d, 0x58,
	0x1f, 0x18, 0x96, 0x46, 0x4e, 0x49, 0x6f, 0xc8, 0x37, 0xdf, 0x0f, 0x18, 0xfd, 0xfb, 0x01, 0xd1,
	0xc0, 0xb0, 0xe4, 0x00, 0x2f, 0xc2, 0x16, 0x7e, 0x97, 0x20, 0x35, 0x3e, 0x0d, 0x75, 0xeb, 0x90,
	0x7a, 0x73, 0x1a, 0x5c, 0x1c, 0x7f, 0xd0, 0x47, 0xb2, 0xb7, 0x03, 0xc7, 0xc4, 0x71, 0x83, 0xc5,
	0x8b, 0x29, 0x81, 0x88, 0xf6, 0x60, 0x85, 0x51, 0x86, 0x4d, 0xed, 0x84, 0x18, 0xfd, 0x23, 0x26,
	0x26, 0x7c, 0x9e, 0x46, 0x25, 0x39, 0xfc, 0x80, 0xa3, 0xd1, 0xfb, 0xb0, 0xa6, 0xfb, 0x05, 0xd5,
	0x6c, 0x5e, 0x51, 0x7f, 0x2d, 0xd6, 0x5f, 0x4a, 0xb4, 0x6c, 0x9d, 0x55, 0xd0, 0xf7, 0x2f, 0x35,
	0x45, 0x49, 0xe9, 0x13, 0xf2, 0x9d, 0x98, 0xb7, 0xd7, 0x85, 0x3f, 0x62, 0x10, 0x1f, 0x1d, 0x98,
	0x14, 0x44, 0x0d, 0xd1, 0x92, 0x98, 0x12, 0x35, 0xf4, 0x89, 0x0d, 0x8d, 0x4e, 0x6d, 0xe8, 0x26,
	0x24, 0x6c, 0x8e, 0x23, 0x8e, 0x38, 0x2c, 0x09, 0x65, 0xac, 0x40, 0x32, 0x24, 0xdd, 0x61, 0x77,
	0x60, 0x30, 0xcd, 0xfb, 0x51, 0x9a, 0x6b, 0x85, 0x41, 0x00, 0x3d, 0x13, 0xba, 0x05, 0x28, 0xf4,
	0x3b, 0x13, 0x54, 0x7a, 0x91, 0x13, 0xbc, 0x30, 0xb6, 0xec, 0xfb, 0x35, 0x7f, 0x0b, 0x96, 0x5c,
	0x86, 0xd9, 0xd0, 0xcd, 0x2c, 0xe5, 0xa5, 0xed, 0xd4, 0xce, 0xf5, 0x59, 0x27, 0xd8, 0x4f, 0xb6,
	0xcd, 0x1d, 0x15, 0x1f, 0xe0, 0x41, 0x1d, 0xe2, 0x0e, 0x4d, 0x96, 0x59, 0xfe, 0x4b, 0xa8, 0xc2,
	0x1d, 0x15, 0x1f, 0x80, 0x14, 0x40, 0x87, 0x86, 0x85, 0x4d, 0x8d, 0x61, 0xd3, 0x3c, 0xd3, 0xfc,
	0x30, 0x71, 0x9e, 0x72, 0x76, 0x46, 0x18, 0xd5, 0x73, 0x13, 0x31, 0xfc, 0x4b, 0x9b, 0xe6, 0xf8,
	0x90, 0x1e, 0xb5, 0xe0, 0xc2, 0xc4, 0x9e, 0x68, 0xc4, 0xd2, 0x33, 0x89, 0x39, 0xaa, 0xb8, 0x16,
	0x5e, 0x16, 0xd9, 0xd2, 0x91, 0x02, 0x6b, 0x62, 0x57, 0xa8, 0x13, 0x50, 0x04, 0x9e, 0xe9, 0x8d,
	0xd7, 0x64, 0x2a, 0xfb, 0x08, 0x3f, 0xe3, 0x14, 0x99, 0x90, 0xd1, 0xff, 0xbd, 0xf9, 0x70, 0x5d,
	0xdc, 0x27, 0x6e, 0x26, 0xc9, 0x7f, 0x5b, 0x66, 0x8e, 0xa3, 0x32, 0xf2, 0xf2, 0x87, 0xee, 0xbb,
	0x28, 0x24, 0xc3, 0xd9, 0xee, 0x42, 0xe2, 0x8c, 0xb8, 0x5a, 0x8f, 0x0e, 0x2d, 0x36, 0xff, 0x45,
	0x8b, 0x9f, 0x11, 0xb7, 0xea, 0x41, 0x51, 0x03, 0x56, 0x71, 0xd7, 0x65, 0xd8, 0xb0, 0xfc, 0x58,
	0x73, 0x7f, 0x95, 0xac, 0xf8, 0x78, 0x11, 0xaf, 0x06, 0x71, 0x8b, 0xfa, 0xa1, 0xe6, 0xde, 0xdf,
	0x65, 0x8b, 0x8a, 0x28, 0xfb, 0x80, 0x2c, 0xaa, 0x9d, 0x18, 0xec, 0x48, 0x3b, 0x26, 0x2c, 0x88,
	0x17, 0x9b, 0x37, 0xde, 0x9a, 0x45, 0x0f, 0x0c, 0x76, 0xb4, 0x4f, 0x98, 0x88, 0xeb, 0xd7, 0xf2,
	0x47, 0x09, 0x62, 0xfb, 0x94, 0x11, 0x94, 0x83, 0xa4, 0xed, 0xb7, 0x4d, 0x1b, 0x6d, 0x31, 0x04,
	0xaa, 0xba, 0xee, 0x7d, 0x3e, 0x1c, 0x53, 0x46, 0x1c, 0x7f, 0x95, 0x85, 0x80, 0xde, 0x84, 0x25,
	0x2a, 0xbe, 0x1c, 0x16, 0xf8, 0x38, 0x5c, 0x9b, 0xf5, 0x75, 0x40, 0x19, 0x69, 0x72, 0x27, 0xc5,
	0x77, 0x9e, 0x38, 0x0d, 0xb1, 0xa9, 0xd3, 0x30, 0xb5, 0xfc, 0x8b, 0xff, 0x6c, 0xf9, 0x6f, 0x7e,
	0x2c, 0x01, 0x8c, 0x5f, 0x46, 0x57, 0xe1, 0xf2, 0x7e, 0x53, 0x95, 0xb5, 0x66, 0x4b, 0xad, 0x37,
	0x1b, 0x5a, 0xa7, 0xd1, 0x6e, 0xc9, 0xd5, 0xfa, 0x6e, 0x5d, 0xae, 0xa5, 0x23, 0xe8, 0x22, 0xac,
	0x85, 0x8d, 0x1f, 0xca, 0xed, 0xb4, 0x84, 0x2e, 0xc3, 0xc5, 0xb0, 0xb2, 0x5c, 0x69, 0xab, 0xe5,
	0x7a, 0x23, 0x1d, 0x45, 0x08, 0x52, 0x61, 0x43, 0xa3, 0x99, 0x5e, 0x40, 0x9b, 0x90, 0x99, 0xd4,
	0x69, 0x07, 0x75, 0xf5, 0xae, 0xb6, 0x2f, 0xab, 0xcd, 0x74, 0x6c, 0x23, 0xf6, 0xe0, 0xf3, 0x6c,
	0xe4, 0xe6, 0x57, 0x12, 0xa4, 0x26, 0xef, 0x07, 0xca, 0xc1, 0xd5, 0x96, 0xd2, 0x6c, 0x35, 0xdb,
	0xe5, 0x3d, 0xad, 0xad, 0x96, 0xd5, 0x4e, 0x7b, 0x8a, 0xd9, 0x35, 0xb8, 0x32, 0xed, 0xd0, 0xee,
	0x54, 0xee, 0xd5, 0x55, 0x55, 0xae, 0xa5, 0x25, 0xb4, 0x01, 0x97, 0xa6, 0xcd, 0xd5, 0xbd, 0x66,
	0x5b, 0xae, 0xa5, 0xa3, 0x5e, 0xc6, 0xd3, 0xb6, 0x72, 0xa5, 0xa9, 0x78, 0xc0, 0x85, 0x59, 0x71,
	0x3d, 0xc2, 0x35, 0xa5, 0x7c, 0xd0, 0x18, 0x11, 0xfe, 0x24, 0x44, 0xd8, 0xdf, 0xb5, 0x30, 0x61,
	0x45, 0x6e, 0x77, 0xf6, 0xd4, 0x29, 0xc2, 0x33, 0x1d, 0x76, 0xeb, 0x8d, 0xf2, 0x5e, 0xfd, 0x3e,
	0xa7, 0xbc, 0x09, 0x99, 0x69, 0x87, 0x72, 0xb5, 0x2a, 0xb7, 0x54, 0x4e, 0x7a, 0x86, 0x55, 0x91,
	0xdf, 0x93, 0xab, 0x9c, 0xb5, 0x4f, 0xeb, 0x89, 0x04, 0x97, 0x66, 0x9f, 0x18, 0xb4, 0x0d, 0x5b,
	0x23, 0xb8, 0xfc, 0x81, 0x5c, 0xed, 0xa8, 0x4d, 0x65, 0x36, 0xcf, 0x2d, 0xc8, 0xbf, 0xd2, 0xb3,
	0xd1, 0x54, 0x35, 0xa5, 0xd3, 0x48, 0x4b, 0xaf, 0xf5, 0x6a, 0x77, 0xaa, 0x55, 0xb9, 0xdd, 0x4e,
	0x47, 0x5f, 0xeb, 0xb5, 0x5b, 0xae, 0xef, 0x75, 0x14, 0x39, 0x20, 0x5f, 0xa9, 0x7c, 0x79, 0x9e,
	0x95, 0x9e, 0x9e, 0x67, 0xa5, 0x67, 0xe7, 0x59, 0xe9, 0xd7, 0xf3, 0xac, 0xf4, 0xf0, 0x45, 0x36,
	0xf2, 0xec, 0x45, 0x36, 0xf2, 0xd3, 0x8b, 0x6c, 0xe4, 0xfe, 0xd6, 0xab, 0x16, 0xf9, 0x34, 0xf4,
	0x9f, 0x60, 0x77, 0x89, 0x2f, 0xc1, 0x1b, 0x7f, 0x06, 0x00, 0x00, 0xff, 0xff, 0xf2, 0x1b, 0xcf,
	0x69, 0x30, 0x0e, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if !this.FoundationTax.Equal(that1.FoundationTax) {
		return false
	}
	return true
}
func (this *ValidatorAuth) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorAuth)
	if !ok {
		that2, ok := that.(ValidatorAuth)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.OperatorAddress != that1.OperatorAddress {
		return false
	}
	if this.CreationAllowed != that1.CreationAllowed {
		return false
	}
	return true
}
func (this *Member) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Member)
	if !ok {
		that2, ok := that.(Member)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Participating != that1.Participating {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !this.AddedAt.Equal(that1.AddedAt) {
		return false
	}
	return true
}
func (this *ThresholdDecisionPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ThresholdDecisionPolicy)
	if !ok {
		that2, ok := that.(ThresholdDecisionPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Threshold.Equal(that1.Threshold) {
		return false
	}
	if !this.Windows.Equal(that1.Windows) {
		return false
	}
	return true
}
func (this *PercentageDecisionPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PercentageDecisionPolicy)
	if !ok {
		that2, ok := that.(PercentageDecisionPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Percentage.Equal(that1.Percentage) {
		return false
	}
	if !this.Windows.Equal(that1.Windows) {
		return false
	}
	return true
}
func (this *DecisionPolicyWindows) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DecisionPolicyWindows)
	if !ok {
		that2, ok := that.(DecisionPolicyWindows)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VotingPeriod != that1.VotingPeriod {
		return false
	}
	if this.MinExecutionPeriod != that1.MinExecutionPeriod {
		return false
	}
	return true
}
func (this *FoundationInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FoundationInfo)
	if !ok {
		that2, ok := that.(FoundationInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Operator != that1.Operator {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.TotalWeight.Equal(that1.TotalWeight) {
		return false
	}
	if !this.DecisionPolicy.Equal(that1.DecisionPolicy) {
		return false
	}
	return true
}
func (this *Proposal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Proposal)
	if !ok {
		that2, ok := that.(Proposal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if len(this.Proposers) != len(that1.Proposers) {
		return false
	}
	for i := range this.Proposers {
		if this.Proposers[i] != that1.Proposers[i] {
			return false
		}
	}
	if !this.SubmitTime.Equal(that1.SubmitTime) {
		return false
	}
	if this.FoundationVersion != that1.FoundationVersion {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Result != that1.Result {
		return false
	}
	if !this.FinalTallyResult.Equal(&that1.FinalTallyResult) {
		return false
	}
	if !this.VotingPeriodEnd.Equal(that1.VotingPeriodEnd) {
		return false
	}
	if this.ExecutorResult != that1.ExecutorResult {
		return false
	}
	if len(this.Messages) != len(that1.Messages) {
		return false
	}
	for i := range this.Messages {
		if !this.Messages[i].Equal(that1.Messages[i]) {
			return false
		}
	}
	return true
}
func (this *TallyResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TallyResult)
	if !ok {
		that2, ok := that.(TallyResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.YesCount.Equal(that1.YesCount) {
		return false
	}
	if !this.AbstainCount.Equal(that1.AbstainCount) {
		return false
	}
	if !this.NoCount.Equal(that1.NoCount) {
		return false
	}
	if !this.NoWithVetoCount.Equal(that1.NoWithVetoCount) {
		return false
	}
	return true
}
func (this *Vote) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Vote)
	if !ok {
		that2, ok := that.(Vote)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProposalId != that1.ProposalId {
		return false
	}
	if this.Voter != that1.Voter {
		return false
	}
	if this.Option != that1.Option {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if !this.SubmitTime.Equal(that1.SubmitTime) {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.FoundationTax.Size()
		i -= size
		if _, err := m.FoundationTax.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFoundation(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreationAllowed {
		i--
		if m.CreationAllowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.OperatorAddress) > 0 {
		i -= len(m.OperatorAddress)
		copy(dAtA[i:], m.OperatorAddress)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.OperatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateFoundationParamsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateFoundationParamsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateFoundationParamsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Params != nil {
		{
			size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFoundation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateValidatorAuthsProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateValidatorAuthsProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateValidatorAuthsProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Auths) > 0 {
		for iNdEx := len(m.Auths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Auths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFoundation(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.AddedAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.AddedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintFoundation(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x22
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Participating {
		i--
		if m.Participating {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdDecisionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdDecisionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdDecisionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Windows != nil {
		{
			size, err := m.Windows.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFoundation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Threshold.Size()
		i -= size
		if _, err := m.Threshold.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFoundation(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PercentageDecisionPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PercentageDecisionPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PercentageDecisionPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Windows != nil {
		{
			size, err := m.Windows.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFoundation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size := m.Percentage.Size()
		i -= size
		if _, err := m.Percentage.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFoundation(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *DecisionPolicyWindows) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DecisionPolicyWindows) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DecisionPolicyWindows) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n5, err5 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.MinExecutionPeriod, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.MinExecutionPeriod):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintFoundation(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x12
	n6, err6 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.VotingPeriod, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.VotingPeriod):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintFoundation(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *FoundationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FoundationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FoundationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DecisionPolicy != nil {
		{
			size, err := m.DecisionPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFoundation(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size := m.TotalWeight.Size()
		i -= size
		if _, err := m.TotalWeight.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFoundation(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Version != 0 {
		i = encodeVarintFoundation(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for iNdEx := len(m.Messages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Messages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFoundation(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.ExecutorResult != 0 {
		i = encodeVarintFoundation(dAtA, i, uint64(m.ExecutorResult))
		i--
		dAtA[i] = 0x50
	}
	n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.VotingPeriodEnd, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.VotingPeriodEnd):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintFoundation(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.FinalTallyResult.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFoundation(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.Result != 0 {
		i = encodeVarintFoundation(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x38
	}
	if m.Status != 0 {
		i = encodeVarintFoundation(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.FoundationVersion != 0 {
		i = encodeVarintFoundation(dAtA, i, uint64(m.FoundationVersion))
		i--
		dAtA[i] = 0x28
	}
	n10, err10 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.SubmitTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.SubmitTime):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintFoundation(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x22
	if len(m.Proposers) > 0 {
		for iNdEx := len(m.Proposers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Proposers[iNdEx])
			copy(dAtA[i:], m.Proposers[iNdEx])
			i = encodeVarintFoundation(dAtA, i, uint64(len(m.Proposers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintFoundation(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TallyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TallyResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TallyResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.NoWithVetoCount.Size()
		i -= size
		if _, err := m.NoWithVetoCount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFoundation(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.NoCount.Size()
		i -= size
		if _, err := m.NoCount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFoundation(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.AbstainCount.Size()
		i -= size
		if _, err := m.AbstainCount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFoundation(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.YesCount.Size()
		i -= size
		if _, err := m.YesCount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFoundation(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n11, err11 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.SubmitTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.SubmitTime):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintFoundation(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x2a
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if m.Option != 0 {
		i = encodeVarintFoundation(dAtA, i, uint64(m.Option))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintFoundation(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarintFoundation(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFoundation(dAtA []byte, offset int, v uint64) int {
	offset -= sovFoundation(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = m.FoundationTax.Size()
	n += 1 + l + sovFoundation(uint64(l))
	return n
}

func (m *ValidatorAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OperatorAddress)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	if m.CreationAllowed {
		n += 2
	}
	return n
}

func (m *UpdateFoundationParamsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	if m.Params != nil {
		l = m.Params.Size()
		n += 1 + l + sovFoundation(uint64(l))
	}
	return n
}

func (m *UpdateValidatorAuthsProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	if len(m.Auths) > 0 {
		for _, e := range m.Auths {
			l = e.Size()
			n += 1 + l + sovFoundation(uint64(l))
		}
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	if m.Participating {
		n += 2
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.AddedAt)
	n += 1 + l + sovFoundation(uint64(l))
	return n
}

func (m *ThresholdDecisionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Threshold.Size()
	n += 1 + l + sovFoundation(uint64(l))
	if m.Windows != nil {
		l = m.Windows.Size()
		n += 1 + l + sovFoundation(uint64(l))
	}
	return n
}

func (m *PercentageDecisionPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Percentage.Size()
	n += 1 + l + sovFoundation(uint64(l))
	if m.Windows != nil {
		l = m.Windows.Size()
		n += 1 + l + sovFoundation(uint64(l))
	}
	return n
}

func (m *DecisionPolicyWindows) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.VotingPeriod)
	n += 1 + l + sovFoundation(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.MinExecutionPeriod)
	n += 1 + l + sovFoundation(uint64(l))
	return n
}

func (m *FoundationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovFoundation(uint64(m.Version))
	}
	l = m.TotalWeight.Size()
	n += 1 + l + sovFoundation(uint64(l))
	if m.DecisionPolicy != nil {
		l = m.DecisionPolicy.Size()
		n += 1 + l + sovFoundation(uint64(l))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovFoundation(uint64(m.Id))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	if len(m.Proposers) > 0 {
		for _, s := range m.Proposers {
			l = len(s)
			n += 1 + l + sovFoundation(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.SubmitTime)
	n += 1 + l + sovFoundation(uint64(l))
	if m.FoundationVersion != 0 {
		n += 1 + sovFoundation(uint64(m.FoundationVersion))
	}
	if m.Status != 0 {
		n += 1 + sovFoundation(uint64(m.Status))
	}
	if m.Result != 0 {
		n += 1 + sovFoundation(uint64(m.Result))
	}
	l = m.FinalTallyResult.Size()
	n += 1 + l + sovFoundation(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.VotingPeriodEnd)
	n += 1 + l + sovFoundation(uint64(l))
	if m.ExecutorResult != 0 {
		n += 1 + sovFoundation(uint64(m.ExecutorResult))
	}
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovFoundation(uint64(l))
		}
	}
	return n
}

func (m *TallyResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.YesCount.Size()
	n += 1 + l + sovFoundation(uint64(l))
	l = m.AbstainCount.Size()
	n += 1 + l + sovFoundation(uint64(l))
	l = m.NoCount.Size()
	n += 1 + l + sovFoundation(uint64(l))
	l = m.NoWithVetoCount.Size()
	n += 1 + l + sovFoundation(uint64(l))
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovFoundation(uint64(m.ProposalId))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	if m.Option != 0 {
		n += 1 + sovFoundation(uint64(m.Option))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovFoundation(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.SubmitTime)
	n += 1 + l + sovFoundation(uint64(l))
	return n
}

func sovFoundation(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFoundation(x uint64) (n int) {
	return sovFoundation(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundationTax", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FoundationTax.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationAllowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreationAllowed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateFoundationParamsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateFoundationParamsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateFoundationParamsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Params == nil {
				m.Params = &Params{}
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateValidatorAuthsProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateValidatorAuthsProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateValidatorAuthsProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Auths = append(m.Auths, ValidatorAuth{})
			if err := m.Auths[len(m.Auths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participating", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Participating = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.AddedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdDecisionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdDecisionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdDecisionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Windows == nil {
				m.Windows = &DecisionPolicyWindows{}
			}
			if err := m.Windows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PercentageDecisionPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PercentageDecisionPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PercentageDecisionPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Percentage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Percentage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Windows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Windows == nil {
				m.Windows = &DecisionPolicyWindows{}
			}
			if err := m.Windows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecisionPolicyWindows) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecisionPolicyWindows: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecisionPolicyWindows: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.VotingPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinExecutionPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.MinExecutionPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FoundationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FoundationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FoundationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalWeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DecisionPolicy == nil {
				m.DecisionPolicy = &types.Any{}
			}
			if err := m.DecisionPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposers = append(m.Proposers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.SubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundationVersion", wireType)
			}
			m.FoundationVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FoundationVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ProposalStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ProposalResult(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalTallyResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FinalTallyResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPeriodEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.VotingPeriodEnd, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutorResult", wireType)
			}
			m.ExecutorResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutorResult |= ProposalExecutorResult(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &types.Any{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TallyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TallyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TallyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YesCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.YesCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbstainCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AbstainCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NoCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWithVetoCount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.NoWithVetoCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			m.Option = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Option |= VoteOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFoundation
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFoundation
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.SubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFoundation(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFoundation
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFoundation(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFoundation
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFoundation
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFoundation
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFoundation
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFoundation
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFoundation        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFoundation          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFoundation = fmt.Errorf("proto: unexpected end of group")
)
