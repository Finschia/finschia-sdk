// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lbm/collection/v1/tx.proto

package collection

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	github_com_line_lbm_sdk_types "github.com/line/lbm-sdk/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgSend is the Msg/Send request type.
//
// Throws:
// - ErrInvalidAddress
//   - `from` is of invalid format.
//   - `to` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `amount` is not positive.
//
// Signer: `from`
//
// Since: 0.46.0 (finschia)
type MsgSend struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// holder whose tokens are being sent.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// recipient of the tokens.
	To string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// amount of tokens to send.
	Amount Coins `protobuf:"bytes,4,rep,name=amount,proto3,castrepeated=Coins" json:"amount"`
}

func (m *MsgSend) Reset()         { *m = MsgSend{} }
func (m *MsgSend) String() string { return proto.CompactTextString(m) }
func (*MsgSend) ProtoMessage()    {}
func (*MsgSend) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{0}
}
func (m *MsgSend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSend.Merge(m, src)
}
func (m *MsgSend) XXX_Size() int {
	return m.Size()
}
func (m *MsgSend) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSend.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSend proto.InternalMessageInfo

func (m *MsgSend) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgSend) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgSend) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *MsgSend) GetAmount() Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

// MsgSendResponse is the Msg/Send response type.
//
// Since: 0.46.0 (finschia)
type MsgSendResponse struct {
}

func (m *MsgSendResponse) Reset()         { *m = MsgSendResponse{} }
func (m *MsgSendResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSendResponse) ProtoMessage()    {}
func (*MsgSendResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{1}
}
func (m *MsgSendResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendResponse.Merge(m, src)
}
func (m *MsgSendResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendResponse proto.InternalMessageInfo

// MsgOperatorSend is the Msg/OperatorSend request type.
//
// Throws:
// - ErrInvalidAddress
//   - `operator` is of invalid format.
//   - `from` is of invalid format.
//   - `to` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `amount` is not positive.
//
// Signer: `operator`
//
// Since: 0.46.0 (finschia)
type MsgOperatorSend struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggers the send.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// holder whose tokens are being sent.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// recipient of the tokens.
	To string `protobuf:"bytes,4,opt,name=to,proto3" json:"to,omitempty"`
	// amount of tokens to send.
	Amount Coins `protobuf:"bytes,5,rep,name=amount,proto3,castrepeated=Coins" json:"amount"`
}

func (m *MsgOperatorSend) Reset()         { *m = MsgOperatorSend{} }
func (m *MsgOperatorSend) String() string { return proto.CompactTextString(m) }
func (*MsgOperatorSend) ProtoMessage()    {}
func (*MsgOperatorSend) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{2}
}
func (m *MsgOperatorSend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOperatorSend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOperatorSend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOperatorSend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOperatorSend.Merge(m, src)
}
func (m *MsgOperatorSend) XXX_Size() int {
	return m.Size()
}
func (m *MsgOperatorSend) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOperatorSend.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOperatorSend proto.InternalMessageInfo

func (m *MsgOperatorSend) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgOperatorSend) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *MsgOperatorSend) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgOperatorSend) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *MsgOperatorSend) GetAmount() Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

// MsgOperatorSendResponse is the Msg/OperatorSend response type.
//
// Since: 0.46.0 (finschia)
type MsgOperatorSendResponse struct {
}

func (m *MsgOperatorSendResponse) Reset()         { *m = MsgOperatorSendResponse{} }
func (m *MsgOperatorSendResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOperatorSendResponse) ProtoMessage()    {}
func (*MsgOperatorSendResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{3}
}
func (m *MsgOperatorSendResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOperatorSendResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOperatorSendResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOperatorSendResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOperatorSendResponse.Merge(m, src)
}
func (m *MsgOperatorSendResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOperatorSendResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOperatorSendResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOperatorSendResponse proto.InternalMessageInfo

// Deprecated: use MsgSend
//
// MsgTransferFT is the Msg/TransferFT request type.
type MsgTransferFT struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// the address which the transfer is from.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// the address which the transfer is to.
	To string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// the amount of the transfer.
	// Note: amount may be empty.
	Amount []Coin `protobuf:"bytes,4,rep,name=amount,proto3" json:"amount"`
}

func (m *MsgTransferFT) Reset()         { *m = MsgTransferFT{} }
func (m *MsgTransferFT) String() string { return proto.CompactTextString(m) }
func (*MsgTransferFT) ProtoMessage()    {}
func (*MsgTransferFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{4}
}
func (m *MsgTransferFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferFT.Merge(m, src)
}
func (m *MsgTransferFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferFT proto.InternalMessageInfo

func (m *MsgTransferFT) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgTransferFT) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgTransferFT) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *MsgTransferFT) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// Deprecated: do not use
//
// MsgTransferFTResponse is the Msg/TransferFT response type.
type MsgTransferFTResponse struct {
}

func (m *MsgTransferFTResponse) Reset()         { *m = MsgTransferFTResponse{} }
func (m *MsgTransferFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTransferFTResponse) ProtoMessage()    {}
func (*MsgTransferFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{5}
}
func (m *MsgTransferFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferFTResponse.Merge(m, src)
}
func (m *MsgTransferFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferFTResponse proto.InternalMessageInfo

// Deprecated: use MsgOperatorSend
//
// MsgTransferFTFrom is the Msg/TransferFTFrom request type.
type MsgTransferFTFrom struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// the address of the operator.
	Proxy string `protobuf:"bytes,2,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// the address which the transfer is from.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// the address which the transfer is to.
	To string `protobuf:"bytes,4,opt,name=to,proto3" json:"to,omitempty"`
	// the amount of the transfer.
	// Note: amount may be empty.
	Amount []Coin `protobuf:"bytes,5,rep,name=amount,proto3" json:"amount"`
}

func (m *MsgTransferFTFrom) Reset()         { *m = MsgTransferFTFrom{} }
func (m *MsgTransferFTFrom) String() string { return proto.CompactTextString(m) }
func (*MsgTransferFTFrom) ProtoMessage()    {}
func (*MsgTransferFTFrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{6}
}
func (m *MsgTransferFTFrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferFTFrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferFTFrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferFTFrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferFTFrom.Merge(m, src)
}
func (m *MsgTransferFTFrom) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferFTFrom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferFTFrom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferFTFrom proto.InternalMessageInfo

func (m *MsgTransferFTFrom) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgTransferFTFrom) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *MsgTransferFTFrom) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgTransferFTFrom) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *MsgTransferFTFrom) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// Deprecated: do not use
//
// MsgTransferFTFromResponse is the Msg/TransferFTFrom response type.
type MsgTransferFTFromResponse struct {
}

func (m *MsgTransferFTFromResponse) Reset()         { *m = MsgTransferFTFromResponse{} }
func (m *MsgTransferFTFromResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTransferFTFromResponse) ProtoMessage()    {}
func (*MsgTransferFTFromResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{7}
}
func (m *MsgTransferFTFromResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferFTFromResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferFTFromResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferFTFromResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferFTFromResponse.Merge(m, src)
}
func (m *MsgTransferFTFromResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferFTFromResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferFTFromResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferFTFromResponse proto.InternalMessageInfo

// Deprecated: use MsgSend
//
// MsgTransferNFT is the Msg/TransferNFT request type.
type MsgTransferNFT struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// the address which the transfer is from.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// the address which the transfer is to.
	To string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// the token ids to transfer.
	TokenIds []string `protobuf:"bytes,4,rep,name=token_ids,json=tokenIds,proto3" json:"token_ids,omitempty"`
}

func (m *MsgTransferNFT) Reset()         { *m = MsgTransferNFT{} }
func (m *MsgTransferNFT) String() string { return proto.CompactTextString(m) }
func (*MsgTransferNFT) ProtoMessage()    {}
func (*MsgTransferNFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{8}
}
func (m *MsgTransferNFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferNFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferNFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferNFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferNFT.Merge(m, src)
}
func (m *MsgTransferNFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferNFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferNFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferNFT proto.InternalMessageInfo

func (m *MsgTransferNFT) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgTransferNFT) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgTransferNFT) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *MsgTransferNFT) GetTokenIds() []string {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

// Deprecated: do not use
//
// MsgTransferNFTResponse is the Msg/TransferNFT response type.
type MsgTransferNFTResponse struct {
}

func (m *MsgTransferNFTResponse) Reset()         { *m = MsgTransferNFTResponse{} }
func (m *MsgTransferNFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTransferNFTResponse) ProtoMessage()    {}
func (*MsgTransferNFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{9}
}
func (m *MsgTransferNFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferNFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferNFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferNFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferNFTResponse.Merge(m, src)
}
func (m *MsgTransferNFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferNFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferNFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferNFTResponse proto.InternalMessageInfo

// Deprecated: use MsgOperatorSend
//
// MsgTransferNFTFrom is the Msg/TransferNFTFrom request type.
type MsgTransferNFTFrom struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// the address of the operator.
	Proxy string `protobuf:"bytes,2,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// the address which the transfer is from.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// the address which the transfer is to.
	To string `protobuf:"bytes,4,opt,name=to,proto3" json:"to,omitempty"`
	// the token ids to transfer.
	TokenIds []string `protobuf:"bytes,5,rep,name=token_ids,json=tokenIds,proto3" json:"token_ids,omitempty"`
}

func (m *MsgTransferNFTFrom) Reset()         { *m = MsgTransferNFTFrom{} }
func (m *MsgTransferNFTFrom) String() string { return proto.CompactTextString(m) }
func (*MsgTransferNFTFrom) ProtoMessage()    {}
func (*MsgTransferNFTFrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{10}
}
func (m *MsgTransferNFTFrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferNFTFrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferNFTFrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferNFTFrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferNFTFrom.Merge(m, src)
}
func (m *MsgTransferNFTFrom) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferNFTFrom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferNFTFrom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferNFTFrom proto.InternalMessageInfo

func (m *MsgTransferNFTFrom) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgTransferNFTFrom) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *MsgTransferNFTFrom) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgTransferNFTFrom) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *MsgTransferNFTFrom) GetTokenIds() []string {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

// Deprecated: do not use
//
// MsgTransferNFTFromResponse is the Msg/TransferNFTFrom response type.
type MsgTransferNFTFromResponse struct {
}

func (m *MsgTransferNFTFromResponse) Reset()         { *m = MsgTransferNFTFromResponse{} }
func (m *MsgTransferNFTFromResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTransferNFTFromResponse) ProtoMessage()    {}
func (*MsgTransferNFTFromResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{11}
}
func (m *MsgTransferNFTFromResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferNFTFromResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferNFTFromResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferNFTFromResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferNFTFromResponse.Merge(m, src)
}
func (m *MsgTransferNFTFromResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferNFTFromResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferNFTFromResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferNFTFromResponse proto.InternalMessageInfo

// MsgAuthorizeOperator is the Msg/AuthorizeOperator request type.
//
// Throws:
// - ErrInvalidAddress
//   - `holder` is of invalid format.
//   - `operator` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//
// Signer: `holder`
//
// Since: 0.46.0 (finschia)
type MsgAuthorizeOperator struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of a holder which authorizes the `operator` address as an operator.
	Holder string `protobuf:"bytes,2,opt,name=holder,proto3" json:"holder,omitempty"`
	// address to set as an operator for `holder`.
	Operator string `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *MsgAuthorizeOperator) Reset()         { *m = MsgAuthorizeOperator{} }
func (m *MsgAuthorizeOperator) String() string { return proto.CompactTextString(m) }
func (*MsgAuthorizeOperator) ProtoMessage()    {}
func (*MsgAuthorizeOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{12}
}
func (m *MsgAuthorizeOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAuthorizeOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAuthorizeOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAuthorizeOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAuthorizeOperator.Merge(m, src)
}
func (m *MsgAuthorizeOperator) XXX_Size() int {
	return m.Size()
}
func (m *MsgAuthorizeOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAuthorizeOperator.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAuthorizeOperator proto.InternalMessageInfo

func (m *MsgAuthorizeOperator) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgAuthorizeOperator) GetHolder() string {
	if m != nil {
		return m.Holder
	}
	return ""
}

func (m *MsgAuthorizeOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// MsgAuthorizeOperatorResponse is the Msg/AuthorizeOperator response type.
//
// Since: 0.46.0 (finschia)
type MsgAuthorizeOperatorResponse struct {
}

func (m *MsgAuthorizeOperatorResponse) Reset()         { *m = MsgAuthorizeOperatorResponse{} }
func (m *MsgAuthorizeOperatorResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAuthorizeOperatorResponse) ProtoMessage()    {}
func (*MsgAuthorizeOperatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{13}
}
func (m *MsgAuthorizeOperatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAuthorizeOperatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAuthorizeOperatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAuthorizeOperatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAuthorizeOperatorResponse.Merge(m, src)
}
func (m *MsgAuthorizeOperatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAuthorizeOperatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAuthorizeOperatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAuthorizeOperatorResponse proto.InternalMessageInfo

// MsgRevokeOperator is the Msg/RevokeOperator request type.
//
// Throws:
// - ErrInvalidAddress
//   - `holder` is of invalid format.
//   - `operator` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//
// Signer: `holder`
//
// Since: 0.46.0 (finschia)
type MsgRevokeOperator struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of a holder which revokes the `operator` address as an operator.
	Holder string `protobuf:"bytes,2,opt,name=holder,proto3" json:"holder,omitempty"`
	// address to rescind as an operator for `holder`.
	Operator string `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *MsgRevokeOperator) Reset()         { *m = MsgRevokeOperator{} }
func (m *MsgRevokeOperator) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeOperator) ProtoMessage()    {}
func (*MsgRevokeOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{14}
}
func (m *MsgRevokeOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokeOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokeOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokeOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokeOperator.Merge(m, src)
}
func (m *MsgRevokeOperator) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokeOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokeOperator.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokeOperator proto.InternalMessageInfo

func (m *MsgRevokeOperator) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgRevokeOperator) GetHolder() string {
	if m != nil {
		return m.Holder
	}
	return ""
}

func (m *MsgRevokeOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// MsgRevokeOperatorResponse is the Msg/RevokeOperator response type.
//
// Since: 0.46.0 (finschia)
type MsgRevokeOperatorResponse struct {
}

func (m *MsgRevokeOperatorResponse) Reset()         { *m = MsgRevokeOperatorResponse{} }
func (m *MsgRevokeOperatorResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeOperatorResponse) ProtoMessage()    {}
func (*MsgRevokeOperatorResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{15}
}
func (m *MsgRevokeOperatorResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokeOperatorResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokeOperatorResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokeOperatorResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokeOperatorResponse.Merge(m, src)
}
func (m *MsgRevokeOperatorResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokeOperatorResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokeOperatorResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokeOperatorResponse proto.InternalMessageInfo

// Deprecated: use MsgAuthorizeOperator
//
// MsgApprove is the Msg/Approve request type.
type MsgApprove struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the holder who allows the manipulation of its token.
	Approver string `protobuf:"bytes,2,opt,name=approver,proto3" json:"approver,omitempty"`
	// address which the manipulation is allowed to.
	Proxy string `protobuf:"bytes,3,opt,name=proxy,proto3" json:"proxy,omitempty"`
}

func (m *MsgApprove) Reset()         { *m = MsgApprove{} }
func (m *MsgApprove) String() string { return proto.CompactTextString(m) }
func (*MsgApprove) ProtoMessage()    {}
func (*MsgApprove) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{16}
}
func (m *MsgApprove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgApprove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgApprove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgApprove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgApprove.Merge(m, src)
}
func (m *MsgApprove) XXX_Size() int {
	return m.Size()
}
func (m *MsgApprove) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgApprove.DiscardUnknown(m)
}

var xxx_messageInfo_MsgApprove proto.InternalMessageInfo

func (m *MsgApprove) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgApprove) GetApprover() string {
	if m != nil {
		return m.Approver
	}
	return ""
}

func (m *MsgApprove) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

// Deprecated: do not use
//
// MsgApproveResponse is the Msg/Approve response type.
type MsgApproveResponse struct {
}

func (m *MsgApproveResponse) Reset()         { *m = MsgApproveResponse{} }
func (m *MsgApproveResponse) String() string { return proto.CompactTextString(m) }
func (*MsgApproveResponse) ProtoMessage()    {}
func (*MsgApproveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{17}
}
func (m *MsgApproveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgApproveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgApproveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgApproveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgApproveResponse.Merge(m, src)
}
func (m *MsgApproveResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgApproveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgApproveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgApproveResponse proto.InternalMessageInfo

// Deprecated: use MsgRevokeOperator
//
// MsgDisapprove is the Msg/Disapprove request type.
type MsgDisapprove struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the holder who allows the manipulation of its token.
	Approver string `protobuf:"bytes,2,opt,name=approver,proto3" json:"approver,omitempty"`
	// address which the manipulation is allowed to.
	Proxy string `protobuf:"bytes,3,opt,name=proxy,proto3" json:"proxy,omitempty"`
}

func (m *MsgDisapprove) Reset()         { *m = MsgDisapprove{} }
func (m *MsgDisapprove) String() string { return proto.CompactTextString(m) }
func (*MsgDisapprove) ProtoMessage()    {}
func (*MsgDisapprove) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{18}
}
func (m *MsgDisapprove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisapprove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisapprove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisapprove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisapprove.Merge(m, src)
}
func (m *MsgDisapprove) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisapprove) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisapprove.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisapprove proto.InternalMessageInfo

func (m *MsgDisapprove) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgDisapprove) GetApprover() string {
	if m != nil {
		return m.Approver
	}
	return ""
}

func (m *MsgDisapprove) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

// Deprecated: do not use
//
// MsgDisapproveResponse is the Msg/Disapprove response type.
type MsgDisapproveResponse struct {
}

func (m *MsgDisapproveResponse) Reset()         { *m = MsgDisapproveResponse{} }
func (m *MsgDisapproveResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDisapproveResponse) ProtoMessage()    {}
func (*MsgDisapproveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{19}
}
func (m *MsgDisapproveResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisapproveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisapproveResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisapproveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisapproveResponse.Merge(m, src)
}
func (m *MsgDisapproveResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisapproveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisapproveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisapproveResponse proto.InternalMessageInfo

// MsgCreateContract is the Msg/CreateContract request type.
//
// Throws:
// - ErrInvalidAddress
//   - `owner` is of invalid format.
// - ErrInvalidRequest
//   - `name` exceeds the app-specific limit in length.
//   - `base_img_uri` exceeds the app-specific limit in length.
//   - `meta` exceeds the app-specific limit in length.
//
// Signer: `owner`
type MsgCreateContract struct {
	// address which all the permissions on the contract will be granted to (not a permanent property).
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// name defines the human-readable name of the contract.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// base img uri is an uri for the contract image stored off chain.
	BaseImgUri string `protobuf:"bytes,3,opt,name=base_img_uri,json=baseImgUri,proto3" json:"base_img_uri,omitempty"`
	// meta is a brief description of the contract.
	Meta string `protobuf:"bytes,4,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (m *MsgCreateContract) Reset()         { *m = MsgCreateContract{} }
func (m *MsgCreateContract) String() string { return proto.CompactTextString(m) }
func (*MsgCreateContract) ProtoMessage()    {}
func (*MsgCreateContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{20}
}
func (m *MsgCreateContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateContract.Merge(m, src)
}
func (m *MsgCreateContract) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateContract) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateContract.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateContract proto.InternalMessageInfo

func (m *MsgCreateContract) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgCreateContract) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateContract) GetBaseImgUri() string {
	if m != nil {
		return m.BaseImgUri
	}
	return ""
}

func (m *MsgCreateContract) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

// MsgCreateContractResponse is the Msg/CreateContract response type.
type MsgCreateContractResponse struct {
	// id of the new contract.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgCreateContractResponse) Reset()         { *m = MsgCreateContractResponse{} }
func (m *MsgCreateContractResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateContractResponse) ProtoMessage()    {}
func (*MsgCreateContractResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{21}
}
func (m *MsgCreateContractResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateContractResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateContractResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateContractResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateContractResponse.Merge(m, src)
}
func (m *MsgCreateContractResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateContractResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateContractResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateContractResponse proto.InternalMessageInfo

func (m *MsgCreateContractResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// MsgCreateFTClass is the Msg/CreateFTClass request type.
//
// Throws:
// - ErrInvalidAddress
//   - `operator` is of invalid format.
//   - `to` is not empty and is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `name` exceeds the app-specific limit in length.
//   - `meta` exceeds the app-specific limit in length.
//   - `decimals` is lesser than 0 or greater than 18.
//   - `supply` is positive and `to` is of invalid format.
//
// Signer: `operator`
//
// Since: 0.46.0 (finschia)
type MsgCreateFTClass struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggers the create.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// name defines the human-readable name of the token class.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// meta is a brief description of the token class.
	Meta string `protobuf:"bytes,4,opt,name=meta,proto3" json:"meta,omitempty"`
	// decimals is the number of decimals which one must divide the amount by to get its user representation.
	Decimals int32 `protobuf:"varint,5,opt,name=decimals,proto3" json:"decimals,omitempty"`
	// recipient of the minted tokens.
	To string `protobuf:"bytes,6,opt,name=to,proto3" json:"to,omitempty"`
	// amount of tokens to mint on the create.
	// Note: supply may be zero.
	Supply github_com_line_lbm_sdk_types.Int `protobuf:"bytes,7,opt,name=supply,proto3,customtype=github.com/line/lbm-sdk/types.Int" json:"supply"`
}

func (m *MsgCreateFTClass) Reset()         { *m = MsgCreateFTClass{} }
func (m *MsgCreateFTClass) String() string { return proto.CompactTextString(m) }
func (*MsgCreateFTClass) ProtoMessage()    {}
func (*MsgCreateFTClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{22}
}
func (m *MsgCreateFTClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateFTClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateFTClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateFTClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateFTClass.Merge(m, src)
}
func (m *MsgCreateFTClass) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateFTClass) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateFTClass.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateFTClass proto.InternalMessageInfo

func (m *MsgCreateFTClass) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgCreateFTClass) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *MsgCreateFTClass) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateFTClass) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

func (m *MsgCreateFTClass) GetDecimals() int32 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *MsgCreateFTClass) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

// MsgCreateFTClassResponse is the Msg/CreateFTClass response type.
//
// Since: 0.46.0 (finschia)
type MsgCreateFTClassResponse struct {
	// id of the new token class.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgCreateFTClassResponse) Reset()         { *m = MsgCreateFTClassResponse{} }
func (m *MsgCreateFTClassResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateFTClassResponse) ProtoMessage()    {}
func (*MsgCreateFTClassResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{23}
}
func (m *MsgCreateFTClassResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateFTClassResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateFTClassResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateFTClassResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateFTClassResponse.Merge(m, src)
}
func (m *MsgCreateFTClassResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateFTClassResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateFTClassResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateFTClassResponse proto.InternalMessageInfo

func (m *MsgCreateFTClassResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// MsgCreateNFTClass is the Msg/CreateNFTClass request type.
//
// Throws:
// - ErrInvalidAddress
//   - `operator` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `name` exceeds the app-specific limit in length.
//   - `meta` exceeds the app-specific limit in length.
//
// Signer: `operator`
//
// Since: 0.46.0 (finschia)
type MsgCreateNFTClass struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggers the create.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// name defines the human-readable name of the token class.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// meta is a brief description of the token class.
	Meta string `protobuf:"bytes,4,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (m *MsgCreateNFTClass) Reset()         { *m = MsgCreateNFTClass{} }
func (m *MsgCreateNFTClass) String() string { return proto.CompactTextString(m) }
func (*MsgCreateNFTClass) ProtoMessage()    {}
func (*MsgCreateNFTClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{24}
}
func (m *MsgCreateNFTClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateNFTClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateNFTClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateNFTClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateNFTClass.Merge(m, src)
}
func (m *MsgCreateNFTClass) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateNFTClass) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateNFTClass.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateNFTClass proto.InternalMessageInfo

func (m *MsgCreateNFTClass) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgCreateNFTClass) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *MsgCreateNFTClass) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateNFTClass) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

// MsgCreateNFTClassResponse is the Msg/CreateNFTClass response type.
//
// Since: 0.46.0 (finschia)
type MsgCreateNFTClassResponse struct {
	// id of the new token class.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgCreateNFTClassResponse) Reset()         { *m = MsgCreateNFTClassResponse{} }
func (m *MsgCreateNFTClassResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateNFTClassResponse) ProtoMessage()    {}
func (*MsgCreateNFTClassResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{25}
}
func (m *MsgCreateNFTClassResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateNFTClassResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateNFTClassResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateNFTClassResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateNFTClassResponse.Merge(m, src)
}
func (m *MsgCreateNFTClassResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateNFTClassResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateNFTClassResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateNFTClassResponse proto.InternalMessageInfo

func (m *MsgCreateNFTClassResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Deprecated: use MsgCreateFTClass
//
// MsgIssueFT is the Msg/IssueFT request type.
//
// Throws:
// - ErrInvalidAddress
//   - `owner` is of invalid format.
//   - `to` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `name` is empty.
//   - `name` exceeds the app-specific limit in length.
//   - `meta` exceeds the app-specific limit in length.
//   - `decimals` is lesser than 0 or greater than 18.
//   - `amount` is not positive.
//   - `mintable` == false, amount == 1 and decimals == 0 (weird, but for the backward compatibility).
//
// Signer: `owner`
type MsgIssueFT struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// name defines the human-readable name of the token class.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// meta is a brief description of the token class.
	Meta string `protobuf:"bytes,3,opt,name=meta,proto3" json:"meta,omitempty"`
	// decimals is the number of decimals which one must divide the amount by to get its user representation.
	Decimals int32 `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty"`
	// mintable represents whether the token is allowed to be minted or burnt.
	Mintable bool `protobuf:"varint,5,opt,name=mintable,proto3" json:"mintable,omitempty"`
	// the address of the grantee which must have the permission to issue a token.
	Owner string `protobuf:"bytes,6,opt,name=owner,proto3" json:"owner,omitempty"`
	// the address to send the minted tokens to. mandatory.
	To string `protobuf:"bytes,7,opt,name=to,proto3" json:"to,omitempty"`
	// the amount of tokens to mint on the issuance.
	// Note: if you provide negative amount, a panic may result.
	// Note: amount may be zero.
	Amount github_com_line_lbm_sdk_types.Int `protobuf:"bytes,8,opt,name=amount,proto3,customtype=github.com/line/lbm-sdk/types.Int" json:"amount"`
}

func (m *MsgIssueFT) Reset()         { *m = MsgIssueFT{} }
func (m *MsgIssueFT) String() string { return proto.CompactTextString(m) }
func (*MsgIssueFT) ProtoMessage()    {}
func (*MsgIssueFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{26}
}
func (m *MsgIssueFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIssueFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIssueFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIssueFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIssueFT.Merge(m, src)
}
func (m *MsgIssueFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgIssueFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIssueFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIssueFT proto.InternalMessageInfo

func (m *MsgIssueFT) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgIssueFT) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgIssueFT) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

func (m *MsgIssueFT) GetDecimals() int32 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *MsgIssueFT) GetMintable() bool {
	if m != nil {
		return m.Mintable
	}
	return false
}

func (m *MsgIssueFT) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgIssueFT) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

// Deprecated: do not use
//
// MsgIssueFTResponse is the Msg/IssueFT response type.
type MsgIssueFTResponse struct {
	// id of the new token class.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgIssueFTResponse) Reset()         { *m = MsgIssueFTResponse{} }
func (m *MsgIssueFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgIssueFTResponse) ProtoMessage()    {}
func (*MsgIssueFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{27}
}
func (m *MsgIssueFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIssueFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIssueFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIssueFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIssueFTResponse.Merge(m, src)
}
func (m *MsgIssueFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgIssueFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIssueFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIssueFTResponse proto.InternalMessageInfo

func (m *MsgIssueFTResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// Deprecated: use MsgCreateNFTClass
//
// MsgIssueNFT is the Msg/IssueNFT request type.
//
// Throws:
// - ErrInvalidAddress
//   - `owner` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `name` exceeds the app-specific limit in length.
//   - `meta` exceeds the app-specific limit in length.
//
// Signer: `owner`
type MsgIssueNFT struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// name defines the human-readable name of the token class.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// meta is a brief description of the token class.
	Meta string `protobuf:"bytes,3,opt,name=meta,proto3" json:"meta,omitempty"`
	// the address of the grantee which must have the permission to issue a token.
	Owner string `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *MsgIssueNFT) Reset()         { *m = MsgIssueNFT{} }
func (m *MsgIssueNFT) String() string { return proto.CompactTextString(m) }
func (*MsgIssueNFT) ProtoMessage()    {}
func (*MsgIssueNFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{28}
}
func (m *MsgIssueNFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIssueNFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIssueNFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIssueNFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIssueNFT.Merge(m, src)
}
func (m *MsgIssueNFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgIssueNFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIssueNFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIssueNFT proto.InternalMessageInfo

func (m *MsgIssueNFT) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgIssueNFT) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgIssueNFT) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

func (m *MsgIssueNFT) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// Deprecated: do not use
//
// MsgIssueNFTResponse is the Msg/IssueNFT response type.
type MsgIssueNFTResponse struct {
	// id of the new token class.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *MsgIssueNFTResponse) Reset()         { *m = MsgIssueNFTResponse{} }
func (m *MsgIssueNFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgIssueNFTResponse) ProtoMessage()    {}
func (*MsgIssueNFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{29}
}
func (m *MsgIssueNFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgIssueNFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgIssueNFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgIssueNFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgIssueNFTResponse.Merge(m, src)
}
func (m *MsgIssueNFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgIssueNFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgIssueNFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgIssueNFTResponse proto.InternalMessageInfo

func (m *MsgIssueNFTResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// MsgMintFT is the Msg/MintFT request type.
//
// Throws:
// - ErrInvalidAddress
//   - `from` is of invalid format.
//   - `to` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `amount` is not positive.
//
// Signer: `from`
type MsgMintFT struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the grantee which has the permission for the mint.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// address which the minted tokens will be sent to.
	To string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// the amount of the mint.
	// Note: amount may be empty.
	Amount Coins `protobuf:"bytes,4,rep,name=amount,proto3,castrepeated=Coins" json:"amount"`
}

func (m *MsgMintFT) Reset()         { *m = MsgMintFT{} }
func (m *MsgMintFT) String() string { return proto.CompactTextString(m) }
func (*MsgMintFT) ProtoMessage()    {}
func (*MsgMintFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{30}
}
func (m *MsgMintFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintFT.Merge(m, src)
}
func (m *MsgMintFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintFT proto.InternalMessageInfo

func (m *MsgMintFT) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgMintFT) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgMintFT) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *MsgMintFT) GetAmount() Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

// MsgMintFTResponse is the Msg/MintFT response type.
type MsgMintFTResponse struct {
}

func (m *MsgMintFTResponse) Reset()         { *m = MsgMintFTResponse{} }
func (m *MsgMintFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintFTResponse) ProtoMessage()    {}
func (*MsgMintFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{31}
}
func (m *MsgMintFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintFTResponse.Merge(m, src)
}
func (m *MsgMintFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintFTResponse proto.InternalMessageInfo

// MsgMintNFT is the Msg/MintNFT request type.
//
// Throws:
// - ErrInvalidAddress
//   - `from` is of invalid format.
//   - `to` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `params` is empty.
//   - `params` has an invalid element.
//
// Signer: `from`
type MsgMintNFT struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the grantee which has the permission for the mint.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// address which the minted token will be sent to.
	To string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// parameters for the minted tokens.
	Params []MintNFTParam `protobuf:"bytes,4,rep,name=params,proto3" json:"params"`
}

func (m *MsgMintNFT) Reset()         { *m = MsgMintNFT{} }
func (m *MsgMintNFT) String() string { return proto.CompactTextString(m) }
func (*MsgMintNFT) ProtoMessage()    {}
func (*MsgMintNFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{32}
}
func (m *MsgMintNFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintNFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintNFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintNFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintNFT.Merge(m, src)
}
func (m *MsgMintNFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintNFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintNFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintNFT proto.InternalMessageInfo

func (m *MsgMintNFT) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgMintNFT) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgMintNFT) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *MsgMintNFT) GetParams() []MintNFTParam {
	if m != nil {
		return m.Params
	}
	return nil
}

// MsgMintNFTResponse is the Msg/MintNFT response type.
type MsgMintNFTResponse struct {
	// ids of the new non-fungible tokens.
	Ids []string `protobuf:"bytes,1,rep,name=ids,proto3" json:"ids,omitempty"`
}

func (m *MsgMintNFTResponse) Reset()         { *m = MsgMintNFTResponse{} }
func (m *MsgMintNFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgMintNFTResponse) ProtoMessage()    {}
func (*MsgMintNFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{33}
}
func (m *MsgMintNFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgMintNFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgMintNFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgMintNFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgMintNFTResponse.Merge(m, src)
}
func (m *MsgMintNFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgMintNFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgMintNFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgMintNFTResponse proto.InternalMessageInfo

func (m *MsgMintNFTResponse) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

// MintNFTParam defines a parameter for minting nft.
type MintNFTParam struct {
	// token type or class id of the nft.
	// Note: it cannot start with zero.
	TokenType string `protobuf:"bytes,1,opt,name=token_type,json=tokenType,proto3" json:"token_type,omitempty"`
	// name defines the human-readable name of the nft (mandatory).
	// Note: it has an app-specific limit in length.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// meta is a brief description of the nft.
	// Note: it has an app-specific limit in length.
	Meta string `protobuf:"bytes,3,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (m *MintNFTParam) Reset()         { *m = MintNFTParam{} }
func (m *MintNFTParam) String() string { return proto.CompactTextString(m) }
func (*MintNFTParam) ProtoMessage()    {}
func (*MintNFTParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{34}
}
func (m *MintNFTParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MintNFTParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MintNFTParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MintNFTParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MintNFTParam.Merge(m, src)
}
func (m *MintNFTParam) XXX_Size() int {
	return m.Size()
}
func (m *MintNFTParam) XXX_DiscardUnknown() {
	xxx_messageInfo_MintNFTParam.DiscardUnknown(m)
}

var xxx_messageInfo_MintNFTParam proto.InternalMessageInfo

func (m *MintNFTParam) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

func (m *MintNFTParam) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MintNFTParam) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

// MsgBurn is the Msg/Burn request type.
//
// Throws:
// - ErrInvalidAddress
//   - `from` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `amount` is not positive.
//
// Signer: `from`
//
// Since: 0.46.0 (finschia)
type MsgBurn struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// holder whose tokens are being burned.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// amount of tokens to burn.
	Amount Coins `protobuf:"bytes,3,rep,name=amount,proto3,castrepeated=Coins" json:"amount"`
}

func (m *MsgBurn) Reset()         { *m = MsgBurn{} }
func (m *MsgBurn) String() string { return proto.CompactTextString(m) }
func (*MsgBurn) ProtoMessage()    {}
func (*MsgBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{35}
}
func (m *MsgBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurn.Merge(m, src)
}
func (m *MsgBurn) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurn.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurn proto.InternalMessageInfo

func (m *MsgBurn) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgBurn) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgBurn) GetAmount() Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

// MsgBurnResponse is the Msg/Burn response type.
//
// Since: 0.46.0 (finschia)
type MsgBurnResponse struct {
}

func (m *MsgBurnResponse) Reset()         { *m = MsgBurnResponse{} }
func (m *MsgBurnResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnResponse) ProtoMessage()    {}
func (*MsgBurnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{36}
}
func (m *MsgBurnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnResponse.Merge(m, src)
}
func (m *MsgBurnResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnResponse proto.InternalMessageInfo

// MsgOperatorBurn is the Msg/OperatorBurn request type.
//
// Throws:
// - ErrInvalidAddress
//   - `operator` is of invalid format.
//   - `from` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `amount` is not positive.
//
// Signer: `from`
//
// Since: 0.46.0 (finschia)
type MsgOperatorBurn struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggers the burn.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// holder whose tokens are being burned.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// amount of tokens to burn.
	Amount Coins `protobuf:"bytes,4,rep,name=amount,proto3,castrepeated=Coins" json:"amount"`
}

func (m *MsgOperatorBurn) Reset()         { *m = MsgOperatorBurn{} }
func (m *MsgOperatorBurn) String() string { return proto.CompactTextString(m) }
func (*MsgOperatorBurn) ProtoMessage()    {}
func (*MsgOperatorBurn) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{37}
}
func (m *MsgOperatorBurn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOperatorBurn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOperatorBurn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOperatorBurn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOperatorBurn.Merge(m, src)
}
func (m *MsgOperatorBurn) XXX_Size() int {
	return m.Size()
}
func (m *MsgOperatorBurn) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOperatorBurn.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOperatorBurn proto.InternalMessageInfo

func (m *MsgOperatorBurn) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgOperatorBurn) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *MsgOperatorBurn) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgOperatorBurn) GetAmount() Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

// MsgOperatorBurnResponse is the Msg/OperatorBurn response type.
//
// Since: 0.46.0 (finschia)
type MsgOperatorBurnResponse struct {
}

func (m *MsgOperatorBurnResponse) Reset()         { *m = MsgOperatorBurnResponse{} }
func (m *MsgOperatorBurnResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOperatorBurnResponse) ProtoMessage()    {}
func (*MsgOperatorBurnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{38}
}
func (m *MsgOperatorBurnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOperatorBurnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOperatorBurnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOperatorBurnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOperatorBurnResponse.Merge(m, src)
}
func (m *MsgOperatorBurnResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOperatorBurnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOperatorBurnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOperatorBurnResponse proto.InternalMessageInfo

// Deprecated: use MsgBurn
//
// MsgBurnFT is the Msg/BurnFT request type.
type MsgBurnFT struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which the tokens will be burnt from.
	// Note: it must have the permission for the burn.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// the amount of the burn.
	// Note: amount may be empty.
	Amount []Coin `protobuf:"bytes,3,rep,name=amount,proto3" json:"amount"`
}

func (m *MsgBurnFT) Reset()         { *m = MsgBurnFT{} }
func (m *MsgBurnFT) String() string { return proto.CompactTextString(m) }
func (*MsgBurnFT) ProtoMessage()    {}
func (*MsgBurnFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{39}
}
func (m *MsgBurnFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnFT.Merge(m, src)
}
func (m *MsgBurnFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnFT proto.InternalMessageInfo

func (m *MsgBurnFT) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgBurnFT) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgBurnFT) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// Deprecated: do not use
//
// MsgBurnFTResponse is the Msg/BurnFT response type.
type MsgBurnFTResponse struct {
}

func (m *MsgBurnFTResponse) Reset()         { *m = MsgBurnFTResponse{} }
func (m *MsgBurnFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnFTResponse) ProtoMessage()    {}
func (*MsgBurnFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{40}
}
func (m *MsgBurnFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnFTResponse.Merge(m, src)
}
func (m *MsgBurnFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnFTResponse proto.InternalMessageInfo

// Deprecated: use MsgOperatorBurn
//
// MsgBurnFTFrom is the Msg/BurnFTFrom request type.
type MsgBurnFTFrom struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggers the burn.
	// Note: it must have the permission for the burn.
	// Note: it must have been authorized by from.
	Proxy string `protobuf:"bytes,2,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// address which the tokens will be burnt from.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// the amount of the burn.
	// Note: amount may be empty.
	Amount []Coin `protobuf:"bytes,4,rep,name=amount,proto3" json:"amount"`
}

func (m *MsgBurnFTFrom) Reset()         { *m = MsgBurnFTFrom{} }
func (m *MsgBurnFTFrom) String() string { return proto.CompactTextString(m) }
func (*MsgBurnFTFrom) ProtoMessage()    {}
func (*MsgBurnFTFrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{41}
}
func (m *MsgBurnFTFrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnFTFrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnFTFrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnFTFrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnFTFrom.Merge(m, src)
}
func (m *MsgBurnFTFrom) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnFTFrom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnFTFrom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnFTFrom proto.InternalMessageInfo

func (m *MsgBurnFTFrom) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgBurnFTFrom) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *MsgBurnFTFrom) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgBurnFTFrom) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// Deprecated: do not use
//
// MsgBurnFTFromResponse is the Msg/BurnFTFrom response type.
type MsgBurnFTFromResponse struct {
}

func (m *MsgBurnFTFromResponse) Reset()         { *m = MsgBurnFTFromResponse{} }
func (m *MsgBurnFTFromResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnFTFromResponse) ProtoMessage()    {}
func (*MsgBurnFTFromResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{42}
}
func (m *MsgBurnFTFromResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnFTFromResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnFTFromResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnFTFromResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnFTFromResponse.Merge(m, src)
}
func (m *MsgBurnFTFromResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnFTFromResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnFTFromResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnFTFromResponse proto.InternalMessageInfo

// Deprecated: use MsgBurn
//
// MsgBurnNFT is the Msg/BurnNFT request type.
type MsgBurnNFT struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which the tokens will be burnt from.
	// Note: it must have the permission for the burn.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// the token ids to burn.
	// Note: id cannot start with zero.
	TokenIds []string `protobuf:"bytes,3,rep,name=token_ids,json=tokenIds,proto3" json:"token_ids,omitempty"`
}

func (m *MsgBurnNFT) Reset()         { *m = MsgBurnNFT{} }
func (m *MsgBurnNFT) String() string { return proto.CompactTextString(m) }
func (*MsgBurnNFT) ProtoMessage()    {}
func (*MsgBurnNFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{43}
}
func (m *MsgBurnNFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnNFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnNFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnNFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnNFT.Merge(m, src)
}
func (m *MsgBurnNFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnNFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnNFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnNFT proto.InternalMessageInfo

func (m *MsgBurnNFT) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgBurnNFT) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgBurnNFT) GetTokenIds() []string {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

// Deprecated: do not use
//
// MsgBurnNFTResponse is the Msg/BurnNFT response type.
type MsgBurnNFTResponse struct {
}

func (m *MsgBurnNFTResponse) Reset()         { *m = MsgBurnNFTResponse{} }
func (m *MsgBurnNFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnNFTResponse) ProtoMessage()    {}
func (*MsgBurnNFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{44}
}
func (m *MsgBurnNFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnNFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnNFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnNFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnNFTResponse.Merge(m, src)
}
func (m *MsgBurnNFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnNFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnNFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnNFTResponse proto.InternalMessageInfo

// Deprecated: use MsgOperatorBurn
//
// MsgBurnNFTFrom is the Msg/BurnNFTFrom request type.
type MsgBurnNFTFrom struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggers the burn.
	// Note: it must have the permission for the burn.
	// Note: it must have been authorized by from.
	Proxy string `protobuf:"bytes,2,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// address which the tokens will be burnt from.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// the token ids to burn.
	// Note: id cannot start with zero.
	TokenIds []string `protobuf:"bytes,4,rep,name=token_ids,json=tokenIds,proto3" json:"token_ids,omitempty"`
}

func (m *MsgBurnNFTFrom) Reset()         { *m = MsgBurnNFTFrom{} }
func (m *MsgBurnNFTFrom) String() string { return proto.CompactTextString(m) }
func (*MsgBurnNFTFrom) ProtoMessage()    {}
func (*MsgBurnNFTFrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{45}
}
func (m *MsgBurnNFTFrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnNFTFrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnNFTFrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnNFTFrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnNFTFrom.Merge(m, src)
}
func (m *MsgBurnNFTFrom) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnNFTFrom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnNFTFrom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnNFTFrom proto.InternalMessageInfo

func (m *MsgBurnNFTFrom) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgBurnNFTFrom) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *MsgBurnNFTFrom) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgBurnNFTFrom) GetTokenIds() []string {
	if m != nil {
		return m.TokenIds
	}
	return nil
}

// Deprecated: do not use
//
// MsgBurnNFTFromResponse is the Msg/BurnNFTFrom response type.
type MsgBurnNFTFromResponse struct {
}

func (m *MsgBurnNFTFromResponse) Reset()         { *m = MsgBurnNFTFromResponse{} }
func (m *MsgBurnNFTFromResponse) String() string { return proto.CompactTextString(m) }
func (*MsgBurnNFTFromResponse) ProtoMessage()    {}
func (*MsgBurnNFTFromResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{46}
}
func (m *MsgBurnNFTFromResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBurnNFTFromResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBurnNFTFromResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBurnNFTFromResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBurnNFTFromResponse.Merge(m, src)
}
func (m *MsgBurnNFTFromResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgBurnNFTFromResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBurnNFTFromResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBurnNFTFromResponse proto.InternalMessageInfo

// MsgModifyContract is the Msg/ModifyContract request type.
//
// Throws:
// - ErrInvalidAddress
//   - `operator` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `changes` has duplicate keys.
//   - `changes` has a key which is not allowed to modify.
//   - `changes` is empty.
//
// Signer: `operator`
//
// Since: 0.46.0 (finschia)
type MsgModifyContract struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggers the modify.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// attributes to apply.
	Changes []Attribute `protobuf:"bytes,3,rep,name=changes,proto3" json:"changes"`
}

func (m *MsgModifyContract) Reset()         { *m = MsgModifyContract{} }
func (m *MsgModifyContract) String() string { return proto.CompactTextString(m) }
func (*MsgModifyContract) ProtoMessage()    {}
func (*MsgModifyContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{47}
}
func (m *MsgModifyContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgModifyContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgModifyContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgModifyContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgModifyContract.Merge(m, src)
}
func (m *MsgModifyContract) XXX_Size() int {
	return m.Size()
}
func (m *MsgModifyContract) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgModifyContract.DiscardUnknown(m)
}

var xxx_messageInfo_MsgModifyContract proto.InternalMessageInfo

func (m *MsgModifyContract) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgModifyContract) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *MsgModifyContract) GetChanges() []Attribute {
	if m != nil {
		return m.Changes
	}
	return nil
}

// MsgModifyContractResponse is the Msg/ModifyContract response type.
//
// Since: 0.46.0 (finschia)
type MsgModifyContractResponse struct {
}

func (m *MsgModifyContractResponse) Reset()         { *m = MsgModifyContractResponse{} }
func (m *MsgModifyContractResponse) String() string { return proto.CompactTextString(m) }
func (*MsgModifyContractResponse) ProtoMessage()    {}
func (*MsgModifyContractResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{48}
}
func (m *MsgModifyContractResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgModifyContractResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgModifyContractResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgModifyContractResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgModifyContractResponse.Merge(m, src)
}
func (m *MsgModifyContractResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgModifyContractResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgModifyContractResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgModifyContractResponse proto.InternalMessageInfo

// MsgModifyTokenClass is the Msg/ModifyTokenClass request type.
//
// Throws:
// - ErrInvalidAddress
//   - `operator` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `class_id` is of invalid format.
//   - `changes` has duplicate keys.
//   - `changes` has a key which is not allowed to modify.
//   - `changes` is empty.
//
// Signer: `operator`
//
// Since: 0.46.0 (finschia)
type MsgModifyTokenClass struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggers the modify.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// class id associated with the token class.
	ClassId string `protobuf:"bytes,3,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// attributes to apply.
	Changes []Attribute `protobuf:"bytes,4,rep,name=changes,proto3" json:"changes"`
}

func (m *MsgModifyTokenClass) Reset()         { *m = MsgModifyTokenClass{} }
func (m *MsgModifyTokenClass) String() string { return proto.CompactTextString(m) }
func (*MsgModifyTokenClass) ProtoMessage()    {}
func (*MsgModifyTokenClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{49}
}
func (m *MsgModifyTokenClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgModifyTokenClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgModifyTokenClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgModifyTokenClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgModifyTokenClass.Merge(m, src)
}
func (m *MsgModifyTokenClass) XXX_Size() int {
	return m.Size()
}
func (m *MsgModifyTokenClass) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgModifyTokenClass.DiscardUnknown(m)
}

var xxx_messageInfo_MsgModifyTokenClass proto.InternalMessageInfo

func (m *MsgModifyTokenClass) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgModifyTokenClass) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *MsgModifyTokenClass) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *MsgModifyTokenClass) GetChanges() []Attribute {
	if m != nil {
		return m.Changes
	}
	return nil
}

// MsgModifyTokenClassResponse is the Msg/ModifyTokenClass response type.
//
// Since: 0.46.0 (finschia)
type MsgModifyTokenClassResponse struct {
}

func (m *MsgModifyTokenClassResponse) Reset()         { *m = MsgModifyTokenClassResponse{} }
func (m *MsgModifyTokenClassResponse) String() string { return proto.CompactTextString(m) }
func (*MsgModifyTokenClassResponse) ProtoMessage()    {}
func (*MsgModifyTokenClassResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{50}
}
func (m *MsgModifyTokenClassResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgModifyTokenClassResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgModifyTokenClassResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgModifyTokenClassResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgModifyTokenClassResponse.Merge(m, src)
}
func (m *MsgModifyTokenClassResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgModifyTokenClassResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgModifyTokenClassResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgModifyTokenClassResponse proto.InternalMessageInfo

// MsgModifyNFT is the Msg/ModifyNFT request type.
//
// Throws:
// - ErrInvalidAddress
//   - `operator` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `token_id` is of invalid format.
//   - `changes` has duplicate keys.
//   - `changes` has a key which is not allowed to modify.
//   - `changes` is empty.
//
// Signer: `operator`
//
// Since: 0.46.0 (finschia)
type MsgModifyNFT struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggers the modify.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// token id associated with the non-fungible token.
	TokenId string `protobuf:"bytes,3,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	// attributes to apply.
	Changes []Attribute `protobuf:"bytes,4,rep,name=changes,proto3" json:"changes"`
}

func (m *MsgModifyNFT) Reset()         { *m = MsgModifyNFT{} }
func (m *MsgModifyNFT) String() string { return proto.CompactTextString(m) }
func (*MsgModifyNFT) ProtoMessage()    {}
func (*MsgModifyNFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{51}
}
func (m *MsgModifyNFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgModifyNFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgModifyNFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgModifyNFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgModifyNFT.Merge(m, src)
}
func (m *MsgModifyNFT) XXX_Size() int {
	return m.Size()
}
func (m *MsgModifyNFT) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgModifyNFT.DiscardUnknown(m)
}

var xxx_messageInfo_MsgModifyNFT proto.InternalMessageInfo

func (m *MsgModifyNFT) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgModifyNFT) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *MsgModifyNFT) GetTokenId() string {
	if m != nil {
		return m.TokenId
	}
	return ""
}

func (m *MsgModifyNFT) GetChanges() []Attribute {
	if m != nil {
		return m.Changes
	}
	return nil
}

// MsgModifyNFTResponse is the Msg/ModifyNFT response type.
//
// Since: 0.46.0 (finschia)
type MsgModifyNFTResponse struct {
}

func (m *MsgModifyNFTResponse) Reset()         { *m = MsgModifyNFTResponse{} }
func (m *MsgModifyNFTResponse) String() string { return proto.CompactTextString(m) }
func (*MsgModifyNFTResponse) ProtoMessage()    {}
func (*MsgModifyNFTResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{52}
}
func (m *MsgModifyNFTResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgModifyNFTResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgModifyNFTResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgModifyNFTResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgModifyNFTResponse.Merge(m, src)
}
func (m *MsgModifyNFTResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgModifyNFTResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgModifyNFTResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgModifyNFTResponse proto.InternalMessageInfo

// Deprecated: use MsgModifyContract, MsgModifyTokenClass or MsgModifyNFT
//
// MsgModify is the Msg/Modify request type.
type MsgModify struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// the address of the grantee which must have modify permission.
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	// token type of the token.
	TokenType string `protobuf:"bytes,3,opt,name=token_type,json=tokenType,proto3" json:"token_type,omitempty"`
	// token index of the token.
	// if index is empty, it would modify the corresponding token type.
	// if index is not empty, it would modify the corresponding nft.
	// Note: if token type is of FTs, the index cannot be empty.
	TokenIndex string `protobuf:"bytes,4,opt,name=token_index,json=tokenIndex,proto3" json:"token_index,omitempty"`
	// changes to apply.
	// on modifying collection: name, base_img_uri, meta.
	// on modifying token type and token: name, meta.
	Changes []Change `protobuf:"bytes,5,rep,name=changes,proto3" json:"changes"`
}

func (m *MsgModify) Reset()         { *m = MsgModify{} }
func (m *MsgModify) String() string { return proto.CompactTextString(m) }
func (*MsgModify) ProtoMessage()    {}
func (*MsgModify) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{53}
}
func (m *MsgModify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgModify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgModify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgModify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgModify.Merge(m, src)
}
func (m *MsgModify) XXX_Size() int {
	return m.Size()
}
func (m *MsgModify) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgModify.DiscardUnknown(m)
}

var xxx_messageInfo_MsgModify proto.InternalMessageInfo

func (m *MsgModify) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgModify) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgModify) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

func (m *MsgModify) GetTokenIndex() string {
	if m != nil {
		return m.TokenIndex
	}
	return ""
}

func (m *MsgModify) GetChanges() []Change {
	if m != nil {
		return m.Changes
	}
	return nil
}

// Deprecated: do not use
//
// MsgModifyResponse is the Msg/Modify response type.
type MsgModifyResponse struct {
}

func (m *MsgModifyResponse) Reset()         { *m = MsgModifyResponse{} }
func (m *MsgModifyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgModifyResponse) ProtoMessage()    {}
func (*MsgModifyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{54}
}
func (m *MsgModifyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgModifyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgModifyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgModifyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgModifyResponse.Merge(m, src)
}
func (m *MsgModifyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgModifyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgModifyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgModifyResponse proto.InternalMessageInfo

// MsgGrant is the Msg/Grant request type.
//
// Throws:
// - ErrInvalidAddress
//   - `granter` is of invalid format.
//   - `grantee` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `permission` is not a valid permission.
//
// Signer: `granter`
//
// Since: 0.46.0 (finschia)
type MsgGrant struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the granter which must have the permission to give.
	Granter string `protobuf:"bytes,2,opt,name=granter,proto3" json:"granter,omitempty"`
	// address of the grantee.
	Grantee string `protobuf:"bytes,3,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// permission on the contract.
	Permission Permission `protobuf:"varint,4,opt,name=permission,proto3,enum=lbm.collection.v1.Permission" json:"permission,omitempty"`
}

func (m *MsgGrant) Reset()         { *m = MsgGrant{} }
func (m *MsgGrant) String() string { return proto.CompactTextString(m) }
func (*MsgGrant) ProtoMessage()    {}
func (*MsgGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{55}
}
func (m *MsgGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGrant.Merge(m, src)
}
func (m *MsgGrant) XXX_Size() int {
	return m.Size()
}
func (m *MsgGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGrant.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGrant proto.InternalMessageInfo

func (m *MsgGrant) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgGrant) GetGranter() string {
	if m != nil {
		return m.Granter
	}
	return ""
}

func (m *MsgGrant) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *MsgGrant) GetPermission() Permission {
	if m != nil {
		return m.Permission
	}
	return PermissionUnspecified
}

// MsgGrantResponse is the Msg/Grant response type.
//
// Since: 0.46.0 (finschia)
type MsgGrantResponse struct {
}

func (m *MsgGrantResponse) Reset()         { *m = MsgGrantResponse{} }
func (m *MsgGrantResponse) String() string { return proto.CompactTextString(m) }
func (*MsgGrantResponse) ProtoMessage()    {}
func (*MsgGrantResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{56}
}
func (m *MsgGrantResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGrantResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGrantResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGrantResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGrantResponse.Merge(m, src)
}
func (m *MsgGrantResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgGrantResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGrantResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGrantResponse proto.InternalMessageInfo

// MsgAbandon is the Msg/Abandon request type.
//
// Throws:
// - ErrInvalidAddress
//   - `grantee` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `permission` is not a valid permission.
//
// Signer: `grantee`
//
// Since: 0.46.0 (finschia)
type MsgAbandon struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the grantee which abandons the permission.
	Grantee string `protobuf:"bytes,2,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// permission on the contract.
	Permission Permission `protobuf:"varint,3,opt,name=permission,proto3,enum=lbm.collection.v1.Permission" json:"permission,omitempty"`
}

func (m *MsgAbandon) Reset()         { *m = MsgAbandon{} }
func (m *MsgAbandon) String() string { return proto.CompactTextString(m) }
func (*MsgAbandon) ProtoMessage()    {}
func (*MsgAbandon) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{57}
}
func (m *MsgAbandon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAbandon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAbandon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAbandon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAbandon.Merge(m, src)
}
func (m *MsgAbandon) XXX_Size() int {
	return m.Size()
}
func (m *MsgAbandon) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAbandon.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAbandon proto.InternalMessageInfo

func (m *MsgAbandon) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgAbandon) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *MsgAbandon) GetPermission() Permission {
	if m != nil {
		return m.Permission
	}
	return PermissionUnspecified
}

// MsgAbandonResponse is the Msg/Abandon response type.
//
// Since: 0.46.0 (finschia)
type MsgAbandonResponse struct {
}

func (m *MsgAbandonResponse) Reset()         { *m = MsgAbandonResponse{} }
func (m *MsgAbandonResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAbandonResponse) ProtoMessage()    {}
func (*MsgAbandonResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{58}
}
func (m *MsgAbandonResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAbandonResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAbandonResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAbandonResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAbandonResponse.Merge(m, src)
}
func (m *MsgAbandonResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAbandonResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAbandonResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAbandonResponse proto.InternalMessageInfo

// Deprecated: use MsgGrant
//
// MsgGrantPermission is the Msg/GrantPermission request type.
type MsgGrantPermission struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the granter which must have the permission to give.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// address of the grantee.
	To string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// permission on the contract.
	Permission string `protobuf:"bytes,4,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (m *MsgGrantPermission) Reset()         { *m = MsgGrantPermission{} }
func (m *MsgGrantPermission) String() string { return proto.CompactTextString(m) }
func (*MsgGrantPermission) ProtoMessage()    {}
func (*MsgGrantPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{59}
}
func (m *MsgGrantPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGrantPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGrantPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGrantPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGrantPermission.Merge(m, src)
}
func (m *MsgGrantPermission) XXX_Size() int {
	return m.Size()
}
func (m *MsgGrantPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGrantPermission.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGrantPermission proto.InternalMessageInfo

func (m *MsgGrantPermission) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgGrantPermission) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgGrantPermission) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *MsgGrantPermission) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

// Deprecated: do not use
//
// MsgGrantPermissionResponse is the Msg/GrantPermission response type.
type MsgGrantPermissionResponse struct {
}

func (m *MsgGrantPermissionResponse) Reset()         { *m = MsgGrantPermissionResponse{} }
func (m *MsgGrantPermissionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgGrantPermissionResponse) ProtoMessage()    {}
func (*MsgGrantPermissionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{60}
}
func (m *MsgGrantPermissionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgGrantPermissionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgGrantPermissionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgGrantPermissionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgGrantPermissionResponse.Merge(m, src)
}
func (m *MsgGrantPermissionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgGrantPermissionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgGrantPermissionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgGrantPermissionResponse proto.InternalMessageInfo

// Deprecated: use MsgAbandon
//
// MsgRevokePermission is the Msg/RevokePermission request type.
type MsgRevokePermission struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the grantee which abandons the permission.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// permission on the contract.
	Permission string `protobuf:"bytes,3,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (m *MsgRevokePermission) Reset()         { *m = MsgRevokePermission{} }
func (m *MsgRevokePermission) String() string { return proto.CompactTextString(m) }
func (*MsgRevokePermission) ProtoMessage()    {}
func (*MsgRevokePermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{61}
}
func (m *MsgRevokePermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokePermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokePermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokePermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokePermission.Merge(m, src)
}
func (m *MsgRevokePermission) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokePermission) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokePermission.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokePermission proto.InternalMessageInfo

func (m *MsgRevokePermission) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgRevokePermission) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgRevokePermission) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

// Deprecated: do not use
//
// MsgRevokePermissionResponse is the Msg/RevokePermission response type.
type MsgRevokePermissionResponse struct {
}

func (m *MsgRevokePermissionResponse) Reset()         { *m = MsgRevokePermissionResponse{} }
func (m *MsgRevokePermissionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevokePermissionResponse) ProtoMessage()    {}
func (*MsgRevokePermissionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{62}
}
func (m *MsgRevokePermissionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokePermissionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokePermissionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokePermissionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokePermissionResponse.Merge(m, src)
}
func (m *MsgRevokePermissionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokePermissionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokePermissionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokePermissionResponse proto.InternalMessageInfo

// MsgAttach is the Msg/Attach request type.
//
// Throws:
// - ErrInvalidAddress
//   - `from` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `token_id` is of invalid format.
//   - `to_token_id` is of invalid format.
//   - `token_id` is equal to `to_token_id`.
//
// Signer: `from`
//
// TODO: revisit the field names
type MsgAttach struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the owner of the token.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// token id of the token to attach.
	TokenId string `protobuf:"bytes,3,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	// to token id which one attachs the token to.
	ToTokenId string `protobuf:"bytes,4,opt,name=to_token_id,json=toTokenId,proto3" json:"to_token_id,omitempty"`
}

func (m *MsgAttach) Reset()         { *m = MsgAttach{} }
func (m *MsgAttach) String() string { return proto.CompactTextString(m) }
func (*MsgAttach) ProtoMessage()    {}
func (*MsgAttach) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{63}
}
func (m *MsgAttach) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAttach) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAttach.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAttach) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAttach.Merge(m, src)
}
func (m *MsgAttach) XXX_Size() int {
	return m.Size()
}
func (m *MsgAttach) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAttach.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAttach proto.InternalMessageInfo

func (m *MsgAttach) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgAttach) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgAttach) GetTokenId() string {
	if m != nil {
		return m.TokenId
	}
	return ""
}

func (m *MsgAttach) GetToTokenId() string {
	if m != nil {
		return m.ToTokenId
	}
	return ""
}

// MsgAttachResponse is the Msg/Attach response type.
type MsgAttachResponse struct {
}

func (m *MsgAttachResponse) Reset()         { *m = MsgAttachResponse{} }
func (m *MsgAttachResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAttachResponse) ProtoMessage()    {}
func (*MsgAttachResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{64}
}
func (m *MsgAttachResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAttachResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAttachResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAttachResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAttachResponse.Merge(m, src)
}
func (m *MsgAttachResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAttachResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAttachResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAttachResponse proto.InternalMessageInfo

// MsgDetach is the Msg/Detach request type.
//
// Throws:
// - ErrInvalidAddress
//   - `from` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `token_id` is of invalid format.
//
// Signer: `from`
//
// TODO: revisit the field names
type MsgDetach struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the owner of the token.
	From string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// token id of the token to detach.
	TokenId string `protobuf:"bytes,3,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
}

func (m *MsgDetach) Reset()         { *m = MsgDetach{} }
func (m *MsgDetach) String() string { return proto.CompactTextString(m) }
func (*MsgDetach) ProtoMessage()    {}
func (*MsgDetach) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{65}
}
func (m *MsgDetach) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDetach) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDetach.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDetach) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDetach.Merge(m, src)
}
func (m *MsgDetach) XXX_Size() int {
	return m.Size()
}
func (m *MsgDetach) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDetach.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDetach proto.InternalMessageInfo

func (m *MsgDetach) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgDetach) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgDetach) GetTokenId() string {
	if m != nil {
		return m.TokenId
	}
	return ""
}

// MsgDetachResponse is the Msg/Detach response type.
type MsgDetachResponse struct {
}

func (m *MsgDetachResponse) Reset()         { *m = MsgDetachResponse{} }
func (m *MsgDetachResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDetachResponse) ProtoMessage()    {}
func (*MsgDetachResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{66}
}
func (m *MsgDetachResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDetachResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDetachResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDetachResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDetachResponse.Merge(m, src)
}
func (m *MsgDetachResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDetachResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDetachResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDetachResponse proto.InternalMessageInfo

// MsgOperatorAttach is the Msg/OperatorAttach request type.
//
// Throws:
// - ErrInvalidAddress
//   - `operator` is of invalid format.
//   - `owner` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `subject` is of invalid format.
//   - `target` is of invalid format.
//   - `subject` is equal to `target`.
//
// Signer: `operator`
//
// Since: 0.46.0 (finschia)
type MsgOperatorAttach struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// address of the owner of the token.
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// token id of the token to attach.
	Subject string `protobuf:"bytes,4,opt,name=subject,proto3" json:"subject,omitempty"`
	// token id which one attachs the token to.
	Target string `protobuf:"bytes,5,opt,name=target,proto3" json:"target,omitempty"`
}

func (m *MsgOperatorAttach) Reset()         { *m = MsgOperatorAttach{} }
func (m *MsgOperatorAttach) String() string { return proto.CompactTextString(m) }
func (*MsgOperatorAttach) ProtoMessage()    {}
func (*MsgOperatorAttach) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{67}
}
func (m *MsgOperatorAttach) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOperatorAttach) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOperatorAttach.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOperatorAttach) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOperatorAttach.Merge(m, src)
}
func (m *MsgOperatorAttach) XXX_Size() int {
	return m.Size()
}
func (m *MsgOperatorAttach) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOperatorAttach.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOperatorAttach proto.InternalMessageInfo

func (m *MsgOperatorAttach) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgOperatorAttach) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *MsgOperatorAttach) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgOperatorAttach) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

func (m *MsgOperatorAttach) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

// MsgOperatorAttachResponse is the Msg/OperatorAttach response type.
//
// Since: 0.46.0 (finschia)
type MsgOperatorAttachResponse struct {
}

func (m *MsgOperatorAttachResponse) Reset()         { *m = MsgOperatorAttachResponse{} }
func (m *MsgOperatorAttachResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOperatorAttachResponse) ProtoMessage()    {}
func (*MsgOperatorAttachResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{68}
}
func (m *MsgOperatorAttachResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOperatorAttachResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOperatorAttachResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOperatorAttachResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOperatorAttachResponse.Merge(m, src)
}
func (m *MsgOperatorAttachResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOperatorAttachResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOperatorAttachResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOperatorAttachResponse proto.InternalMessageInfo

// MsgOperatorDetach is the Msg/OperatorDetach request type.
//
// Throws:
// - ErrInvalidAddress
//   - `operator` is of invalid format.
//   - `owner` is of invalid format.
// - ErrInvalidRequest
//   - `contract_id` is of invalid format.
//   - `subject` is of invalid format.
//
// Signer: `operator`
//
// Since: 0.46.0 (finschia)
type MsgOperatorDetach struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// address of the holder of the token.
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// token id of the token to detach.
	Subject string `protobuf:"bytes,4,opt,name=subject,proto3" json:"subject,omitempty"`
}

func (m *MsgOperatorDetach) Reset()         { *m = MsgOperatorDetach{} }
func (m *MsgOperatorDetach) String() string { return proto.CompactTextString(m) }
func (*MsgOperatorDetach) ProtoMessage()    {}
func (*MsgOperatorDetach) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{69}
}
func (m *MsgOperatorDetach) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOperatorDetach) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOperatorDetach.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOperatorDetach) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOperatorDetach.Merge(m, src)
}
func (m *MsgOperatorDetach) XXX_Size() int {
	return m.Size()
}
func (m *MsgOperatorDetach) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOperatorDetach.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOperatorDetach proto.InternalMessageInfo

func (m *MsgOperatorDetach) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgOperatorDetach) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *MsgOperatorDetach) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgOperatorDetach) GetSubject() string {
	if m != nil {
		return m.Subject
	}
	return ""
}

// MsgOperatorDetachResponse is the Msg/OperatorDetach response type.
//
// Since: 0.46.0 (finschia)
type MsgOperatorDetachResponse struct {
}

func (m *MsgOperatorDetachResponse) Reset()         { *m = MsgOperatorDetachResponse{} }
func (m *MsgOperatorDetachResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOperatorDetachResponse) ProtoMessage()    {}
func (*MsgOperatorDetachResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{70}
}
func (m *MsgOperatorDetachResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOperatorDetachResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOperatorDetachResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOperatorDetachResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOperatorDetachResponse.Merge(m, src)
}
func (m *MsgOperatorDetachResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOperatorDetachResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOperatorDetachResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOperatorDetachResponse proto.InternalMessageInfo

// Deprecated: use MsgOperatorAttach
//
// MsgAttachFrom is the Msg/AttachFrom request type.
type MsgAttachFrom struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Proxy string `protobuf:"bytes,2,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// address of the owner of the token.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// token id of the token to attach.
	TokenId string `protobuf:"bytes,4,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	// to token id which one attachs the token to.
	ToTokenId string `protobuf:"bytes,5,opt,name=to_token_id,json=toTokenId,proto3" json:"to_token_id,omitempty"`
}

func (m *MsgAttachFrom) Reset()         { *m = MsgAttachFrom{} }
func (m *MsgAttachFrom) String() string { return proto.CompactTextString(m) }
func (*MsgAttachFrom) ProtoMessage()    {}
func (*MsgAttachFrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{71}
}
func (m *MsgAttachFrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAttachFrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAttachFrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAttachFrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAttachFrom.Merge(m, src)
}
func (m *MsgAttachFrom) XXX_Size() int {
	return m.Size()
}
func (m *MsgAttachFrom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAttachFrom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAttachFrom proto.InternalMessageInfo

func (m *MsgAttachFrom) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgAttachFrom) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *MsgAttachFrom) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgAttachFrom) GetTokenId() string {
	if m != nil {
		return m.TokenId
	}
	return ""
}

func (m *MsgAttachFrom) GetToTokenId() string {
	if m != nil {
		return m.ToTokenId
	}
	return ""
}

// Deprecated: do not use
//
// MsgAttachFromResponse is the Msg/AttachFrom response type.
type MsgAttachFromResponse struct {
}

func (m *MsgAttachFromResponse) Reset()         { *m = MsgAttachFromResponse{} }
func (m *MsgAttachFromResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAttachFromResponse) ProtoMessage()    {}
func (*MsgAttachFromResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{72}
}
func (m *MsgAttachFromResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAttachFromResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAttachFromResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAttachFromResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAttachFromResponse.Merge(m, src)
}
func (m *MsgAttachFromResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAttachFromResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAttachFromResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAttachFromResponse proto.InternalMessageInfo

// Deprecated: use MsgOperatorDetach
//
// MsgDetachFrom is the Msg/DetachFrom request type.
type MsgDetachFrom struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Proxy string `protobuf:"bytes,2,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// address of the owner of the token.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// token id of the token to detach.
	TokenId string `protobuf:"bytes,4,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
}

func (m *MsgDetachFrom) Reset()         { *m = MsgDetachFrom{} }
func (m *MsgDetachFrom) String() string { return proto.CompactTextString(m) }
func (*MsgDetachFrom) ProtoMessage()    {}
func (*MsgDetachFrom) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{73}
}
func (m *MsgDetachFrom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDetachFrom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDetachFrom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDetachFrom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDetachFrom.Merge(m, src)
}
func (m *MsgDetachFrom) XXX_Size() int {
	return m.Size()
}
func (m *MsgDetachFrom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDetachFrom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDetachFrom proto.InternalMessageInfo

func (m *MsgDetachFrom) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *MsgDetachFrom) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *MsgDetachFrom) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *MsgDetachFrom) GetTokenId() string {
	if m != nil {
		return m.TokenId
	}
	return ""
}

// Deprecated: do not use
//
// MsgDetachFromResponse is the Msg/DetachFrom response type.
type MsgDetachFromResponse struct {
}

func (m *MsgDetachFromResponse) Reset()         { *m = MsgDetachFromResponse{} }
func (m *MsgDetachFromResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDetachFromResponse) ProtoMessage()    {}
func (*MsgDetachFromResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaee77977a3cfe12, []int{74}
}
func (m *MsgDetachFromResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDetachFromResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDetachFromResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDetachFromResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDetachFromResponse.Merge(m, src)
}
func (m *MsgDetachFromResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDetachFromResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDetachFromResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDetachFromResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgSend)(nil), "lbm.collection.v1.MsgSend")
	proto.RegisterType((*MsgSendResponse)(nil), "lbm.collection.v1.MsgSendResponse")
	proto.RegisterType((*MsgOperatorSend)(nil), "lbm.collection.v1.MsgOperatorSend")
	proto.RegisterType((*MsgOperatorSendResponse)(nil), "lbm.collection.v1.MsgOperatorSendResponse")
	proto.RegisterType((*MsgTransferFT)(nil), "lbm.collection.v1.MsgTransferFT")
	proto.RegisterType((*MsgTransferFTResponse)(nil), "lbm.collection.v1.MsgTransferFTResponse")
	proto.RegisterType((*MsgTransferFTFrom)(nil), "lbm.collection.v1.MsgTransferFTFrom")
	proto.RegisterType((*MsgTransferFTFromResponse)(nil), "lbm.collection.v1.MsgTransferFTFromResponse")
	proto.RegisterType((*MsgTransferNFT)(nil), "lbm.collection.v1.MsgTransferNFT")
	proto.RegisterType((*MsgTransferNFTResponse)(nil), "lbm.collection.v1.MsgTransferNFTResponse")
	proto.RegisterType((*MsgTransferNFTFrom)(nil), "lbm.collection.v1.MsgTransferNFTFrom")
	proto.RegisterType((*MsgTransferNFTFromResponse)(nil), "lbm.collection.v1.MsgTransferNFTFromResponse")
	proto.RegisterType((*MsgAuthorizeOperator)(nil), "lbm.collection.v1.MsgAuthorizeOperator")
	proto.RegisterType((*MsgAuthorizeOperatorResponse)(nil), "lbm.collection.v1.MsgAuthorizeOperatorResponse")
	proto.RegisterType((*MsgRevokeOperator)(nil), "lbm.collection.v1.MsgRevokeOperator")
	proto.RegisterType((*MsgRevokeOperatorResponse)(nil), "lbm.collection.v1.MsgRevokeOperatorResponse")
	proto.RegisterType((*MsgApprove)(nil), "lbm.collection.v1.MsgApprove")
	proto.RegisterType((*MsgApproveResponse)(nil), "lbm.collection.v1.MsgApproveResponse")
	proto.RegisterType((*MsgDisapprove)(nil), "lbm.collection.v1.MsgDisapprove")
	proto.RegisterType((*MsgDisapproveResponse)(nil), "lbm.collection.v1.MsgDisapproveResponse")
	proto.RegisterType((*MsgCreateContract)(nil), "lbm.collection.v1.MsgCreateContract")
	proto.RegisterType((*MsgCreateContractResponse)(nil), "lbm.collection.v1.MsgCreateContractResponse")
	proto.RegisterType((*MsgCreateFTClass)(nil), "lbm.collection.v1.MsgCreateFTClass")
	proto.RegisterType((*MsgCreateFTClassResponse)(nil), "lbm.collection.v1.MsgCreateFTClassResponse")
	proto.RegisterType((*MsgCreateNFTClass)(nil), "lbm.collection.v1.MsgCreateNFTClass")
	proto.RegisterType((*MsgCreateNFTClassResponse)(nil), "lbm.collection.v1.MsgCreateNFTClassResponse")
	proto.RegisterType((*MsgIssueFT)(nil), "lbm.collection.v1.MsgIssueFT")
	proto.RegisterType((*MsgIssueFTResponse)(nil), "lbm.collection.v1.MsgIssueFTResponse")
	proto.RegisterType((*MsgIssueNFT)(nil), "lbm.collection.v1.MsgIssueNFT")
	proto.RegisterType((*MsgIssueNFTResponse)(nil), "lbm.collection.v1.MsgIssueNFTResponse")
	proto.RegisterType((*MsgMintFT)(nil), "lbm.collection.v1.MsgMintFT")
	proto.RegisterType((*MsgMintFTResponse)(nil), "lbm.collection.v1.MsgMintFTResponse")
	proto.RegisterType((*MsgMintNFT)(nil), "lbm.collection.v1.MsgMintNFT")
	proto.RegisterType((*MsgMintNFTResponse)(nil), "lbm.collection.v1.MsgMintNFTResponse")
	proto.RegisterType((*MintNFTParam)(nil), "lbm.collection.v1.MintNFTParam")
	proto.RegisterType((*MsgBurn)(nil), "lbm.collection.v1.MsgBurn")
	proto.RegisterType((*MsgBurnResponse)(nil), "lbm.collection.v1.MsgBurnResponse")
	proto.RegisterType((*MsgOperatorBurn)(nil), "lbm.collection.v1.MsgOperatorBurn")
	proto.RegisterType((*MsgOperatorBurnResponse)(nil), "lbm.collection.v1.MsgOperatorBurnResponse")
	proto.RegisterType((*MsgBurnFT)(nil), "lbm.collection.v1.MsgBurnFT")
	proto.RegisterType((*MsgBurnFTResponse)(nil), "lbm.collection.v1.MsgBurnFTResponse")
	proto.RegisterType((*MsgBurnFTFrom)(nil), "lbm.collection.v1.MsgBurnFTFrom")
	proto.RegisterType((*MsgBurnFTFromResponse)(nil), "lbm.collection.v1.MsgBurnFTFromResponse")
	proto.RegisterType((*MsgBurnNFT)(nil), "lbm.collection.v1.MsgBurnNFT")
	proto.RegisterType((*MsgBurnNFTResponse)(nil), "lbm.collection.v1.MsgBurnNFTResponse")
	proto.RegisterType((*MsgBurnNFTFrom)(nil), "lbm.collection.v1.MsgBurnNFTFrom")
	proto.RegisterType((*MsgBurnNFTFromResponse)(nil), "lbm.collection.v1.MsgBurnNFTFromResponse")
	proto.RegisterType((*MsgModifyContract)(nil), "lbm.collection.v1.MsgModifyContract")
	proto.RegisterType((*MsgModifyContractResponse)(nil), "lbm.collection.v1.MsgModifyContractResponse")
	proto.RegisterType((*MsgModifyTokenClass)(nil), "lbm.collection.v1.MsgModifyTokenClass")
	proto.RegisterType((*MsgModifyTokenClassResponse)(nil), "lbm.collection.v1.MsgModifyTokenClassResponse")
	proto.RegisterType((*MsgModifyNFT)(nil), "lbm.collection.v1.MsgModifyNFT")
	proto.RegisterType((*MsgModifyNFTResponse)(nil), "lbm.collection.v1.MsgModifyNFTResponse")
	proto.RegisterType((*MsgModify)(nil), "lbm.collection.v1.MsgModify")
	proto.RegisterType((*MsgModifyResponse)(nil), "lbm.collection.v1.MsgModifyResponse")
	proto.RegisterType((*MsgGrant)(nil), "lbm.collection.v1.MsgGrant")
	proto.RegisterType((*MsgGrantResponse)(nil), "lbm.collection.v1.MsgGrantResponse")
	proto.RegisterType((*MsgAbandon)(nil), "lbm.collection.v1.MsgAbandon")
	proto.RegisterType((*MsgAbandonResponse)(nil), "lbm.collection.v1.MsgAbandonResponse")
	proto.RegisterType((*MsgGrantPermission)(nil), "lbm.collection.v1.MsgGrantPermission")
	proto.RegisterType((*MsgGrantPermissionResponse)(nil), "lbm.collection.v1.MsgGrantPermissionResponse")
	proto.RegisterType((*MsgRevokePermission)(nil), "lbm.collection.v1.MsgRevokePermission")
	proto.RegisterType((*MsgRevokePermissionResponse)(nil), "lbm.collection.v1.MsgRevokePermissionResponse")
	proto.RegisterType((*MsgAttach)(nil), "lbm.collection.v1.MsgAttach")
	proto.RegisterType((*MsgAttachResponse)(nil), "lbm.collection.v1.MsgAttachResponse")
	proto.RegisterType((*MsgDetach)(nil), "lbm.collection.v1.MsgDetach")
	proto.RegisterType((*MsgDetachResponse)(nil), "lbm.collection.v1.MsgDetachResponse")
	proto.RegisterType((*MsgOperatorAttach)(nil), "lbm.collection.v1.MsgOperatorAttach")
	proto.RegisterType((*MsgOperatorAttachResponse)(nil), "lbm.collection.v1.MsgOperatorAttachResponse")
	proto.RegisterType((*MsgOperatorDetach)(nil), "lbm.collection.v1.MsgOperatorDetach")
	proto.RegisterType((*MsgOperatorDetachResponse)(nil), "lbm.collection.v1.MsgOperatorDetachResponse")
	proto.RegisterType((*MsgAttachFrom)(nil), "lbm.collection.v1.MsgAttachFrom")
	proto.RegisterType((*MsgAttachFromResponse)(nil), "lbm.collection.v1.MsgAttachFromResponse")
	proto.RegisterType((*MsgDetachFrom)(nil), "lbm.collection.v1.MsgDetachFrom")
	proto.RegisterType((*MsgDetachFromResponse)(nil), "lbm.collection.v1.MsgDetachFromResponse")
}

func init() { proto.RegisterFile("lbm/collection/v1/tx.proto", fileDescriptor_eaee77977a3cfe12) }

var fileDescriptor_eaee77977a3cfe12 = []byte{
	// 2011 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x5a, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xd7, 0x8a, 0x14, 0x49, 0x3d, 0xd9, 0x8e, 0xbd, 0x76, 0x6d, 0x7a, 0x25, 0x51, 0xf2, 0x46,
	0x52, 0x64, 0xc7, 0x21, 0x11, 0x17, 0x3e, 0x14, 0x68, 0x0a, 0x48, 0x0a, 0x54, 0x10, 0x28, 0xe5,
	0x80, 0x95, 0x81, 0xa2, 0x01, 0x22, 0x2c, 0xc9, 0x31, 0xb5, 0x16, 0xb9, 0x4b, 0xec, 0x2e, 0x15,
	0xa9, 0x05, 0x8a, 0x9e, 0x7a, 0x69, 0x11, 0xb8, 0x87, 0x02, 0x3d, 0xf5, 0x50, 0xb4, 0x40, 0xd0,
	0xde, 0x7a, 0xef, 0x3d, 0xc7, 0x1c, 0x8b, 0x1e, 0xd2, 0x42, 0x06, 0xfa, 0x27, 0xf4, 0x1c, 0xcc,
	0xc7, 0x0e, 0x67, 0x76, 0x77, 0x76, 0x57, 0x22, 0x95, 0x1b, 0x67, 0xdf, 0x9b, 0x79, 0xbf, 0xf7,
	0x31, 0xf3, 0x3e, 0x24, 0x30, 0x06, 0x9d, 0x61, 0xa3, 0xeb, 0x0e, 0x06, 0xa8, 0x1b, 0xd8, 0xae,
	0xd3, 0x38, 0xfd, 0xb0, 0x11, 0x9c, 0xd5, 0x47, 0x9e, 0x1b, 0xb8, 0xfa, 0x9d, 0x41, 0x67, 0x58,
	0x9f, 0xd0, 0xea, 0xa7, 0x1f, 0x1a, 0xf7, 0xfa, 0x6e, 0xdf, 0x25, 0xd4, 0x06, 0xfe, 0x45, 0x19,
	0x0d, 0x33, 0x7e, 0x88, 0xb0, 0x8d, 0xf0, 0x98, 0x5f, 0x68, 0x50, 0x6e, 0xf9, 0xfd, 0x9f, 0x22,
	0xa7, 0xa7, 0xaf, 0xc1, 0x52, 0xd7, 0x75, 0x02, 0xcf, 0xea, 0x06, 0x47, 0x76, 0xaf, 0xaa, 0xad,
	0x6b, 0xdb, 0x8b, 0x6d, 0x08, 0x3f, 0x35, 0x7b, 0xba, 0x0e, 0xc5, 0x57, 0x9e, 0x3b, 0xac, 0xce,
	0x13, 0x0a, 0xf9, 0xad, 0xdf, 0x82, 0xf9, 0xc0, 0xad, 0x16, 0xc8, 0x97, 0xf9, 0xc0, 0xd5, 0x7f,
	0x04, 0x25, 0x6b, 0xe8, 0x8e, 0x9d, 0xa0, 0x5a, 0x5c, 0x2f, 0x6c, 0x2f, 0x3d, 0x7b, 0x50, 0x8f,
	0xc1, 0xad, 0xef, 0xb9, 0xb6, 0xb3, 0x7b, 0xf3, 0xab, 0x6f, 0xd6, 0xe6, 0xfe, 0xf6, 0x9f, 0xb5,
	0x05, 0xbc, 0xf2, 0xdb, 0x6c, 0x97, 0x79, 0x07, 0xde, 0x61, 0x78, 0xda, 0xc8, 0x1f, 0xb9, 0x8e,
	0x8f, 0xcc, 0x7f, 0x68, 0xe4, 0xdb, 0x8b, 0x11, 0xf2, 0xac, 0xc0, 0xf5, 0xf2, 0x61, 0x35, 0xa0,
	0xe2, 0xb2, 0x0d, 0x0c, 0x2f, 0x5f, 0x73, 0x3d, 0x0a, 0x31, 0x3d, 0x8a, 0x09, 0x7a, 0x2c, 0x5c,
	0x49, 0x8f, 0x87, 0xf0, 0x20, 0x82, 0x99, 0xeb, 0xf3, 0x5b, 0x0d, 0x6e, 0xb6, 0xfc, 0xfe, 0xa1,
	0x67, 0x39, 0xfe, 0x2b, 0xe4, 0xed, 0x1f, 0xce, 0xc6, 0xf2, 0xcf, 0xf3, 0x5a, 0xbe, 0x88, 0x11,
	0x73, 0xa0, 0x0f, 0xe0, 0x7b, 0x12, 0x18, 0x0e, 0xf3, 0xaf, 0x1a, 0xdc, 0x91, 0x28, 0xfb, 0x58,
	0x6a, 0x26, 0xd4, 0x7b, 0xb0, 0x30, 0xf2, 0xdc, 0xb3, 0x73, 0x86, 0x95, 0x2e, 0x72, 0x99, 0xfc,
	0x79, 0x5e, 0x93, 0xcb, 0x0a, 0x2c, 0xc3, 0xc3, 0x18, 0x4c, 0xae, 0x84, 0x07, 0xb7, 0x04, 0xe2,
	0xc1, 0xac, 0x6c, 0xbd, 0x0c, 0x8b, 0x81, 0x7b, 0x82, 0x9c, 0x23, 0xbb, 0xe7, 0x13, 0x73, 0x2f,
	0xb6, 0x2b, 0xe4, 0x43, 0xb3, 0xe7, 0x9b, 0x55, 0xb8, 0x2f, 0xcb, 0xe4, 0x68, 0x7e, 0xa7, 0x81,
	0x2e, 0x93, 0xae, 0xdb, 0xa6, 0x12, 0xd0, 0x85, 0x08, 0xd0, 0x15, 0x30, 0xe2, 0x68, 0x38, 0xd8,
	0x13, 0xb8, 0xd7, 0xf2, 0xfb, 0x3b, 0xe3, 0xe0, 0xd8, 0xf5, 0xec, 0x5f, 0xa0, 0x30, 0x94, 0xb3,
	0xd1, 0xde, 0x87, 0xd2, 0xb1, 0x3b, 0xe8, 0xa1, 0xf0, 0xe2, 0xb1, 0x95, 0x74, 0x25, 0x0b, 0xf2,
	0x95, 0x34, 0x6b, 0xb0, 0x92, 0x24, 0x8c, 0x83, 0x39, 0x26, 0xb1, 0xd8, 0x46, 0xa7, 0xee, 0xc9,
	0x35, 0x23, 0xa1, 0xe1, 0x24, 0x4b, 0xe2, 0x30, 0x8e, 0x00, 0x30, 0xcc, 0xd1, 0xc8, 0x73, 0x4f,
	0x51, 0xae, 0x47, 0xc8, 0xa2, 0xbc, 0xfc, 0x11, 0x0a, 0xd7, 0x13, 0x9f, 0x16, 0x04, 0x9f, 0x9a,
	0xf7, 0x48, 0x80, 0x30, 0x01, 0x5c, 0x6c, 0x87, 0x3c, 0x18, 0x1f, 0xdb, 0xbe, 0x75, 0x7d, 0x92,
	0xe9, 0x3b, 0x30, 0x91, 0xc1, 0x85, 0xfb, 0xc4, 0xf4, 0x7b, 0x1e, 0xb2, 0x02, 0xb4, 0xc7, 0x24,
	0xe0, 0x33, 0xdc, 0xcf, 0x1d, 0xe4, 0x31, 0xd1, 0x74, 0x81, 0x23, 0xd2, 0xb1, 0x86, 0x28, 0xbc,
	0x3a, 0xf8, 0xb7, 0xbe, 0x0e, 0x37, 0x3a, 0x96, 0x8f, 0x8e, 0xec, 0x61, 0xff, 0x68, 0xec, 0xd9,
	0x4c, 0x28, 0xe0, 0x6f, 0xcd, 0x61, 0xff, 0xa5, 0x67, 0xe3, 0x5d, 0x43, 0x14, 0x58, 0x2c, 0x6a,
	0xc9, 0x6f, 0xf3, 0x7d, 0xe2, 0x05, 0x59, 0x68, 0x88, 0x08, 0x07, 0x39, 0x57, 0x7a, 0xde, 0xee,
	0x99, 0xff, 0xd3, 0xe0, 0x36, 0xe7, 0xde, 0x3f, 0xdc, 0x1b, 0x58, 0xbe, 0x3f, 0x75, 0x86, 0x20,
	0x8a, 0x14, 0x04, 0x45, 0x12, 0x60, 0xe2, 0x33, 0x7a, 0xa8, 0x6b, 0x0f, 0xad, 0x01, 0xbe, 0x5d,
	0xda, 0xf6, 0x42, 0x9b, 0xaf, 0xd9, 0x55, 0x2c, 0xf1, 0xab, 0xb8, 0x03, 0x25, 0x7f, 0x3c, 0x1a,
	0x0d, 0xce, 0xab, 0x65, 0xfc, 0x6d, 0xf7, 0x31, 0x7e, 0xc5, 0xfe, 0xfd, 0xcd, 0xda, 0xa3, 0xbe,
	0x1d, 0x1c, 0x8f, 0x3b, 0xf5, 0xae, 0x3b, 0x6c, 0x0c, 0x6c, 0x07, 0x35, 0x06, 0x9d, 0xe1, 0x07,
	0x7e, 0xef, 0xa4, 0x11, 0x9c, 0x8f, 0x90, 0x5f, 0x6f, 0x3a, 0x41, 0x9b, 0x6d, 0x34, 0x9f, 0x40,
	0x35, 0xaa, 0xa7, 0xd2, 0x28, 0x67, 0x82, 0xdb, 0x0e, 0xbe, 0x4b, 0xa3, 0x48, 0xbe, 0x3b, 0xc8,
	0x82, 0xf9, 0x7f, 0x8d, 0x5c, 0xa9, 0xa6, 0xef, 0x8f, 0x51, 0xce, 0xd7, 0x39, 0x16, 0x62, 0x21,
	0x88, 0x82, 0xc2, 0x33, 0xc5, 0x88, 0x67, 0x0c, 0xa8, 0x0c, 0x6d, 0x27, 0xb0, 0x3a, 0x03, 0x44,
	0xbc, 0x56, 0x69, 0xf3, 0xf5, 0x24, 0xb0, 0x4b, 0x62, 0x60, 0x53, 0x5f, 0x96, 0x45, 0x5f, 0xb2,
	0x54, 0x55, 0xb9, 0xb4, 0x2f, 0x59, 0xda, 0xda, 0x20, 0x37, 0x9d, 0xe9, 0xad, 0x34, 0xcf, 0x00,
	0x96, 0x42, 0xae, 0x83, 0x59, 0x9a, 0x87, 0xab, 0x59, 0x14, 0xd4, 0x34, 0x37, 0xe1, 0xae, 0x20,
	0x4d, 0x09, 0xea, 0x8d, 0x06, 0x8b, 0x2d, 0xbf, 0xdf, 0xb2, 0x9d, 0x60, 0x56, 0x09, 0x75, 0xda,
	0xb2, 0xf1, 0x2e, 0x89, 0x76, 0x8a, 0x88, 0xbf, 0x5c, 0x6f, 0x68, 0x6c, 0xe1, 0xaf, 0x33, 0xcb,
	0xfc, 0x1f, 0x41, 0x69, 0x64, 0x79, 0xd6, 0xd0, 0x67, 0x40, 0xd7, 0x12, 0x80, 0x32, 0x81, 0x9f,
	0x60, 0xbe, 0xb0, 0x58, 0xa1, 0x9b, 0xcc, 0x2d, 0xe2, 0x75, 0xc6, 0xc0, 0x0d, 0x7c, 0x1b, 0x0a,
	0x38, 0x3f, 0x6b, 0x24, 0x3f, 0xe3, 0x9f, 0xe6, 0x4b, 0xb8, 0x21, 0x9e, 0xa2, 0xaf, 0x02, 0xd0,
	0x3c, 0x8e, 0x03, 0x89, 0x41, 0xa7, 0x99, 0xfd, 0xf0, 0x7c, 0x84, 0xf2, 0xba, 0xdd, 0xfc, 0x15,
	0xa9, 0xf6, 0x77, 0xc7, 0x9e, 0x73, 0x35, 0x6b, 0x4c, 0xdc, 0x54, 0x98, 0xa2, 0xba, 0xc7, 0xf2,
	0xb9, 0x93, 0xfe, 0x2c, 0x57, 0xf7, 0xf9, 0xb0, 0x5d, 0xb6, 0xba, 0x9f, 0x36, 0xbc, 0xe4, 0x6a,
	0x5e, 0xc2, 0xff, 0x39, 0xb9, 0x0b, 0xf8, 0xd3, 0x55, 0x43, 0xec, 0x79, 0x5e, 0xa3, 0xca, 0x75,
	0x2f, 0x0d, 0x79, 0x2a, 0x98, 0xa3, 0xf9, 0x3d, 0xed, 0x2d, 0xe8, 0xd7, 0x59, 0x17, 0x97, 0x53,
	0x75, 0x18, 0x13, 0x48, 0x1c, 0xec, 0x67, 0xe4, 0x7a, 0x62, 0xc2, 0x95, 0xaf, 0xa7, 0x54, 0xdf,
	0x16, 0x22, 0xf5, 0x2d, 0x2d, 0xa6, 0xd8, 0xf9, 0x5c, 0xea, 0x19, 0x69, 0x09, 0xd8, 0xd7, 0x59,
	0x9b, 0x28, 0x47, 0x63, 0x20, 0x48, 0xe6, 0x98, 0xbe, 0xa0, 0xbd, 0x56, 0xcb, 0xed, 0xd9, 0xaf,
	0xce, 0x79, 0x91, 0x35, 0xd5, 0x35, 0xf8, 0x21, 0x94, 0xbb, 0xc7, 0x96, 0xd3, 0x47, 0x3e, 0x0b,
	0xab, 0x95, 0x04, 0x6f, 0xed, 0x04, 0x81, 0x67, 0x77, 0xc6, 0x01, 0x62, 0x2e, 0x0b, 0xb7, 0xb0,
	0x2a, 0x58, 0xc6, 0xc3, 0xd1, 0xfe, 0x5d, 0x23, 0x79, 0x82, 0x52, 0x0f, 0xb1, 0x76, 0x33, 0xa8,
	0x2e, 0x1e, 0x42, 0xa5, 0x8b, 0x4f, 0xc1, 0x3b, 0xa9, 0x45, 0xcb, 0x64, 0xdd, 0xec, 0x89, 0xaa,
	0x14, 0x2f, 0xaf, 0xca, 0x2a, 0x2c, 0x27, 0x80, 0xe5, 0xca, 0xfc, 0x45, 0x83, 0x1b, 0x9c, 0x9e,
	0x2b, 0x0e, 0x33, 0xb4, 0x08, 0xfd, 0x1f, 0x6a, 0xc1, 0xdc, 0x3f, 0xa5, 0x16, 0xf7, 0x49, 0x37,
	0xc6, 0x51, 0x72, 0xf8, 0xff, 0x64, 0xb9, 0x98, 0x10, 0x72, 0x45, 0x32, 0xcd, 0xfb, 0xf3, 0x62,
	0x79, 0x23, 0x67, 0x97, 0x42, 0x34, 0xbb, 0xac, 0xc1, 0x12, 0x53, 0xca, 0xe9, 0xa1, 0x33, 0x56,
	0x32, 0xd0, 0x1d, 0x4d, 0xfc, 0x45, 0xff, 0xc1, 0x44, 0x35, 0xda, 0xba, 0x3f, 0x4c, 0x7a, 0x19,
	0x08, 0x47, 0x54, 0xaf, 0xbb, 0x42, 0xe0, 0x73, 0xa5, 0xfe, 0xa4, 0x41, 0xa5, 0xe5, 0xf7, 0x7f,
	0xec, 0x59, 0x4e, 0x8e, 0x5b, 0x50, 0x85, 0x72, 0x1f, 0x73, 0x72, 0xad, 0xc2, 0xe5, 0x84, 0x12,
	0x2a, 0x15, 0x2e, 0xf5, 0x8f, 0x00, 0x46, 0xc8, 0x1b, 0xda, 0xbe, 0x6f, 0xbb, 0x0e, 0xd1, 0xe8,
	0xd6, 0xb3, 0xd5, 0x04, 0xd0, 0x9f, 0x70, 0xa6, 0xb6, 0xb0, 0xc1, 0xd4, 0x49, 0xc3, 0x41, 0xf0,
	0x71, 0xd0, 0xbf, 0xa1, 0xd5, 0xc6, 0x4e, 0xc7, 0x72, 0x7a, 0xae, 0x73, 0x09, 0xd8, 0x48, 0x86,
	0x1d, 0x05, 0x57, 0xb8, 0x2c, 0x38, 0xd6, 0x43, 0x52, 0x1c, 0x1c, 0xde, 0x39, 0xf9, 0x4a, 0x20,
	0x4f, 0xf6, 0xcd, 0xa6, 0x26, 0xaa, 0xc5, 0x8c, 0xb9, 0x28, 0x01, 0xa2, 0x73, 0x86, 0x88, 0x68,
	0x0e, 0xec, 0x35, 0x79, 0x4c, 0x68, 0xc3, 0x3d, 0x2d, 0xb2, 0x5a, 0xcc, 0x72, 0x32, 0x12, 0xfa,
	0x16, 0x44, 0x65, 0x71, 0x28, 0xbf, 0x24, 0x77, 0x69, 0x27, 0x08, 0xac, 0xee, 0xf1, 0xd5, 0x00,
	0xa4, 0xdc, 0xff, 0x1a, 0xbe, 0x45, 0x47, 0x9c, 0x5a, 0x0c, 0x6f, 0xd9, 0x21, 0xa5, 0xb3, 0x9b,
	0x40, 0x85, 0x73, 0x44, 0x9f, 0x12, 0x44, 0x1f, 0xa3, 0xeb, 0x40, 0xc4, 0x24, 0xd2, 0xc3, 0xb9,
	0xc4, 0x3f, 0xd2, 0x54, 0x14, 0xd6, 0x3a, 0x79, 0x8d, 0x91, 0xf6, 0x28, 0xf2, 0x47, 0xa7, 0x20,
	0x3e, 0x3a, 0x55, 0x28, 0xfb, 0xe3, 0xce, 0x6b, 0xd4, 0x0d, 0x98, 0x2d, 0xc2, 0xa5, 0x7e, 0x1f,
	0x4a, 0x81, 0xe5, 0xf5, 0x51, 0x40, 0xba, 0xb3, 0xc5, 0x36, 0x5b, 0xb1, 0xa4, 0x24, 0x23, 0xe3,
	0xb8, 0x7f, 0x2d, 0xe3, 0xce, 0x6b, 0xb2, 0x19, 0xe2, 0x8e, 0xe0, 0x8b, 0xd8, 0xf5, 0x0f, 0xb4,
	0x32, 0xa3, 0xa8, 0x67, 0x5d, 0x76, 0x88, 0x4e, 0x2e, 0xa6, 0x86, 0xdd, 0x42, 0x34, 0xec, 0x68,
	0x75, 0x36, 0x81, 0xc5, 0x01, 0x8f, 0xe9, 0xd0, 0x09, 0x7d, 0xb7, 0x78, 0xc3, 0x39, 0x14, 0x8a,
	0xe2, 0x79, 0xf6, 0xa5, 0x01, 0x85, 0x96, 0xdf, 0xd7, 0xf7, 0xa1, 0x48, 0xfe, 0x04, 0x60, 0x24,
	0x75, 0x5e, 0xf4, 0x4f, 0x07, 0x86, 0xa9, 0xa6, 0xf1, 0xa6, 0xeb, 0x33, 0xb8, 0x21, 0xfd, 0x49,
	0x41, 0xb1, 0x47, 0xe4, 0x31, 0x9e, 0x64, 0xf3, 0xf0, 0xf3, 0x7f, 0x06, 0x20, 0x8c, 0xf8, 0xd7,
	0x93, 0x77, 0x4e, 0x38, 0x8c, 0xed, 0x2c, 0x0e, 0x7e, 0x72, 0x0f, 0x6e, 0x45, 0xa6, 0xf2, 0x1b,
	0x59, 0x7b, 0x31, 0x97, 0xf1, 0x34, 0x0f, 0x17, 0x97, 0xf2, 0x29, 0x2c, 0x89, 0x73, 0xf3, 0x47,
	0xe9, 0x9b, 0x0f, 0xf6, 0x0f, 0x8d, 0xc7, 0x99, 0x2c, 0xfc, 0xf0, 0x3e, 0xbc, 0x13, 0x9d, 0x82,
	0x6f, 0x66, 0xee, 0x26, 0x4a, 0x7c, 0x90, 0x8b, 0x8d, 0x0b, 0x1a, 0xc2, 0x9d, 0xf8, 0x08, 0xfb,
	0xbd, 0xe4, 0x33, 0x62, 0x8c, 0x46, 0x23, 0x27, 0xa3, 0xe8, 0x9a, 0xc8, 0x90, 0x5a, 0xe1, 0x1a,
	0x99, 0x4b, 0xe5, 0x9a, 0xe4, 0x31, 0xb4, 0xfe, 0x02, 0xca, 0xe1, 0x0c, 0x7a, 0x55, 0x81, 0x90,
	0x92, 0x8d, 0xcd, 0x54, 0xb2, 0x18, 0xab, 0xc2, 0x74, 0x59, 0x11, 0xab, 0x13, 0x0e, 0x55, 0xac,
	0xc6, 0xa7, 0xc7, 0xd8, 0x20, 0x91, 0xd1, 0xb1, 0xc2, 0x20, 0x32, 0x97, 0xca, 0x20, 0x8a, 0x89,
	0xb0, 0x05, 0x37, 0xe5, 0xe9, 0xef, 0xbb, 0x69, 0xdb, 0x19, 0x93, 0xf1, 0x7e, 0x0e, 0xa6, 0xb8,
	0x22, 0x7c, 0x98, 0x9a, 0xaa, 0x48, 0xc8, 0x95, 0xae, 0x48, 0x6c, 0x3c, 0xfa, 0x02, 0xca, 0xe1,
	0x28, 0x54, 0xe1, 0x59, 0x46, 0x56, 0x79, 0x36, 0x3a, 0x50, 0x6c, 0x43, 0x85, 0x4f, 0x0f, 0x6b,
	0x29, 0x5b, 0xf0, 0xfd, 0xdd, 0x4a, 0xa7, 0xf3, 0x33, 0x7f, 0x02, 0x25, 0x36, 0xfb, 0x5b, 0x49,
	0xde, 0x41, 0xa9, 0xc6, 0x46, 0x1a, 0x55, 0x54, 0x39, 0x9c, 0xd0, 0xad, 0xaa, 0x37, 0x1c, 0xa8,
	0x55, 0x8e, 0x4e, 0xd3, 0xf6, 0xa1, 0x48, 0xa6, 0x48, 0x8a, 0x04, 0x81, 0x69, 0xaa, 0x04, 0x21,
	0x4e, 0x76, 0xc4, 0x04, 0x41, 0xce, 0xcb, 0x48, 0x10, 0xe4, 0xdc, 0x27, 0xd9, 0x3c, 0xa2, 0x19,
	0xd9, 0xd8, 0x68, 0x45, 0x8d, 0x46, 0x6d, 0x46, 0x79, 0xf2, 0x83, 0xaf, 0xb0, 0x30, 0xf5, 0x59,
	0x4f, 0xdb, 0x43, 0xde, 0xd1, 0xed, 0x2c, 0x0e, 0xd1, 0x41, 0xe1, 0x8c, 0x66, 0x55, 0xbd, 0x29,
	0xc5, 0x41, 0x91, 0x09, 0x0c, 0xce, 0x2c, 0xe2, 0xf8, 0xe5, 0x51, 0xea, 0x2e, 0x02, 0xf6, 0x71,
	0x26, 0x8b, 0x78, 0x4f, 0x23, 0x63, 0x14, 0x55, 0x18, 0x4a, 0x5c, 0xaa, 0x7b, 0x9a, 0x3c, 0x02,
	0xd1, 0x5f, 0xc3, 0xed, 0xd8, 0xf8, 0x63, 0x2b, 0xed, 0x84, 0x09, 0x9f, 0x51, 0xcf, 0xc7, 0xc7,
	0x65, 0xbd, 0x84, 0x45, 0x61, 0x3a, 0x91, 0xb6, 0x19, 0xfb, 0xe0, 0xbd, 0x0c, 0x06, 0xe9, 0x16,
	0xd3, 0xa9, 0xc1, 0x4a, 0xda, 0x16, 0x23, 0xd5, 0x7c, 0xfc, 0xb4, 0x26, 0x2c, 0xd0, 0x76, 0x7d,
	0x39, 0x99, 0x9d, 0x10, 0x8d, 0x77, 0x53, 0x88, 0x52, 0x76, 0x63, 0x4d, 0xb4, 0x2a, 0xbb, 0x51,
	0xb2, 0x32, 0xbb, 0xc9, 0xad, 0x2f, 0x2e, 0x36, 0xa2, 0x7d, 0xef, 0x66, 0x0a, 0x90, 0x09, 0x9b,
	0xaa, 0xd8, 0x50, 0xb4, 0xb2, 0x38, 0x2a, 0x62, 0x7d, 0xec, 0x56, 0x5a, 0x66, 0x17, 0x44, 0xd5,
	0xf3, 0xf1, 0x89, 0xee, 0x63, 0xbd, 0x99, 0xc2, 0x7d, 0x94, 0xaa, 0x72, 0x9f, 0xdc, 0x3d, 0xe1,
	0xd3, 0x58, 0xc7, 0xa4, 0x38, 0x8d, 0x52, 0x55, 0xa7, 0xc9, 0xbd, 0x0e, 0xbe, 0x83, 0x91, 0xfe,
	0x71, 0x23, 0xfd, 0x5d, 0x64, 0x58, 0x9f, 0xe6, 0xe1, 0x4a, 0x92, 0xc2, 0xb0, 0x67, 0x48, 0x61,
	0x3a, 0x3c, 0xcd, 0xc3, 0x25, 0xbe, 0xab, 0x42, 0xcf, 0xb6, 0x9e, 0x66, 0xcd, 0xb4, 0x77, 0x35,
	0xde, 0x60, 0x91, 0xa2, 0x0b, 0x65, 0x9d, 0x3c, 0xe1, 0x50, 0x16, 0x5d, 0xb1, 0x56, 0x69, 0x77,
	0xf7, 0xcb, 0x8b, 0xda, 0xdc, 0x57, 0x17, 0x35, 0xed, 0xeb, 0x8b, 0x9a, 0xf6, 0xdf, 0x8b, 0x9a,
	0xf6, 0xe6, 0x6d, 0x6d, 0xee, 0xeb, 0xb7, 0xb5, 0xb9, 0x7f, 0xbd, 0xad, 0xcd, 0xfd, 0x7c, 0x43,
	0xf5, 0x47, 0xca, 0x33, 0xe1, 0xff, 0xc3, 0x3a, 0x25, 0xf2, 0x0f, 0x62, 0xdf, 0xff, 0x36, 0x00,
	0x00, 0xff, 0xff, 0xd6, 0x51, 0xfa, 0xbf, 0x8b, 0x26, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Send defines a method to send tokens from one account to another account.
	// Fires:
	// - EventSent
	// - transfer_ft (deprecated, not typed)
	// - transfer_nft (deprecated, not typed)
	// - operation_transfer_nft (deprecated, not typed)
	// Throws:
	// - ErrInsufficientFunds:
	//   - the balance of `from` does not have enough tokens to spend.
	// Info: one can send both fungible tokens and non-fungible tokens.
	// Since: 0.46.0 (finschia)
	Send(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error)
	// OperatorSend defines a method to send tokens from one account to another account by the operator.
	// Fires:
	// - EventSent
	// - transfer_ft_from (deprecated, not typed)
	// - transfer_nft_from (deprecated, not typed)
	// - operation_transfer_nft (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized:
	//   - the holder has not authorized the operator.
	// - ErrInsufficientFunds:
	//   - the balance of `from` does not have enough tokens to spend.
	// Info: one can send both fungible tokens and non-fungible tokens.
	// Since: 0.46.0 (finschia)
	OperatorSend(ctx context.Context, in *MsgOperatorSend, opts ...grpc.CallOption) (*MsgOperatorSendResponse, error)
	// Deprecated: use Send
	// TransferFT defines a method to send fungible tokens from one account to another account.
	TransferFT(ctx context.Context, in *MsgTransferFT, opts ...grpc.CallOption) (*MsgTransferFTResponse, error)
	// Deprecated: use OperatorSend
	// TransferFTFrom defines a method to send fungible tokens from one account to another account by the operator.
	TransferFTFrom(ctx context.Context, in *MsgTransferFTFrom, opts ...grpc.CallOption) (*MsgTransferFTFromResponse, error)
	// Deprecated: use Send
	// TransferNFT defines a method to send non-fungible tokens from one account to another account.
	TransferNFT(ctx context.Context, in *MsgTransferNFT, opts ...grpc.CallOption) (*MsgTransferNFTResponse, error)
	// Deprecated: use OperatorSend
	// TransferNFTFrom defines a method to send non-fungible tokens from one account to another account by the operator.
	TransferNFTFrom(ctx context.Context, in *MsgTransferNFTFrom, opts ...grpc.CallOption) (*MsgTransferNFTFromResponse, error)
	// AuthorizeOperator allows one to send tokens on behalf of the approver.
	// Fires:
	// - EventAuthorizedOperator
	// - approve_collection (deprecated, not typed)
	// Throws:
	// - ErrNotFound:
	//   - there is no contract of `contract_id`.
	// - ErrInvalidRequest:
	//   - `holder` has already authorized `operator`.
	// Since: 0.46.0 (finschia)
	AuthorizeOperator(ctx context.Context, in *MsgAuthorizeOperator, opts ...grpc.CallOption) (*MsgAuthorizeOperatorResponse, error)
	// RevokeOperator revokes the authorization of the operator to send the approver's token.
	// Fires:
	// - EventRevokedOperator
	// - disapprove_collection (deprecated, not typed)
	// Throws:
	// - ErrNotFound:
	//   - there is no contract of `contract_id`.
	//   - there is no authorization by `holder` to `operator`.
	// Since: 0.46.0 (finschia)
	RevokeOperator(ctx context.Context, in *MsgRevokeOperator, opts ...grpc.CallOption) (*MsgRevokeOperatorResponse, error)
	// Deprecated: use AuthorizeOperator
	// Approve allows one to send tokens on behalf of the approver.
	Approve(ctx context.Context, in *MsgApprove, opts ...grpc.CallOption) (*MsgApproveResponse, error)
	// Deprecated: use RevokeOperator
	// Disapprove revokes the authorization of the operator to send the approver's token.
	Disapprove(ctx context.Context, in *MsgDisapprove, opts ...grpc.CallOption) (*MsgDisapproveResponse, error)
	// CreateContract defines a method to create a contract for collection.
	// it grants `mint`, `burn`, `modify` and `issue` permissions on the contract to its creator.
	// Fires:
	// - EventCreatedContract
	// - create_collection (deprecated, not typed)
	CreateContract(ctx context.Context, in *MsgCreateContract, opts ...grpc.CallOption) (*MsgCreateContractResponse, error)
	// CreateFTClass defines a method to create a class of fungible token.
	// one may set the supply on the creation, then no one can change the supply, which means no more mints and burns.
	// Fires:
	// - EventCreatedFTClass
	// - EventMintedFT
	// - issue_ft (deprecated, not typed)
	// Since: 0.46.0 (finschia)
	CreateFTClass(ctx context.Context, in *MsgCreateFTClass, opts ...grpc.CallOption) (*MsgCreateFTClassResponse, error)
	// CreateNFTClass defines a method to create a class of non-fungible token.
	// Fires:
	// - EventCreatedNFTClass
	// - issue_nft (deprecated, not typed)
	// Since: 0.46.0 (finschia)
	CreateNFTClass(ctx context.Context, in *MsgCreateNFTClass, opts ...grpc.CallOption) (*MsgCreateNFTClassResponse, error)
	// Deprecated: use CreateFTClass
	// IssueFT defines a method to create a class of fungible token.
	// Fires:
	// - EventIssueFT
	// - EventMintedFT
	// - issue_ft (deprecated, not typed)
	// Note: it does not grant any permissions to its issuer.
	IssueFT(ctx context.Context, in *MsgIssueFT, opts ...grpc.CallOption) (*MsgIssueFTResponse, error)
	// Deprecated: use CreateNFTClass
	// IssueNFT defines a method to create a class of non-fungible token.
	// Fires:
	// - EventIssueNFT
	// - issue_nft (deprecated, not typed)
	// Note: it DOES grant `mint` and `burn` permissions to its issuer.
	IssueNFT(ctx context.Context, in *MsgIssueNFT, opts ...grpc.CallOption) (*MsgIssueNFTResponse, error)
	// MintFT defines a method to mint fungible tokens.
	// Fires:
	// - EventMintedFT
	// - mint_ft (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `from` does not have `mint` permission.
	MintFT(ctx context.Context, in *MsgMintFT, opts ...grpc.CallOption) (*MsgMintFTResponse, error)
	// MintNFT defines a method to mint non-fungible tokens.
	// Fires:
	// - EventMintedNFT
	// - mint_nft (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `from` does not have `mint` permission.
	MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error)
	// Burn defines a method to burn tokens.
	// Fires:
	// - EventBurned
	// - burn_ft (deprecated, not typed)
	// - burn_nft (deprecated, not typed)
	// - operation_burn_nft (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `from` does not have `burn` permission.
	// - ErrInsufficientFunds:
	//   - the balance of `from` does not have enough tokens to burn.
	// Info: one can burn both fungible tokens and non-fungible tokens.
	// Since: 0.46.0 (finschia)
	Burn(ctx context.Context, in *MsgBurn, opts ...grpc.CallOption) (*MsgBurnResponse, error)
	// OperatorBurn defines a method to burn tokens of the holder by the operator.
	// Fires:
	// - EventBurned
	// - burn_ft_from (deprecated, not typed)
	// - burn_nft_from (deprecated, not typed)
	// - operation_burn_nft (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `operator` does not have `burn` permission.
	//   - the holder has not authorized `operator`.
	// - ErrInsufficientFunds:
	//   - the balance of `from` does not have enough tokens to burn.
	// Info: one can burn both fungible tokens and non-fungible tokens.
	// Since: 0.46.0 (finschia)
	OperatorBurn(ctx context.Context, in *MsgOperatorBurn, opts ...grpc.CallOption) (*MsgOperatorBurnResponse, error)
	// Deprecated: use Burn
	// BurnFT defines a method to burn fungible tokens.
	BurnFT(ctx context.Context, in *MsgBurnFT, opts ...grpc.CallOption) (*MsgBurnFTResponse, error)
	// Deprecated: use OperatorBurn
	// BurnFTFrom defines a method to burn fungible tokens of the holder by the proxy.
	BurnFTFrom(ctx context.Context, in *MsgBurnFTFrom, opts ...grpc.CallOption) (*MsgBurnFTFromResponse, error)
	// Deprecated: use Burn
	// BurnNFT defines a method to burn non-fungible tokens.
	BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error)
	// Deprecated: use OperatorBurn
	// BurnNFTFrom defines a method to burn non-fungible tokens of the holder by the proxy.
	BurnNFTFrom(ctx context.Context, in *MsgBurnNFTFrom, opts ...grpc.CallOption) (*MsgBurnNFTFromResponse, error)
	// ModifyContract defines a method to modify the attributes of a contract.
	// Fires:
	// - EventModifiedContract
	// - modify_collection (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - the operator does not have `modify` permission.
	// - ErrNotFound
	//   - there is no token class of `contract_id`.
	// Since: 0.46.0 (finschia)
	ModifyContract(ctx context.Context, in *MsgModifyContract, opts ...grpc.CallOption) (*MsgModifyContractResponse, error)
	// ModifyTokenClass defines a method to modify the attributes of a token class.
	// Fires:
	// - EventModifiedTokenClass
	// - modify_token_type (deprecated, not typed)
	// - modify_token (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - the operator does not have `modify` permission.
	// - ErrNotFound
	//   - there is no token class of `contract_id`.
	// Since: 0.46.0 (finschia)
	ModifyTokenClass(ctx context.Context, in *MsgModifyTokenClass, opts ...grpc.CallOption) (*MsgModifyTokenClassResponse, error)
	// ModifyNFT defines a method to modify the attributes of a non-fungible token.
	// Fires:
	// - EventModifiedNFT
	// - modify_token (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - the operator does not have `modify` permission.
	// - ErrNotFound
	//   - there is no token class of `contract_id`.
	// Since: 0.46.0 (finschia)
	ModifyNFT(ctx context.Context, in *MsgModifyNFT, opts ...grpc.CallOption) (*MsgModifyNFTResponse, error)
	// Deprecated: use ModifyContract, ModifyTokenClass or ModifyNFT
	// Modify defines a method to modify metadata.
	Modify(ctx context.Context, in *MsgModify, opts ...grpc.CallOption) (*MsgModifyResponse, error)
	// Grant allows one to mint or burn tokens or modify metadata.
	// Fires:
	// - EventGrant
	// - grant_perm (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `granter` does not have `permission`.
	// - ErrInvalidRequest
	//   - `grantee` already has `permission`.
	// Since: 0.46.0 (finschia)
	Grant(ctx context.Context, in *MsgGrant, opts ...grpc.CallOption) (*MsgGrantResponse, error)
	// Abandon abandons a permission.
	// Fires:
	// - EventAbandon
	// - revoke_perm (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `grantee` does not have `permission`.
	// Since: 0.46.0 (finschia)
	Abandon(ctx context.Context, in *MsgAbandon, opts ...grpc.CallOption) (*MsgAbandonResponse, error)
	// Deprecated: use Grant
	// GrantPermission allows one to mint or burn tokens or modify metadata.
	GrantPermission(ctx context.Context, in *MsgGrantPermission, opts ...grpc.CallOption) (*MsgGrantPermissionResponse, error)
	// Deprecated: use Abandon
	// RevokePermission abandons a permission.
	RevokePermission(ctx context.Context, in *MsgRevokePermission, opts ...grpc.CallOption) (*MsgRevokePermissionResponse, error)
	// Attach defines a method to attach a token to another token.
	// Fires:
	// - EventAttach
	// - attach (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	// Throws:
	// - ErrInvalidRequest
	//   - `owner` does not owns `id`.
	//   - `owner` does not owns `to`.
	//   - `token_id` is not root.
	//   - `token_id` is an ancestor of `to_token_id`, which creates a cycle as a result.
	//   - depth of `to_token_id` exceeds an app-specific limit.
	Attach(ctx context.Context, in *MsgAttach, opts ...grpc.CallOption) (*MsgAttachResponse, error)
	// Detach defines a method to detach a token from another token.
	// Fires:
	// - EventDetach
	// - detach (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	// Throws:
	// - ErrInvalidRequest
	//   - `owner` does not owns `token_id`.
	Detach(ctx context.Context, in *MsgDetach, opts ...grpc.CallOption) (*MsgDetachResponse, error)
	// OperatorAttach defines a method to attach a token to another token by operator.
	// Fires:
	// - EventAttach
	// - attach_from (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - the holder has not authorized `operator`.
	// - ErrInvalidRequest
	//   - `owner` does not owns `subject`.
	//   - `owner` does not owns `target`.
	//   - `subject` is not root.
	//   - `subject` is an ancestor of `target`, which creates a cycle as a result.
	//   - depth of `to` exceeds an app-specific limit.
	// Since: 0.46.0 (finschia)
	OperatorAttach(ctx context.Context, in *MsgOperatorAttach, opts ...grpc.CallOption) (*MsgOperatorAttachResponse, error)
	// OperatorDetach defines a method to detach a token from another token by operator.
	// Fires:
	// - EventDetach
	// - detach_from (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - the holder has not authorized `operator`.
	// - ErrInvalidRequest
	//   - `owner` does not owns `subject`.
	// Since: 0.46.0 (finschia)
	OperatorDetach(ctx context.Context, in *MsgOperatorDetach, opts ...grpc.CallOption) (*MsgOperatorDetachResponse, error)
	// Deprecated: use OperatorAttach
	// AttachFrom defines a method to attach a token to another token by operator.
	AttachFrom(ctx context.Context, in *MsgAttachFrom, opts ...grpc.CallOption) (*MsgAttachFromResponse, error)
	// Deprecated: use OperatorDetach
	// DetachFrom defines a method to detach a token from another token by operator.
	DetachFrom(ctx context.Context, in *MsgDetachFrom, opts ...grpc.CallOption) (*MsgDetachFromResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Send(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error) {
	out := new(MsgSendResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/Send", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorSend(ctx context.Context, in *MsgOperatorSend, opts ...grpc.CallOption) (*MsgOperatorSendResponse, error) {
	out := new(MsgOperatorSendResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/OperatorSend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TransferFT(ctx context.Context, in *MsgTransferFT, opts ...grpc.CallOption) (*MsgTransferFTResponse, error) {
	out := new(MsgTransferFTResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/TransferFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TransferFTFrom(ctx context.Context, in *MsgTransferFTFrom, opts ...grpc.CallOption) (*MsgTransferFTFromResponse, error) {
	out := new(MsgTransferFTFromResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/TransferFTFrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TransferNFT(ctx context.Context, in *MsgTransferNFT, opts ...grpc.CallOption) (*MsgTransferNFTResponse, error) {
	out := new(MsgTransferNFTResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/TransferNFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TransferNFTFrom(ctx context.Context, in *MsgTransferNFTFrom, opts ...grpc.CallOption) (*MsgTransferNFTFromResponse, error) {
	out := new(MsgTransferNFTFromResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/TransferNFTFrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AuthorizeOperator(ctx context.Context, in *MsgAuthorizeOperator, opts ...grpc.CallOption) (*MsgAuthorizeOperatorResponse, error) {
	out := new(MsgAuthorizeOperatorResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/AuthorizeOperator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevokeOperator(ctx context.Context, in *MsgRevokeOperator, opts ...grpc.CallOption) (*MsgRevokeOperatorResponse, error) {
	out := new(MsgRevokeOperatorResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/RevokeOperator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Approve(ctx context.Context, in *MsgApprove, opts ...grpc.CallOption) (*MsgApproveResponse, error) {
	out := new(MsgApproveResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/Approve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Disapprove(ctx context.Context, in *MsgDisapprove, opts ...grpc.CallOption) (*MsgDisapproveResponse, error) {
	out := new(MsgDisapproveResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/Disapprove", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateContract(ctx context.Context, in *MsgCreateContract, opts ...grpc.CallOption) (*MsgCreateContractResponse, error) {
	out := new(MsgCreateContractResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/CreateContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateFTClass(ctx context.Context, in *MsgCreateFTClass, opts ...grpc.CallOption) (*MsgCreateFTClassResponse, error) {
	out := new(MsgCreateFTClassResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/CreateFTClass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateNFTClass(ctx context.Context, in *MsgCreateNFTClass, opts ...grpc.CallOption) (*MsgCreateNFTClassResponse, error) {
	out := new(MsgCreateNFTClassResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/CreateNFTClass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IssueFT(ctx context.Context, in *MsgIssueFT, opts ...grpc.CallOption) (*MsgIssueFTResponse, error) {
	out := new(MsgIssueFTResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/IssueFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IssueNFT(ctx context.Context, in *MsgIssueNFT, opts ...grpc.CallOption) (*MsgIssueNFTResponse, error) {
	out := new(MsgIssueNFTResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/IssueNFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintFT(ctx context.Context, in *MsgMintFT, opts ...grpc.CallOption) (*MsgMintFTResponse, error) {
	out := new(MsgMintFTResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/MintFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error) {
	out := new(MsgMintNFTResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/MintNFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Burn(ctx context.Context, in *MsgBurn, opts ...grpc.CallOption) (*MsgBurnResponse, error) {
	out := new(MsgBurnResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/Burn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorBurn(ctx context.Context, in *MsgOperatorBurn, opts ...grpc.CallOption) (*MsgOperatorBurnResponse, error) {
	out := new(MsgOperatorBurnResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/OperatorBurn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnFT(ctx context.Context, in *MsgBurnFT, opts ...grpc.CallOption) (*MsgBurnFTResponse, error) {
	out := new(MsgBurnFTResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/BurnFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnFTFrom(ctx context.Context, in *MsgBurnFTFrom, opts ...grpc.CallOption) (*MsgBurnFTFromResponse, error) {
	out := new(MsgBurnFTFromResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/BurnFTFrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error) {
	out := new(MsgBurnNFTResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/BurnNFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnNFTFrom(ctx context.Context, in *MsgBurnNFTFrom, opts ...grpc.CallOption) (*MsgBurnNFTFromResponse, error) {
	out := new(MsgBurnNFTFromResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/BurnNFTFrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ModifyContract(ctx context.Context, in *MsgModifyContract, opts ...grpc.CallOption) (*MsgModifyContractResponse, error) {
	out := new(MsgModifyContractResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/ModifyContract", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ModifyTokenClass(ctx context.Context, in *MsgModifyTokenClass, opts ...grpc.CallOption) (*MsgModifyTokenClassResponse, error) {
	out := new(MsgModifyTokenClassResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/ModifyTokenClass", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ModifyNFT(ctx context.Context, in *MsgModifyNFT, opts ...grpc.CallOption) (*MsgModifyNFTResponse, error) {
	out := new(MsgModifyNFTResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/ModifyNFT", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Modify(ctx context.Context, in *MsgModify, opts ...grpc.CallOption) (*MsgModifyResponse, error) {
	out := new(MsgModifyResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/Modify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Grant(ctx context.Context, in *MsgGrant, opts ...grpc.CallOption) (*MsgGrantResponse, error) {
	out := new(MsgGrantResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/Grant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Abandon(ctx context.Context, in *MsgAbandon, opts ...grpc.CallOption) (*MsgAbandonResponse, error) {
	out := new(MsgAbandonResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/Abandon", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) GrantPermission(ctx context.Context, in *MsgGrantPermission, opts ...grpc.CallOption) (*MsgGrantPermissionResponse, error) {
	out := new(MsgGrantPermissionResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/GrantPermission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevokePermission(ctx context.Context, in *MsgRevokePermission, opts ...grpc.CallOption) (*MsgRevokePermissionResponse, error) {
	out := new(MsgRevokePermissionResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/RevokePermission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Attach(ctx context.Context, in *MsgAttach, opts ...grpc.CallOption) (*MsgAttachResponse, error) {
	out := new(MsgAttachResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/Attach", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Detach(ctx context.Context, in *MsgDetach, opts ...grpc.CallOption) (*MsgDetachResponse, error) {
	out := new(MsgDetachResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/Detach", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorAttach(ctx context.Context, in *MsgOperatorAttach, opts ...grpc.CallOption) (*MsgOperatorAttachResponse, error) {
	out := new(MsgOperatorAttachResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/OperatorAttach", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorDetach(ctx context.Context, in *MsgOperatorDetach, opts ...grpc.CallOption) (*MsgOperatorDetachResponse, error) {
	out := new(MsgOperatorDetachResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/OperatorDetach", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AttachFrom(ctx context.Context, in *MsgAttachFrom, opts ...grpc.CallOption) (*MsgAttachFromResponse, error) {
	out := new(MsgAttachFromResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/AttachFrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DetachFrom(ctx context.Context, in *MsgDetachFrom, opts ...grpc.CallOption) (*MsgDetachFromResponse, error) {
	out := new(MsgDetachFromResponse)
	err := c.cc.Invoke(ctx, "/lbm.collection.v1.Msg/DetachFrom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Send defines a method to send tokens from one account to another account.
	// Fires:
	// - EventSent
	// - transfer_ft (deprecated, not typed)
	// - transfer_nft (deprecated, not typed)
	// - operation_transfer_nft (deprecated, not typed)
	// Throws:
	// - ErrInsufficientFunds:
	//   - the balance of `from` does not have enough tokens to spend.
	// Info: one can send both fungible tokens and non-fungible tokens.
	// Since: 0.46.0 (finschia)
	Send(context.Context, *MsgSend) (*MsgSendResponse, error)
	// OperatorSend defines a method to send tokens from one account to another account by the operator.
	// Fires:
	// - EventSent
	// - transfer_ft_from (deprecated, not typed)
	// - transfer_nft_from (deprecated, not typed)
	// - operation_transfer_nft (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized:
	//   - the holder has not authorized the operator.
	// - ErrInsufficientFunds:
	//   - the balance of `from` does not have enough tokens to spend.
	// Info: one can send both fungible tokens and non-fungible tokens.
	// Since: 0.46.0 (finschia)
	OperatorSend(context.Context, *MsgOperatorSend) (*MsgOperatorSendResponse, error)
	// Deprecated: use Send
	// TransferFT defines a method to send fungible tokens from one account to another account.
	TransferFT(context.Context, *MsgTransferFT) (*MsgTransferFTResponse, error)
	// Deprecated: use OperatorSend
	// TransferFTFrom defines a method to send fungible tokens from one account to another account by the operator.
	TransferFTFrom(context.Context, *MsgTransferFTFrom) (*MsgTransferFTFromResponse, error)
	// Deprecated: use Send
	// TransferNFT defines a method to send non-fungible tokens from one account to another account.
	TransferNFT(context.Context, *MsgTransferNFT) (*MsgTransferNFTResponse, error)
	// Deprecated: use OperatorSend
	// TransferNFTFrom defines a method to send non-fungible tokens from one account to another account by the operator.
	TransferNFTFrom(context.Context, *MsgTransferNFTFrom) (*MsgTransferNFTFromResponse, error)
	// AuthorizeOperator allows one to send tokens on behalf of the approver.
	// Fires:
	// - EventAuthorizedOperator
	// - approve_collection (deprecated, not typed)
	// Throws:
	// - ErrNotFound:
	//   - there is no contract of `contract_id`.
	// - ErrInvalidRequest:
	//   - `holder` has already authorized `operator`.
	// Since: 0.46.0 (finschia)
	AuthorizeOperator(context.Context, *MsgAuthorizeOperator) (*MsgAuthorizeOperatorResponse, error)
	// RevokeOperator revokes the authorization of the operator to send the approver's token.
	// Fires:
	// - EventRevokedOperator
	// - disapprove_collection (deprecated, not typed)
	// Throws:
	// - ErrNotFound:
	//   - there is no contract of `contract_id`.
	//   - there is no authorization by `holder` to `operator`.
	// Since: 0.46.0 (finschia)
	RevokeOperator(context.Context, *MsgRevokeOperator) (*MsgRevokeOperatorResponse, error)
	// Deprecated: use AuthorizeOperator
	// Approve allows one to send tokens on behalf of the approver.
	Approve(context.Context, *MsgApprove) (*MsgApproveResponse, error)
	// Deprecated: use RevokeOperator
	// Disapprove revokes the authorization of the operator to send the approver's token.
	Disapprove(context.Context, *MsgDisapprove) (*MsgDisapproveResponse, error)
	// CreateContract defines a method to create a contract for collection.
	// it grants `mint`, `burn`, `modify` and `issue` permissions on the contract to its creator.
	// Fires:
	// - EventCreatedContract
	// - create_collection (deprecated, not typed)
	CreateContract(context.Context, *MsgCreateContract) (*MsgCreateContractResponse, error)
	// CreateFTClass defines a method to create a class of fungible token.
	// one may set the supply on the creation, then no one can change the supply, which means no more mints and burns.
	// Fires:
	// - EventCreatedFTClass
	// - EventMintedFT
	// - issue_ft (deprecated, not typed)
	// Since: 0.46.0 (finschia)
	CreateFTClass(context.Context, *MsgCreateFTClass) (*MsgCreateFTClassResponse, error)
	// CreateNFTClass defines a method to create a class of non-fungible token.
	// Fires:
	// - EventCreatedNFTClass
	// - issue_nft (deprecated, not typed)
	// Since: 0.46.0 (finschia)
	CreateNFTClass(context.Context, *MsgCreateNFTClass) (*MsgCreateNFTClassResponse, error)
	// Deprecated: use CreateFTClass
	// IssueFT defines a method to create a class of fungible token.
	// Fires:
	// - EventIssueFT
	// - EventMintedFT
	// - issue_ft (deprecated, not typed)
	// Note: it does not grant any permissions to its issuer.
	IssueFT(context.Context, *MsgIssueFT) (*MsgIssueFTResponse, error)
	// Deprecated: use CreateNFTClass
	// IssueNFT defines a method to create a class of non-fungible token.
	// Fires:
	// - EventIssueNFT
	// - issue_nft (deprecated, not typed)
	// Note: it DOES grant `mint` and `burn` permissions to its issuer.
	IssueNFT(context.Context, *MsgIssueNFT) (*MsgIssueNFTResponse, error)
	// MintFT defines a method to mint fungible tokens.
	// Fires:
	// - EventMintedFT
	// - mint_ft (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `from` does not have `mint` permission.
	MintFT(context.Context, *MsgMintFT) (*MsgMintFTResponse, error)
	// MintNFT defines a method to mint non-fungible tokens.
	// Fires:
	// - EventMintedNFT
	// - mint_nft (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `from` does not have `mint` permission.
	MintNFT(context.Context, *MsgMintNFT) (*MsgMintNFTResponse, error)
	// Burn defines a method to burn tokens.
	// Fires:
	// - EventBurned
	// - burn_ft (deprecated, not typed)
	// - burn_nft (deprecated, not typed)
	// - operation_burn_nft (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `from` does not have `burn` permission.
	// - ErrInsufficientFunds:
	//   - the balance of `from` does not have enough tokens to burn.
	// Info: one can burn both fungible tokens and non-fungible tokens.
	// Since: 0.46.0 (finschia)
	Burn(context.Context, *MsgBurn) (*MsgBurnResponse, error)
	// OperatorBurn defines a method to burn tokens of the holder by the operator.
	// Fires:
	// - EventBurned
	// - burn_ft_from (deprecated, not typed)
	// - burn_nft_from (deprecated, not typed)
	// - operation_burn_nft (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `operator` does not have `burn` permission.
	//   - the holder has not authorized `operator`.
	// - ErrInsufficientFunds:
	//   - the balance of `from` does not have enough tokens to burn.
	// Info: one can burn both fungible tokens and non-fungible tokens.
	// Since: 0.46.0 (finschia)
	OperatorBurn(context.Context, *MsgOperatorBurn) (*MsgOperatorBurnResponse, error)
	// Deprecated: use Burn
	// BurnFT defines a method to burn fungible tokens.
	BurnFT(context.Context, *MsgBurnFT) (*MsgBurnFTResponse, error)
	// Deprecated: use OperatorBurn
	// BurnFTFrom defines a method to burn fungible tokens of the holder by the proxy.
	BurnFTFrom(context.Context, *MsgBurnFTFrom) (*MsgBurnFTFromResponse, error)
	// Deprecated: use Burn
	// BurnNFT defines a method to burn non-fungible tokens.
	BurnNFT(context.Context, *MsgBurnNFT) (*MsgBurnNFTResponse, error)
	// Deprecated: use OperatorBurn
	// BurnNFTFrom defines a method to burn non-fungible tokens of the holder by the proxy.
	BurnNFTFrom(context.Context, *MsgBurnNFTFrom) (*MsgBurnNFTFromResponse, error)
	// ModifyContract defines a method to modify the attributes of a contract.
	// Fires:
	// - EventModifiedContract
	// - modify_collection (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - the operator does not have `modify` permission.
	// - ErrNotFound
	//   - there is no token class of `contract_id`.
	// Since: 0.46.0 (finschia)
	ModifyContract(context.Context, *MsgModifyContract) (*MsgModifyContractResponse, error)
	// ModifyTokenClass defines a method to modify the attributes of a token class.
	// Fires:
	// - EventModifiedTokenClass
	// - modify_token_type (deprecated, not typed)
	// - modify_token (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - the operator does not have `modify` permission.
	// - ErrNotFound
	//   - there is no token class of `contract_id`.
	// Since: 0.46.0 (finschia)
	ModifyTokenClass(context.Context, *MsgModifyTokenClass) (*MsgModifyTokenClassResponse, error)
	// ModifyNFT defines a method to modify the attributes of a non-fungible token.
	// Fires:
	// - EventModifiedNFT
	// - modify_token (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - the operator does not have `modify` permission.
	// - ErrNotFound
	//   - there is no token class of `contract_id`.
	// Since: 0.46.0 (finschia)
	ModifyNFT(context.Context, *MsgModifyNFT) (*MsgModifyNFTResponse, error)
	// Deprecated: use ModifyContract, ModifyTokenClass or ModifyNFT
	// Modify defines a method to modify metadata.
	Modify(context.Context, *MsgModify) (*MsgModifyResponse, error)
	// Grant allows one to mint or burn tokens or modify metadata.
	// Fires:
	// - EventGrant
	// - grant_perm (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `granter` does not have `permission`.
	// - ErrInvalidRequest
	//   - `grantee` already has `permission`.
	// Since: 0.46.0 (finschia)
	Grant(context.Context, *MsgGrant) (*MsgGrantResponse, error)
	// Abandon abandons a permission.
	// Fires:
	// - EventAbandon
	// - revoke_perm (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - `grantee` does not have `permission`.
	// Since: 0.46.0 (finschia)
	Abandon(context.Context, *MsgAbandon) (*MsgAbandonResponse, error)
	// Deprecated: use Grant
	// GrantPermission allows one to mint or burn tokens or modify metadata.
	GrantPermission(context.Context, *MsgGrantPermission) (*MsgGrantPermissionResponse, error)
	// Deprecated: use Abandon
	// RevokePermission abandons a permission.
	RevokePermission(context.Context, *MsgRevokePermission) (*MsgRevokePermissionResponse, error)
	// Attach defines a method to attach a token to another token.
	// Fires:
	// - EventAttach
	// - attach (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	// Throws:
	// - ErrInvalidRequest
	//   - `owner` does not owns `id`.
	//   - `owner` does not owns `to`.
	//   - `token_id` is not root.
	//   - `token_id` is an ancestor of `to_token_id`, which creates a cycle as a result.
	//   - depth of `to_token_id` exceeds an app-specific limit.
	Attach(context.Context, *MsgAttach) (*MsgAttachResponse, error)
	// Detach defines a method to detach a token from another token.
	// Fires:
	// - EventDetach
	// - detach (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	// Throws:
	// - ErrInvalidRequest
	//   - `owner` does not owns `token_id`.
	Detach(context.Context, *MsgDetach) (*MsgDetachResponse, error)
	// OperatorAttach defines a method to attach a token to another token by operator.
	// Fires:
	// - EventAttach
	// - attach_from (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - the holder has not authorized `operator`.
	// - ErrInvalidRequest
	//   - `owner` does not owns `subject`.
	//   - `owner` does not owns `target`.
	//   - `subject` is not root.
	//   - `subject` is an ancestor of `target`, which creates a cycle as a result.
	//   - depth of `to` exceeds an app-specific limit.
	// Since: 0.46.0 (finschia)
	OperatorAttach(context.Context, *MsgOperatorAttach) (*MsgOperatorAttachResponse, error)
	// OperatorDetach defines a method to detach a token from another token by operator.
	// Fires:
	// - EventDetach
	// - detach_from (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	// Throws:
	// - ErrUnauthorized
	//   - the holder has not authorized `operator`.
	// - ErrInvalidRequest
	//   - `owner` does not owns `subject`.
	// Since: 0.46.0 (finschia)
	OperatorDetach(context.Context, *MsgOperatorDetach) (*MsgOperatorDetachResponse, error)
	// Deprecated: use OperatorAttach
	// AttachFrom defines a method to attach a token to another token by operator.
	AttachFrom(context.Context, *MsgAttachFrom) (*MsgAttachFromResponse, error)
	// Deprecated: use OperatorDetach
	// DetachFrom defines a method to detach a token from another token by operator.
	DetachFrom(context.Context, *MsgDetachFrom) (*MsgDetachFromResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Send(ctx context.Context, req *MsgSend) (*MsgSendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Send not implemented")
}
func (*UnimplementedMsgServer) OperatorSend(ctx context.Context, req *MsgOperatorSend) (*MsgOperatorSendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorSend not implemented")
}
func (*UnimplementedMsgServer) TransferFT(ctx context.Context, req *MsgTransferFT) (*MsgTransferFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferFT not implemented")
}
func (*UnimplementedMsgServer) TransferFTFrom(ctx context.Context, req *MsgTransferFTFrom) (*MsgTransferFTFromResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferFTFrom not implemented")
}
func (*UnimplementedMsgServer) TransferNFT(ctx context.Context, req *MsgTransferNFT) (*MsgTransferNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferNFT not implemented")
}
func (*UnimplementedMsgServer) TransferNFTFrom(ctx context.Context, req *MsgTransferNFTFrom) (*MsgTransferNFTFromResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferNFTFrom not implemented")
}
func (*UnimplementedMsgServer) AuthorizeOperator(ctx context.Context, req *MsgAuthorizeOperator) (*MsgAuthorizeOperatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthorizeOperator not implemented")
}
func (*UnimplementedMsgServer) RevokeOperator(ctx context.Context, req *MsgRevokeOperator) (*MsgRevokeOperatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeOperator not implemented")
}
func (*UnimplementedMsgServer) Approve(ctx context.Context, req *MsgApprove) (*MsgApproveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Approve not implemented")
}
func (*UnimplementedMsgServer) Disapprove(ctx context.Context, req *MsgDisapprove) (*MsgDisapproveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disapprove not implemented")
}
func (*UnimplementedMsgServer) CreateContract(ctx context.Context, req *MsgCreateContract) (*MsgCreateContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContract not implemented")
}
func (*UnimplementedMsgServer) CreateFTClass(ctx context.Context, req *MsgCreateFTClass) (*MsgCreateFTClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFTClass not implemented")
}
func (*UnimplementedMsgServer) CreateNFTClass(ctx context.Context, req *MsgCreateNFTClass) (*MsgCreateNFTClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNFTClass not implemented")
}
func (*UnimplementedMsgServer) IssueFT(ctx context.Context, req *MsgIssueFT) (*MsgIssueFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IssueFT not implemented")
}
func (*UnimplementedMsgServer) IssueNFT(ctx context.Context, req *MsgIssueNFT) (*MsgIssueNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IssueNFT not implemented")
}
func (*UnimplementedMsgServer) MintFT(ctx context.Context, req *MsgMintFT) (*MsgMintFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintFT not implemented")
}
func (*UnimplementedMsgServer) MintNFT(ctx context.Context, req *MsgMintNFT) (*MsgMintNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintNFT not implemented")
}
func (*UnimplementedMsgServer) Burn(ctx context.Context, req *MsgBurn) (*MsgBurnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Burn not implemented")
}
func (*UnimplementedMsgServer) OperatorBurn(ctx context.Context, req *MsgOperatorBurn) (*MsgOperatorBurnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorBurn not implemented")
}
func (*UnimplementedMsgServer) BurnFT(ctx context.Context, req *MsgBurnFT) (*MsgBurnFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnFT not implemented")
}
func (*UnimplementedMsgServer) BurnFTFrom(ctx context.Context, req *MsgBurnFTFrom) (*MsgBurnFTFromResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnFTFrom not implemented")
}
func (*UnimplementedMsgServer) BurnNFT(ctx context.Context, req *MsgBurnNFT) (*MsgBurnNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnNFT not implemented")
}
func (*UnimplementedMsgServer) BurnNFTFrom(ctx context.Context, req *MsgBurnNFTFrom) (*MsgBurnNFTFromResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnNFTFrom not implemented")
}
func (*UnimplementedMsgServer) ModifyContract(ctx context.Context, req *MsgModifyContract) (*MsgModifyContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyContract not implemented")
}
func (*UnimplementedMsgServer) ModifyTokenClass(ctx context.Context, req *MsgModifyTokenClass) (*MsgModifyTokenClassResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyTokenClass not implemented")
}
func (*UnimplementedMsgServer) ModifyNFT(ctx context.Context, req *MsgModifyNFT) (*MsgModifyNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyNFT not implemented")
}
func (*UnimplementedMsgServer) Modify(ctx context.Context, req *MsgModify) (*MsgModifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Modify not implemented")
}
func (*UnimplementedMsgServer) Grant(ctx context.Context, req *MsgGrant) (*MsgGrantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Grant not implemented")
}
func (*UnimplementedMsgServer) Abandon(ctx context.Context, req *MsgAbandon) (*MsgAbandonResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Abandon not implemented")
}
func (*UnimplementedMsgServer) GrantPermission(ctx context.Context, req *MsgGrantPermission) (*MsgGrantPermissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantPermission not implemented")
}
func (*UnimplementedMsgServer) RevokePermission(ctx context.Context, req *MsgRevokePermission) (*MsgRevokePermissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokePermission not implemented")
}
func (*UnimplementedMsgServer) Attach(ctx context.Context, req *MsgAttach) (*MsgAttachResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attach not implemented")
}
func (*UnimplementedMsgServer) Detach(ctx context.Context, req *MsgDetach) (*MsgDetachResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detach not implemented")
}
func (*UnimplementedMsgServer) OperatorAttach(ctx context.Context, req *MsgOperatorAttach) (*MsgOperatorAttachResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorAttach not implemented")
}
func (*UnimplementedMsgServer) OperatorDetach(ctx context.Context, req *MsgOperatorDetach) (*MsgOperatorDetachResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorDetach not implemented")
}
func (*UnimplementedMsgServer) AttachFrom(ctx context.Context, req *MsgAttachFrom) (*MsgAttachFromResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachFrom not implemented")
}
func (*UnimplementedMsgServer) DetachFrom(ctx context.Context, req *MsgDetachFrom) (*MsgDetachFromResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachFrom not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Send(ctx, req.(*MsgSend))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorSend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorSend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorSend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/OperatorSend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorSend(ctx, req.(*MsgOperatorSend))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TransferFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TransferFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/TransferFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TransferFT(ctx, req.(*MsgTransferFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TransferFTFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferFTFrom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TransferFTFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/TransferFTFrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TransferFTFrom(ctx, req.(*MsgTransferFTFrom))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TransferNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TransferNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/TransferNFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TransferNFT(ctx, req.(*MsgTransferNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TransferNFTFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferNFTFrom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TransferNFTFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/TransferNFTFrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TransferNFTFrom(ctx, req.(*MsgTransferNFTFrom))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AuthorizeOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAuthorizeOperator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AuthorizeOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/AuthorizeOperator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AuthorizeOperator(ctx, req.(*MsgAuthorizeOperator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevokeOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevokeOperator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevokeOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/RevokeOperator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevokeOperator(ctx, req.(*MsgRevokeOperator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Approve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgApprove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Approve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/Approve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Approve(ctx, req.(*MsgApprove))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Disapprove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDisapprove)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Disapprove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/Disapprove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Disapprove(ctx, req.(*MsgDisapprove))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/CreateContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateContract(ctx, req.(*MsgCreateContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateFTClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateFTClass)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateFTClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/CreateFTClass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateFTClass(ctx, req.(*MsgCreateFTClass))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateNFTClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateNFTClass)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateNFTClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/CreateNFTClass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateNFTClass(ctx, req.(*MsgCreateNFTClass))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IssueFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIssueFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IssueFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/IssueFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IssueFT(ctx, req.(*MsgIssueFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IssueNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIssueNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IssueNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/IssueNFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IssueNFT(ctx, req.(*MsgIssueNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/MintFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintFT(ctx, req.(*MsgMintFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/MintNFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintNFT(ctx, req.(*MsgMintNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Burn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Burn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/Burn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Burn(ctx, req.(*MsgBurn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorBurn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorBurn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorBurn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/OperatorBurn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorBurn(ctx, req.(*MsgOperatorBurn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/BurnFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnFT(ctx, req.(*MsgBurnFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnFTFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnFTFrom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnFTFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/BurnFTFrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnFTFrom(ctx, req.(*MsgBurnFTFrom))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/BurnNFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnNFT(ctx, req.(*MsgBurnNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnNFTFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnNFTFrom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnNFTFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/BurnNFTFrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnNFTFrom(ctx, req.(*MsgBurnNFTFrom))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ModifyContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgModifyContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ModifyContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/ModifyContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ModifyContract(ctx, req.(*MsgModifyContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ModifyTokenClass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgModifyTokenClass)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ModifyTokenClass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/ModifyTokenClass",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ModifyTokenClass(ctx, req.(*MsgModifyTokenClass))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ModifyNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgModifyNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ModifyNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/ModifyNFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ModifyNFT(ctx, req.(*MsgModifyNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Modify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgModify)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Modify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/Modify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Modify(ctx, req.(*MsgModify))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Grant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGrant)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Grant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/Grant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Grant(ctx, req.(*MsgGrant))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Abandon_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAbandon)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Abandon(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/Abandon",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Abandon(ctx, req.(*MsgAbandon))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_GrantPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGrantPermission)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).GrantPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/GrantPermission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).GrantPermission(ctx, req.(*MsgGrantPermission))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevokePermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevokePermission)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevokePermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/RevokePermission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevokePermission(ctx, req.(*MsgRevokePermission))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Attach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAttach)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Attach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/Attach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Attach(ctx, req.(*MsgAttach))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Detach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDetach)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Detach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/Detach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Detach(ctx, req.(*MsgDetach))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorAttach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorAttach)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorAttach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/OperatorAttach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorAttach(ctx, req.(*MsgOperatorAttach))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorDetach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorDetach)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorDetach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/OperatorDetach",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorDetach(ctx, req.(*MsgOperatorDetach))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AttachFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAttachFrom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AttachFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/AttachFrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AttachFrom(ctx, req.(*MsgAttachFrom))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DetachFrom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDetachFrom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DetachFrom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lbm.collection.v1.Msg/DetachFrom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DetachFrom(ctx, req.(*MsgDetachFrom))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "lbm.collection.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Send",
			Handler:    _Msg_Send_Handler,
		},
		{
			MethodName: "OperatorSend",
			Handler:    _Msg_OperatorSend_Handler,
		},
		{
			MethodName: "TransferFT",
			Handler:    _Msg_TransferFT_Handler,
		},
		{
			MethodName: "TransferFTFrom",
			Handler:    _Msg_TransferFTFrom_Handler,
		},
		{
			MethodName: "TransferNFT",
			Handler:    _Msg_TransferNFT_Handler,
		},
		{
			MethodName: "TransferNFTFrom",
			Handler:    _Msg_TransferNFTFrom_Handler,
		},
		{
			MethodName: "AuthorizeOperator",
			Handler:    _Msg_AuthorizeOperator_Handler,
		},
		{
			MethodName: "RevokeOperator",
			Handler:    _Msg_RevokeOperator_Handler,
		},
		{
			MethodName: "Approve",
			Handler:    _Msg_Approve_Handler,
		},
		{
			MethodName: "Disapprove",
			Handler:    _Msg_Disapprove_Handler,
		},
		{
			MethodName: "CreateContract",
			Handler:    _Msg_CreateContract_Handler,
		},
		{
			MethodName: "CreateFTClass",
			Handler:    _Msg_CreateFTClass_Handler,
		},
		{
			MethodName: "CreateNFTClass",
			Handler:    _Msg_CreateNFTClass_Handler,
		},
		{
			MethodName: "IssueFT",
			Handler:    _Msg_IssueFT_Handler,
		},
		{
			MethodName: "IssueNFT",
			Handler:    _Msg_IssueNFT_Handler,
		},
		{
			MethodName: "MintFT",
			Handler:    _Msg_MintFT_Handler,
		},
		{
			MethodName: "MintNFT",
			Handler:    _Msg_MintNFT_Handler,
		},
		{
			MethodName: "Burn",
			Handler:    _Msg_Burn_Handler,
		},
		{
			MethodName: "OperatorBurn",
			Handler:    _Msg_OperatorBurn_Handler,
		},
		{
			MethodName: "BurnFT",
			Handler:    _Msg_BurnFT_Handler,
		},
		{
			MethodName: "BurnFTFrom",
			Handler:    _Msg_BurnFTFrom_Handler,
		},
		{
			MethodName: "BurnNFT",
			Handler:    _Msg_BurnNFT_Handler,
		},
		{
			MethodName: "BurnNFTFrom",
			Handler:    _Msg_BurnNFTFrom_Handler,
		},
		{
			MethodName: "ModifyContract",
			Handler:    _Msg_ModifyContract_Handler,
		},
		{
			MethodName: "ModifyTokenClass",
			Handler:    _Msg_ModifyTokenClass_Handler,
		},
		{
			MethodName: "ModifyNFT",
			Handler:    _Msg_ModifyNFT_Handler,
		},
		{
			MethodName: "Modify",
			Handler:    _Msg_Modify_Handler,
		},
		{
			MethodName: "Grant",
			Handler:    _Msg_Grant_Handler,
		},
		{
			MethodName: "Abandon",
			Handler:    _Msg_Abandon_Handler,
		},
		{
			MethodName: "GrantPermission",
			Handler:    _Msg_GrantPermission_Handler,
		},
		{
			MethodName: "RevokePermission",
			Handler:    _Msg_RevokePermission_Handler,
		},
		{
			MethodName: "Attach",
			Handler:    _Msg_Attach_Handler,
		},
		{
			MethodName: "Detach",
			Handler:    _Msg_Detach_Handler,
		},
		{
			MethodName: "OperatorAttach",
			Handler:    _Msg_OperatorAttach_Handler,
		},
		{
			MethodName: "OperatorDetach",
			Handler:    _Msg_OperatorDetach_Handler,
		},
		{
			MethodName: "AttachFrom",
			Handler:    _Msg_AttachFrom_Handler,
		},
		{
			MethodName: "DetachFrom",
			Handler:    _Msg_DetachFrom_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lbm/collection/v1/tx.proto",
}

func (m *MsgSend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOperatorSend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOperatorSend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOperatorSend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOperatorSendResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOperatorSendResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOperatorSendResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgTransferFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgTransferFTFrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferFTFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferFTFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferFTFromResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferFTFromResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferFTFromResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgTransferNFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferNFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferNFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TokenIds[iNdEx])
			copy(dAtA[i:], m.TokenIds[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.TokenIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferNFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferNFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferNFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgTransferNFTFrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferNFTFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferNFTFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TokenIds[iNdEx])
			copy(dAtA[i:], m.TokenIds[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.TokenIds[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferNFTFromResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferNFTFromResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferNFTFromResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAuthorizeOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAuthorizeOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAuthorizeOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAuthorizeOperatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAuthorizeOperatorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAuthorizeOperatorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRevokeOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokeOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokeOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokeOperatorResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokeOperatorResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokeOperatorResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgApprove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgApprove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgApprove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Approver) > 0 {
		i -= len(m.Approver)
		copy(dAtA[i:], m.Approver)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Approver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgApproveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgApproveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgApproveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDisapprove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisapprove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisapprove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Approver) > 0 {
		i -= len(m.Approver)
		copy(dAtA[i:], m.Approver)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Approver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisapproveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisapproveResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisapproveResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Meta) > 0 {
		i -= len(m.Meta)
		copy(dAtA[i:], m.Meta)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Meta)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseImgUri) > 0 {
		i -= len(m.BaseImgUri)
		copy(dAtA[i:], m.BaseImgUri)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BaseImgUri)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateContractResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateContractResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateContractResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateFTClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateFTClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateFTClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Supply.Size()
		i -= size
		if _, err := m.Supply.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x32
	}
	if m.Decimals != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Meta) > 0 {
		i -= len(m.Meta)
		copy(dAtA[i:], m.Meta)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Meta)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateFTClassResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateFTClassResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateFTClassResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateNFTClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateNFTClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateNFTClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Meta) > 0 {
		i -= len(m.Meta)
		copy(dAtA[i:], m.Meta)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Meta)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateNFTClassResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateNFTClassResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateNFTClassResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgIssueFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIssueFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIssueFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x32
	}
	if m.Mintable {
		i--
		if m.Mintable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Decimals != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Meta) > 0 {
		i -= len(m.Meta)
		copy(dAtA[i:], m.Meta)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Meta)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgIssueFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIssueFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIssueFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgIssueNFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIssueNFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIssueNFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Meta) > 0 {
		i -= len(m.Meta)
		copy(dAtA[i:], m.Meta)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Meta)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgIssueNFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIssueNFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgIssueNFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgMintNFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintNFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintNFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Params) > 0 {
		for iNdEx := len(m.Params) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Params[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgMintNFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgMintNFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgMintNFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for iNdEx := len(m.Ids) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Ids[iNdEx])
			copy(dAtA[i:], m.Ids[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Ids[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MintNFTParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MintNFTParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MintNFTParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Meta) > 0 {
		i -= len(m.Meta)
		copy(dAtA[i:], m.Meta)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Meta)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TokenType) > 0 {
		i -= len(m.TokenType)
		copy(dAtA[i:], m.TokenType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOperatorBurn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOperatorBurn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOperatorBurn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOperatorBurnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOperatorBurnResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOperatorBurnResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBurnFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBurnFTFrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnFTFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnFTFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnFTFromResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnFTFromResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnFTFromResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBurnNFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnNFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnNFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TokenIds[iNdEx])
			copy(dAtA[i:], m.TokenIds[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.TokenIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnNFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnNFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnNFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgBurnNFTFrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnNFTFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnNFTFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenIds) > 0 {
		for iNdEx := len(m.TokenIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TokenIds[iNdEx])
			copy(dAtA[i:], m.TokenIds[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.TokenIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBurnNFTFromResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBurnNFTFromResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBurnNFTFromResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgModifyContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModifyContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgModifyContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgModifyContractResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModifyContractResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgModifyContractResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgModifyTokenClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModifyTokenClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgModifyTokenClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgModifyTokenClassResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModifyTokenClassResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgModifyTokenClassResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgModifyNFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModifyNFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgModifyNFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TokenId) > 0 {
		i -= len(m.TokenId)
		copy(dAtA[i:], m.TokenId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgModifyNFTResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModifyNFTResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgModifyNFTResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgModify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgModify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.TokenIndex) > 0 {
		i -= len(m.TokenIndex)
		copy(dAtA[i:], m.TokenIndex)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenIndex)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenType) > 0 {
		i -= len(m.TokenType)
		copy(dAtA[i:], m.TokenType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgModifyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModifyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgModifyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permission != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Permission))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Granter) > 0 {
		i -= len(m.Granter)
		copy(dAtA[i:], m.Granter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Granter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgGrantResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGrantResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGrantResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAbandon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAbandon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAbandon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permission != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Permission))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAbandonResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAbandonResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAbandonResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgGrantPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGrantPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGrantPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintTx(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgGrantPermissionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGrantPermissionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgGrantPermissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRevokePermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokePermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokePermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokePermissionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokePermissionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokePermissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAttach) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAttach) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAttach) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ToTokenId) > 0 {
		i -= len(m.ToTokenId)
		copy(dAtA[i:], m.ToTokenId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ToTokenId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TokenId) > 0 {
		i -= len(m.TokenId)
		copy(dAtA[i:], m.TokenId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAttachResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAttachResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAttachResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDetach) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDetach) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDetach) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenId) > 0 {
		i -= len(m.TokenId)
		copy(dAtA[i:], m.TokenId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDetachResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDetachResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDetachResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOperatorAttach) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOperatorAttach) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOperatorAttach) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOperatorAttachResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOperatorAttachResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOperatorAttachResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOperatorDetach) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOperatorDetach) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOperatorDetach) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOperatorDetachResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOperatorDetachResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOperatorDetachResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAttachFrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAttachFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAttachFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ToTokenId) > 0 {
		i -= len(m.ToTokenId)
		copy(dAtA[i:], m.ToTokenId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ToTokenId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TokenId) > 0 {
		i -= len(m.TokenId)
		copy(dAtA[i:], m.TokenId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAttachFromResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAttachFromResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAttachFromResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDetachFrom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDetachFrom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDetachFrom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokenId) > 0 {
		i -= len(m.TokenId)
		copy(dAtA[i:], m.TokenId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintTx(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDetachFromResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDetachFromResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDetachFromResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgSend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSendResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOperatorSend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgOperatorSendResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgTransferFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgTransferFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgTransferFTFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgTransferFTFromResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgTransferNFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.TokenIds) > 0 {
		for _, s := range m.TokenIds {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgTransferNFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgTransferNFTFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.TokenIds) > 0 {
		for _, s := range m.TokenIds {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgTransferNFTFromResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAuthorizeOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAuthorizeOperatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRevokeOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevokeOperatorResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgApprove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Approver)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgApproveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDisapprove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Approver)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDisapproveResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BaseImgUri)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Meta)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateContractResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateFTClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Meta)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovTx(uint64(m.Decimals))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Supply.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateFTClassResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateNFTClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Meta)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateNFTClassResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgIssueFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Meta)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovTx(uint64(m.Decimals))
	}
	if m.Mintable {
		n += 2
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgIssueFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgIssueNFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Meta)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgIssueNFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgMintFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgMintFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgMintNFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgMintNFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Ids) > 0 {
		for _, s := range m.Ids {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MintNFTParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Meta)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBurnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOperatorBurn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgOperatorBurnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBurnFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBurnFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBurnFTFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBurnFTFromResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBurnNFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.TokenIds) > 0 {
		for _, s := range m.TokenIds {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBurnNFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgBurnNFTFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.TokenIds) > 0 {
		for _, s := range m.TokenIds {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgBurnNFTFromResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgModifyContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgModifyContractResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgModifyTokenClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgModifyTokenClassResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgModifyNFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgModifyNFTResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgModify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenIndex)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgModifyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Granter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Permission != 0 {
		n += 1 + sovTx(uint64(m.Permission))
	}
	return n
}

func (m *MsgGrantResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAbandon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Permission != 0 {
		n += 1 + sovTx(uint64(m.Permission))
	}
	return n
}

func (m *MsgAbandonResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgGrantPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgGrantPermissionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRevokePermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevokePermissionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAttach) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ToTokenId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAttachResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDetach) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDetachResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOperatorAttach) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOperatorAttachResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOperatorDetach) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOperatorDetachResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAttachFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ToTokenId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAttachFromResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDetachFrom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TokenId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDetachFromResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgSend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOperatorSend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOperatorSend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOperatorSend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOperatorSendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOperatorSendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOperatorSendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferFTFrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferFTFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferFTFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferFTFromResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferFTFromResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferFTFromResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferNFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferNFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferNFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferNFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferNFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferNFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferNFTFrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferNFTFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferNFTFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferNFTFromResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferNFTFromResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferNFTFromResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAuthorizeOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAuthorizeOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAuthorizeOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAuthorizeOperatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAuthorizeOperatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAuthorizeOperatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokeOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokeOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokeOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokeOperatorResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokeOperatorResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokeOperatorResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgApprove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgApprove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgApprove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Approver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgApproveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgApproveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgApproveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisapprove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisapprove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisapprove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Approver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisapproveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisapproveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisapproveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseImgUri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseImgUri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meta = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateContractResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateContractResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateContractResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateFTClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateFTClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateFTClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meta = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Supply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Supply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateFTClassResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateFTClassResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateFTClassResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateNFTClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateNFTClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateNFTClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meta = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateNFTClassResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateNFTClassResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateNFTClassResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIssueFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIssueFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIssueFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meta = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mintable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mintable = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIssueFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIssueFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIssueFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIssueNFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIssueNFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIssueNFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meta = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIssueNFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIssueNFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIssueNFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintNFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintNFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintNFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, MintNFTParam{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgMintNFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgMintNFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgMintNFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MintNFTParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MintNFTParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MintNFTParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meta = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOperatorBurn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOperatorBurn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOperatorBurn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOperatorBurnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOperatorBurnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOperatorBurnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnFTFrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnFTFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnFTFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnFTFromResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnFTFromResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnFTFromResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnNFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnNFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnNFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnNFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnNFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnNFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnNFTFrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnNFTFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnNFTFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIds = append(m.TokenIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBurnNFTFromResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBurnNFTFromResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBurnNFTFromResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModifyContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModifyContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModifyContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, Attribute{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModifyContractResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModifyContractResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModifyContractResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModifyTokenClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModifyTokenClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModifyTokenClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, Attribute{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModifyTokenClassResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModifyTokenClassResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModifyTokenClassResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModifyNFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModifyNFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModifyNFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, Attribute{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModifyNFTResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModifyNFTResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModifyNFTResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIndex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIndex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, Change{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModifyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModifyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModifyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Granter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			m.Permission = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permission |= Permission(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGrantResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGrantResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGrantResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAbandon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAbandon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAbandon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			m.Permission = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permission |= Permission(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAbandonResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAbandonResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAbandonResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGrantPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGrantPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGrantPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGrantPermissionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGrantPermissionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGrantPermissionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokePermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokePermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokePermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokePermissionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokePermissionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokePermissionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAttach) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAttach: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAttach: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToTokenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAttachResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAttachResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAttachResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDetach) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDetach: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDetach: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDetachResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDetachResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDetachResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOperatorAttach) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOperatorAttach: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOperatorAttach: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOperatorAttachResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOperatorAttachResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOperatorAttachResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOperatorDetach) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOperatorDetach: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOperatorDetach: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOperatorDetachResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOperatorDetachResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOperatorDetachResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAttachFrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAttachFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAttachFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToTokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToTokenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAttachFromResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAttachFromResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAttachFromResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDetachFrom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDetachFrom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDetachFrom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDetachFromResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDetachFromResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDetachFromResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
