// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lbm/collection/v1/event.proto

package collection

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventType enumerates the valid event types on x/collection.
// For the legacy events.
type EventType int32

const (
	EventType_Unspecified          EventType = 0
	EventType_CreateCollection     EventType = 1
	EventType_IssueFT              EventType = 2
	EventType_IssueNFT             EventType = 3
	EventType_MintFT               EventType = 4
	EventType_BurnFT               EventType = 5
	EventType_MintNFT              EventType = 6
	EventType_BurnNFT              EventType = 7
	EventType_BurnFTFrom           EventType = 8
	EventType_BurnNFTFrom          EventType = 9
	EventType_ModifyCollection     EventType = 10
	EventType_ModifyTokenType      EventType = 11
	EventType_ModifyToken          EventType = 12
	EventType_Transfer             EventType = 13
	EventType_TransferFT           EventType = 14
	EventType_TransferNFT          EventType = 15
	EventType_TransferFTFrom       EventType = 16
	EventType_TransferNFTFrom      EventType = 17
	EventType_GrantPermToken       EventType = 18
	EventType_RevokePermToken      EventType = 19
	EventType_AttachToken          EventType = 20
	EventType_DetachToken          EventType = 21
	EventType_AttachFrom           EventType = 22
	EventType_DetachFrom           EventType = 23
	EventType_ApproveCollection    EventType = 24
	EventType_DisapproveCollection EventType = 25
	EventType_OperationTransferNFT EventType = 26
	EventType_OperationBurnNFT     EventType = 27
	EventType_OperationRootChanged EventType = 28
)

var EventType_name = map[int32]string{
	0:  "unspecified",
	1:  "create_collection",
	2:  "issue_ft",
	3:  "issue_nft",
	4:  "mint_ft",
	5:  "burn_ft",
	6:  "mint_nft",
	7:  "burn_nft",
	8:  "burn_ft_from",
	9:  "burn_nft_from",
	10: "modify_collection",
	11: "modify_token_type",
	12: "modify_token",
	13: "transfer",
	14: "transfer_ft",
	15: "transfer_nft",
	16: "transfer_ft_from",
	17: "transfer_nft_from",
	18: "grant_perm",
	19: "revoke_perm",
	20: "attach",
	21: "detach",
	22: "attach_from",
	23: "detach_from",
	24: "approve_collection",
	25: "disapprove_collection",
	26: "operation_transfer_nft",
	27: "operation_burn_nft",
	28: "operation_root_changed",
}

var EventType_value = map[string]int32{
	"unspecified":            0,
	"create_collection":      1,
	"issue_ft":               2,
	"issue_nft":              3,
	"mint_ft":                4,
	"burn_ft":                5,
	"mint_nft":               6,
	"burn_nft":               7,
	"burn_ft_from":           8,
	"burn_nft_from":          9,
	"modify_collection":      10,
	"modify_token_type":      11,
	"modify_token":           12,
	"transfer":               13,
	"transfer_ft":            14,
	"transfer_nft":           15,
	"transfer_ft_from":       16,
	"transfer_nft_from":      17,
	"grant_perm":             18,
	"revoke_perm":            19,
	"attach":                 20,
	"detach":                 21,
	"attach_from":            22,
	"detach_from":            23,
	"approve_collection":     24,
	"disapprove_collection":  25,
	"operation_transfer_nft": 26,
	"operation_burn_nft":     27,
	"operation_root_changed": 28,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{0}
}

// AttributeKey enumerates the valid attribute keys on x/collection.
// For the legacy events.
type AttributeKey int32

const (
	AttributeKey_Unspecified AttributeKey = 0
	AttributeKey_Name        AttributeKey = 1
	AttributeKey_Meta        AttributeKey = 2
	AttributeKey_ContractID  AttributeKey = 3
	AttributeKey_TokenID     AttributeKey = 4
	AttributeKey_Owner       AttributeKey = 5
	AttributeKey_Amount      AttributeKey = 6
	AttributeKey_Decimals    AttributeKey = 7
	AttributeKey_BaseImgURI  AttributeKey = 8
	AttributeKey_Mintable    AttributeKey = 9
	AttributeKey_TokenType   AttributeKey = 10
	AttributeKey_From        AttributeKey = 11
	AttributeKey_To          AttributeKey = 12
	AttributeKey_Perm        AttributeKey = 13
	AttributeKey_ToTokenID   AttributeKey = 14
	AttributeKey_FromTokenID AttributeKey = 15
	AttributeKey_Approver    AttributeKey = 16
	AttributeKey_Proxy       AttributeKey = 17
	AttributeKey_OldRoot     AttributeKey = 18
	AttributeKey_NewRoot     AttributeKey = 19
)

var AttributeKey_name = map[int32]string{
	0:  "unspecified",
	1:  "name",
	2:  "meta",
	3:  "contract_id",
	4:  "token_id",
	5:  "owner",
	6:  "amount",
	7:  "decimals",
	8:  "base_img_uri",
	9:  "mintable",
	10: "token_type",
	11: "from",
	12: "to",
	13: "perm",
	14: "to_token_id",
	15: "FromTokenID",
	16: "Approver",
	17: "Proxy",
	18: "old_root_token_id",
	19: "new_root_token_id",
}

var AttributeKey_value = map[string]int32{
	"unspecified":       0,
	"name":              1,
	"meta":              2,
	"contract_id":       3,
	"token_id":          4,
	"owner":             5,
	"amount":            6,
	"decimals":          7,
	"base_img_uri":      8,
	"mintable":          9,
	"token_type":        10,
	"from":              11,
	"to":                12,
	"perm":              13,
	"to_token_id":       14,
	"FromTokenID":       15,
	"Approver":          16,
	"Proxy":             17,
	"old_root_token_id": 18,
	"new_root_token_id": 19,
}

func (x AttributeKey) String() string {
	return proto.EnumName(AttributeKey_name, int32(x))
}

func (AttributeKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{1}
}

// EventSent is emitted on Msg/Send and Msg/OperatorSend.
// Since: finschia
type EventSent struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// address which the transfer is from.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// address which the transfer is to.
	To string `protobuf:"bytes,4,opt,name=to,proto3" json:"to,omitempty"`
	// amount of coins of the transfer.
	Amount []Coin `protobuf:"bytes,5,rep,name=amount,proto3" json:"amount"`
}

func (m *EventSent) Reset()         { *m = EventSent{} }
func (m *EventSent) String() string { return proto.CompactTextString(m) }
func (*EventSent) ProtoMessage()    {}
func (*EventSent) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{0}
}
func (m *EventSent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSent.Merge(m, src)
}
func (m *EventSent) XXX_Size() int {
	return m.Size()
}
func (m *EventSent) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSent.DiscardUnknown(m)
}

var xxx_messageInfo_EventSent proto.InternalMessageInfo

func (m *EventSent) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventSent) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventSent) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *EventSent) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *EventSent) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// EventAuthorizedOperator is emitted on Msg/AuthorizeOperator.
// Since: finschia
type EventAuthorizedOperator struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the token holder.
	Holder string `protobuf:"bytes,2,opt,name=holder,proto3" json:"holder,omitempty"`
	// address of the operator which the authorization is granted to.
	Operator string `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *EventAuthorizedOperator) Reset()         { *m = EventAuthorizedOperator{} }
func (m *EventAuthorizedOperator) String() string { return proto.CompactTextString(m) }
func (*EventAuthorizedOperator) ProtoMessage()    {}
func (*EventAuthorizedOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{1}
}
func (m *EventAuthorizedOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAuthorizedOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAuthorizedOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAuthorizedOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAuthorizedOperator.Merge(m, src)
}
func (m *EventAuthorizedOperator) XXX_Size() int {
	return m.Size()
}
func (m *EventAuthorizedOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAuthorizedOperator.DiscardUnknown(m)
}

var xxx_messageInfo_EventAuthorizedOperator proto.InternalMessageInfo

func (m *EventAuthorizedOperator) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventAuthorizedOperator) GetHolder() string {
	if m != nil {
		return m.Holder
	}
	return ""
}

func (m *EventAuthorizedOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// EventRevokedOperator is emitted on Msg/RevokeOperator.
// Since: finschia
type EventRevokedOperator struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the token holder of the authorization.
	Holder string `protobuf:"bytes,2,opt,name=holder,proto3" json:"holder,omitempty"`
	// address of the operator which the authorization is granted to.
	Operator string `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *EventRevokedOperator) Reset()         { *m = EventRevokedOperator{} }
func (m *EventRevokedOperator) String() string { return proto.CompactTextString(m) }
func (*EventRevokedOperator) ProtoMessage()    {}
func (*EventRevokedOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{2}
}
func (m *EventRevokedOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRevokedOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRevokedOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRevokedOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRevokedOperator.Merge(m, src)
}
func (m *EventRevokedOperator) XXX_Size() int {
	return m.Size()
}
func (m *EventRevokedOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRevokedOperator.DiscardUnknown(m)
}

var xxx_messageInfo_EventRevokedOperator proto.InternalMessageInfo

func (m *EventRevokedOperator) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventRevokedOperator) GetHolder() string {
	if m != nil {
		return m.Holder
	}
	return ""
}

func (m *EventRevokedOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// EventIssue is emitted on Msg/Issue.
// Since: finschia
type EventIssue struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// name defines the human-readable name of the token class.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// symbol is an abbreviated name for token class.
	Symbol string `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// uri for the resource of the token class stored off chain.
	Uri string `protobuf:"bytes,4,opt,name=uri,proto3" json:"uri,omitempty"`
	// meta is a brief description of token class.
	Meta string `protobuf:"bytes,5,opt,name=meta,proto3" json:"meta,omitempty"`
	// decimals is the number of decimals which one must divide the amount by to get its user representation.
	Decimals int32 `protobuf:"varint,6,opt,name=decimals,proto3" json:"decimals,omitempty"`
	// mintable represents whether the token is allowed to mint.
	Mintable bool `protobuf:"varint,7,opt,name=mintable,proto3" json:"mintable,omitempty"`
}

func (m *EventIssue) Reset()         { *m = EventIssue{} }
func (m *EventIssue) String() string { return proto.CompactTextString(m) }
func (*EventIssue) ProtoMessage()    {}
func (*EventIssue) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{3}
}
func (m *EventIssue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventIssue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventIssue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventIssue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventIssue.Merge(m, src)
}
func (m *EventIssue) XXX_Size() int {
	return m.Size()
}
func (m *EventIssue) XXX_DiscardUnknown() {
	xxx_messageInfo_EventIssue.DiscardUnknown(m)
}

var xxx_messageInfo_EventIssue proto.InternalMessageInfo

func (m *EventIssue) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventIssue) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EventIssue) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *EventIssue) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *EventIssue) GetMeta() string {
	if m != nil {
		return m.Meta
	}
	return ""
}

func (m *EventIssue) GetDecimals() int32 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *EventIssue) GetMintable() bool {
	if m != nil {
		return m.Mintable
	}
	return false
}

// EventGrant is emitted on Msg/Grant.
// Since: finschia
type EventGrant struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the granter.
	Granter string `protobuf:"bytes,2,opt,name=granter,proto3" json:"granter,omitempty"`
	// address of the grantee.
	Grantee string `protobuf:"bytes,3,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// permission on the contract.
	Permission string `protobuf:"bytes,4,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (m *EventGrant) Reset()         { *m = EventGrant{} }
func (m *EventGrant) String() string { return proto.CompactTextString(m) }
func (*EventGrant) ProtoMessage()    {}
func (*EventGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{4}
}
func (m *EventGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGrant.Merge(m, src)
}
func (m *EventGrant) XXX_Size() int {
	return m.Size()
}
func (m *EventGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGrant.DiscardUnknown(m)
}

var xxx_messageInfo_EventGrant proto.InternalMessageInfo

func (m *EventGrant) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventGrant) GetGranter() string {
	if m != nil {
		return m.Granter
	}
	return ""
}

func (m *EventGrant) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *EventGrant) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

// EventAbandon is emitted on Msg/Abandon.
// Since: finschia
type EventAbandon struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the grantee which abandons its grant.
	Grantee string `protobuf:"bytes,2,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// permission on the contract.
	Permission string `protobuf:"bytes,3,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (m *EventAbandon) Reset()         { *m = EventAbandon{} }
func (m *EventAbandon) String() string { return proto.CompactTextString(m) }
func (*EventAbandon) ProtoMessage()    {}
func (*EventAbandon) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{5}
}
func (m *EventAbandon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAbandon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAbandon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAbandon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAbandon.Merge(m, src)
}
func (m *EventAbandon) XXX_Size() int {
	return m.Size()
}
func (m *EventAbandon) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAbandon.DiscardUnknown(m)
}

var xxx_messageInfo_EventAbandon proto.InternalMessageInfo

func (m *EventAbandon) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventAbandon) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *EventAbandon) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

// EventMinted is emitted on Msg/MintFT and Msg/MintNFT.
// Since: finschia
type EventMinted struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// the address to send minted tokens to.
	To string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// the amount of minted tokens.
	Amount []Coin `protobuf:"bytes,4,rep,name=amount,proto3" json:"amount"`
}

func (m *EventMinted) Reset()         { *m = EventMinted{} }
func (m *EventMinted) String() string { return proto.CompactTextString(m) }
func (*EventMinted) ProtoMessage()    {}
func (*EventMinted) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{6}
}
func (m *EventMinted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMinted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMinted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMinted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMinted.Merge(m, src)
}
func (m *EventMinted) XXX_Size() int {
	return m.Size()
}
func (m *EventMinted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMinted.DiscardUnknown(m)
}

var xxx_messageInfo_EventMinted proto.InternalMessageInfo

func (m *EventMinted) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventMinted) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventMinted) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *EventMinted) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// EventBurned is emitted on Msg/Burn and Msg/OperatorBurn.
// Since: finschia
type EventBurned struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// address of the token holder.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// the amount of burnt token.
	Amount []Coin `protobuf:"bytes,4,rep,name=amount,proto3" json:"amount"`
}

func (m *EventBurned) Reset()         { *m = EventBurned{} }
func (m *EventBurned) String() string { return proto.CompactTextString(m) }
func (*EventBurned) ProtoMessage()    {}
func (*EventBurned) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{7}
}
func (m *EventBurned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBurned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBurned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBurned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBurned.Merge(m, src)
}
func (m *EventBurned) XXX_Size() int {
	return m.Size()
}
func (m *EventBurned) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBurned.DiscardUnknown(m)
}

var xxx_messageInfo_EventBurned proto.InternalMessageInfo

func (m *EventBurned) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventBurned) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventBurned) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *EventBurned) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// EventModified is emitted on Msg/Modify.
// Since: finschia
type EventModified struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the operator.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// changes on metadata.
	Changes []Pair `protobuf:"bytes,3,rep,name=changes,proto3" json:"changes"`
}

func (m *EventModified) Reset()         { *m = EventModified{} }
func (m *EventModified) String() string { return proto.CompactTextString(m) }
func (*EventModified) ProtoMessage()    {}
func (*EventModified) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{8}
}
func (m *EventModified) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventModified) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventModified.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventModified) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventModified.Merge(m, src)
}
func (m *EventModified) XXX_Size() int {
	return m.Size()
}
func (m *EventModified) XXX_DiscardUnknown() {
	xxx_messageInfo_EventModified.DiscardUnknown(m)
}

var xxx_messageInfo_EventModified proto.InternalMessageInfo

func (m *EventModified) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventModified) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventModified) GetChanges() []Pair {
	if m != nil {
		return m.Changes
	}
	return nil
}

// EventSpent is emitted on token spend.
// Since: finschia
type EventSpent struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	Spender    string `protobuf:"bytes,2,opt,name=spender,proto3" json:"spender,omitempty"`
	Amount     []Coin `protobuf:"bytes,3,rep,name=amount,proto3" json:"amount"`
}

func (m *EventSpent) Reset()         { *m = EventSpent{} }
func (m *EventSpent) String() string { return proto.CompactTextString(m) }
func (*EventSpent) ProtoMessage()    {}
func (*EventSpent) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{9}
}
func (m *EventSpent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSpent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSpent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSpent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSpent.Merge(m, src)
}
func (m *EventSpent) XXX_Size() int {
	return m.Size()
}
func (m *EventSpent) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSpent.DiscardUnknown(m)
}

var xxx_messageInfo_EventSpent proto.InternalMessageInfo

func (m *EventSpent) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventSpent) GetSpender() string {
	if m != nil {
		return m.Spender
	}
	return ""
}

func (m *EventSpent) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// EventReceived is emitted on token receipt.
// Since: finschia
type EventReceived struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	Receiver   string `protobuf:"bytes,2,opt,name=receiver,proto3" json:"receiver,omitempty"`
	Amount     []Coin `protobuf:"bytes,3,rep,name=amount,proto3" json:"amount"`
}

func (m *EventReceived) Reset()         { *m = EventReceived{} }
func (m *EventReceived) String() string { return proto.CompactTextString(m) }
func (*EventReceived) ProtoMessage()    {}
func (*EventReceived) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{10}
}
func (m *EventReceived) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventReceived) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventReceived.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventReceived) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventReceived.Merge(m, src)
}
func (m *EventReceived) XXX_Size() int {
	return m.Size()
}
func (m *EventReceived) XXX_DiscardUnknown() {
	xxx_messageInfo_EventReceived.DiscardUnknown(m)
}

var xxx_messageInfo_EventReceived proto.InternalMessageInfo

func (m *EventReceived) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventReceived) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

func (m *EventReceived) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

func init() {
	proto.RegisterEnum("lbm.collection.v1.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("lbm.collection.v1.AttributeKey", AttributeKey_name, AttributeKey_value)
	proto.RegisterType((*EventSent)(nil), "lbm.collection.v1.EventSent")
	proto.RegisterType((*EventAuthorizedOperator)(nil), "lbm.collection.v1.EventAuthorizedOperator")
	proto.RegisterType((*EventRevokedOperator)(nil), "lbm.collection.v1.EventRevokedOperator")
	proto.RegisterType((*EventIssue)(nil), "lbm.collection.v1.EventIssue")
	proto.RegisterType((*EventGrant)(nil), "lbm.collection.v1.EventGrant")
	proto.RegisterType((*EventAbandon)(nil), "lbm.collection.v1.EventAbandon")
	proto.RegisterType((*EventMinted)(nil), "lbm.collection.v1.EventMinted")
	proto.RegisterType((*EventBurned)(nil), "lbm.collection.v1.EventBurned")
	proto.RegisterType((*EventModified)(nil), "lbm.collection.v1.EventModified")
	proto.RegisterType((*EventSpent)(nil), "lbm.collection.v1.EventSpent")
	proto.RegisterType((*EventReceived)(nil), "lbm.collection.v1.EventReceived")
}

func init() { proto.RegisterFile("lbm/collection/v1/event.proto", fileDescriptor_478cfab12ea1b00e) }

var fileDescriptor_478cfab12ea1b00e = []byte{
	// 1285 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x3f, 0x6f, 0xdb, 0x46,
	0x14, 0x37, 0xad, 0xff, 0x8f, 0xb2, 0x73, 0x62, 0x9c, 0x58, 0x61, 0x1a, 0x99, 0x15, 0x32, 0x18,
	0x4e, 0x63, 0x21, 0x4d, 0x8b, 0x6e, 0x05, 0x1c, 0xbb, 0x2e, 0x8c, 0x22, 0x76, 0xa0, 0x28, 0x4b,
	0x17, 0x81, 0x12, 0xcf, 0x32, 0x61, 0xf1, 0x4e, 0x38, 0x9e, 0x94, 0xa8, 0x43, 0x81, 0xa2, 0xe8,
	0xc2, 0xa9, 0x1d, 0x3a, 0x72, 0xea, 0x07, 0xe8, 0xd6, 0x7e, 0x85, 0x8c, 0x19, 0x3b, 0x15, 0x45,
	0xf2, 0x45, 0x8a, 0xbb, 0x47, 0x52, 0x54, 0x92, 0x22, 0x4e, 0x8c, 0x6e, 0x7c, 0xf7, 0xfb, 0xbd,
	0xbf, 0xf7, 0xde, 0xd3, 0x09, 0x6e, 0x8d, 0x07, 0x41, 0x67, 0xc8, 0xc7, 0x63, 0x3a, 0x94, 0x3e,
	0x67, 0x9d, 0xd9, 0xbd, 0x0e, 0x9d, 0x51, 0x26, 0x77, 0x27, 0x82, 0x4b, 0x6e, 0x35, 0xc6, 0x83,
	0x60, 0x77, 0x01, 0xef, 0xce, 0xee, 0xd9, 0x1b, 0x23, 0x3e, 0xe2, 0x1a, 0xed, 0xa8, 0x2f, 0x24,
	0xda, 0xed, 0x37, 0xed, 0xe4, 0xd4, 0x34, 0xa7, 0xfd, 0x9b, 0x01, 0xb5, 0xaf, 0x94, 0xf1, 0xc7,
	0x94, 0x49, 0x6b, 0x0b, 0xcc, 0x21, 0x67, 0x52, 0xb8, 0x43, 0xd9, 0xf7, 0xbd, 0xa6, 0xe1, 0x18,
	0xdb, 0xb5, 0x2e, 0xa4, 0x47, 0x47, 0x9e, 0x65, 0x43, 0x95, 0x4f, 0xa8, 0x70, 0x25, 0x17, 0xcd,
	0x55, 0x8d, 0x66, 0xb2, 0x65, 0x41, 0xf1, 0x54, 0xf0, 0xa0, 0x59, 0xd0, 0xe7, 0xfa, 0xdb, 0x5a,
	0x87, 0x55, 0xc9, 0x9b, 0x45, 0x7d, 0xb2, 0x2a, 0xb9, 0xf5, 0x39, 0x94, 0xdd, 0x80, 0x4f, 0x99,
	0x6c, 0x96, 0x9c, 0xc2, 0xb6, 0xf9, 0xe9, 0xe6, 0xee, 0x1b, 0xc9, 0xec, 0xee, 0x73, 0x9f, 0x3d,
	0x28, 0x3e, 0xff, 0x7b, 0x6b, 0xa5, 0x9b, 0x90, 0xdb, 0x0c, 0x36, 0x75, 0x90, 0x7b, 0x53, 0x79,
	0xc6, 0x85, 0xff, 0x1d, 0xf5, 0x4e, 0x52, 0xaf, 0xef, 0x0c, 0xf9, 0x3a, 0x94, 0xcf, 0xf8, 0xd8,
	0xa3, 0x69, 0xc0, 0x89, 0xb4, 0x94, 0x4a, 0x61, 0x39, 0x95, 0xf6, 0x39, 0x6c, 0x68, 0x7f, 0x5d,
	0x3a, 0xe3, 0xe7, 0xff, 0xb7, 0xb3, 0x3f, 0x0d, 0x00, 0xed, 0xed, 0x28, 0x0c, 0xa7, 0xf4, 0xdd,
	0x3e, 0x2c, 0x28, 0x32, 0x37, 0xa0, 0x89, 0x07, 0xfd, 0xad, 0xfc, 0x86, 0xf3, 0x60, 0xc0, 0xc7,
	0x89, 0xf5, 0x44, 0xb2, 0x08, 0x14, 0xa6, 0xc2, 0x4f, 0x2e, 0x40, 0x7d, 0x2a, 0xed, 0x80, 0x4a,
	0xb7, 0x59, 0x42, 0x6d, 0xf5, 0xad, 0xa2, 0xf3, 0xe8, 0xd0, 0x0f, 0xdc, 0x71, 0xd8, 0x2c, 0x3b,
	0xc6, 0x76, 0xa9, 0x9b, 0xc9, 0x0a, 0x0b, 0x7c, 0x26, 0xdd, 0xc1, 0x98, 0x36, 0x2b, 0x8e, 0xb1,
	0x5d, 0xed, 0x66, 0x72, 0xfb, 0x87, 0x34, 0xf2, 0xaf, 0x85, 0x7b, 0x91, 0xee, 0x69, 0x42, 0x65,
	0xa4, 0x98, 0x59, 0x79, 0x52, 0x71, 0x81, 0xd0, 0x24, 0x81, 0x54, 0xb4, 0x5a, 0x00, 0x13, 0x2a,
	0x02, 0x3f, 0x0c, 0x7d, 0xce, 0x92, 0x44, 0x72, 0x27, 0x6d, 0x1f, 0xea, 0xd8, 0x1a, 0x03, 0x97,
	0x79, 0x9c, 0xbd, 0x47, 0x10, 0x74, 0x39, 0x88, 0xd7, 0x5d, 0x15, 0xde, 0x70, 0xf5, 0x8b, 0x01,
	0xa6, 0xf6, 0xf5, 0xd0, 0x67, 0x92, 0x7a, 0x97, 0x9b, 0x16, 0x9c, 0x8c, 0xc2, 0x5b, 0x26, 0xa3,
	0xf8, 0x3e, 0x93, 0xf1, 0x6b, 0x1a, 0xd3, 0x83, 0xa9, 0x60, 0x97, 0x8d, 0xe9, 0x6d, 0x13, 0xfc,
	0x81, 0x71, 0xfd, 0x64, 0xc0, 0x1a, 0xd6, 0x8a, 0x7b, 0xfe, 0xa9, 0x7f, 0xd9, 0xc8, 0xbe, 0x80,
	0xca, 0xf0, 0xcc, 0x65, 0x23, 0x1a, 0x36, 0x0b, 0xff, 0x19, 0xc6, 0x23, 0xd7, 0x17, 0x49, 0x18,
	0x29, 0xbb, 0xfd, 0x7d, 0xd2, 0xa1, 0x8f, 0x27, 0xf4, 0x82, 0x1d, 0x1a, 0x4e, 0x28, 0x5b, 0x0c,
	0x70, 0x2a, 0xe6, 0xea, 0x50, 0x78, 0x9f, 0x3a, 0xfc, 0x98, 0xd6, 0xa1, 0x4b, 0x87, 0xd4, 0x9f,
	0x5d, 0xb0, 0x0e, 0x02, 0xc9, 0x59, 0x1d, 0x52, 0xf9, 0x03, 0xa3, 0xd8, 0xf9, 0xa3, 0x9a, 0x6c,
	0xf9, 0xde, 0x7c, 0x42, 0x2d, 0x07, 0xcc, 0x29, 0x0b, 0x27, 0x74, 0xa8, 0x2f, 0x86, 0xac, 0xd8,
	0x57, 0xa2, 0xd8, 0x31, 0x9f, 0x2c, 0x8e, 0xac, 0x3b, 0xd0, 0x18, 0x0a, 0xea, 0x4a, 0xda, 0x5f,
	0x98, 0x26, 0x86, 0xbd, 0x11, 0xc5, 0x0e, 0xd9, 0xd7, 0xc0, 0x7e, 0x76, 0x6e, 0xdd, 0x80, 0xaa,
	0xaf, 0x36, 0x57, 0xff, 0x54, 0x92, 0x55, 0xdb, 0x8c, 0x62, 0xa7, 0xa2, 0x37, 0xd9, 0x61, 0xcf,
	0xba, 0x09, 0x35, 0x84, 0xd8, 0xa9, 0x24, 0x05, 0xbb, 0x1e, 0xc5, 0x4e, 0x55, 0x63, 0xc7, 0x87,
	0x3d, 0x6b, 0x13, 0x2a, 0x6a, 0x93, 0x28, 0xb5, 0xa2, 0x0d, 0x51, 0xec, 0x94, 0xd5, 0x5c, 0x21,
	0x30, 0x98, 0x0a, 0xa6, 0x80, 0x12, 0x02, 0xaa, 0xb9, 0x0f, 0x7b, 0xca, 0x93, 0xd6, 0x50, 0xd6,
	0xca, 0xe8, 0x49, 0xa9, 0x1c, 0x23, 0xa4, 0x75, 0x14, 0x54, 0x41, 0x48, 0x29, 0x29, 0xc8, 0x81,
	0x7a, 0x62, 0xae, 0xaf, 0x3a, 0x9a, 0x54, 0xed, 0xf5, 0x28, 0x76, 0x00, 0x6d, 0x1e, 0xaa, 0x1e,
	0x6f, 0xc3, 0x5a, 0xaa, 0x8c, 0x94, 0x1a, 0x96, 0x24, 0xb1, 0xa0, 0x39, 0x77, 0xa0, 0x11, 0xa8,
	0x56, 0x9e, 0xe7, 0x4b, 0x02, 0x58, 0x12, 0xdd, 0xe3, 0xf3, 0x5c, 0x49, 0x76, 0x32, 0xb2, 0xe4,
	0xe7, 0x94, 0xf5, 0xe5, 0x7c, 0x42, 0x89, 0x69, 0x5f, 0x8d, 0x62, 0xe7, 0x0a, 0x92, 0x7b, 0xea,
	0x5c, 0xdf, 0xc6, 0xc7, 0x50, 0xcf, 0x73, 0x49, 0x1d, 0x7d, 0xe7, 0x68, 0xaa, 0x23, 0xa4, 0x70,
	0x59, 0x78, 0x4a, 0x05, 0x59, 0xc3, 0x2a, 0xf6, 0x12, 0x59, 0xb5, 0x53, 0x8a, 0xa9, 0x82, 0xad,
	0x63, 0x72, 0x29, 0x7c, 0xd8, 0x53, 0xf6, 0x33, 0x82, 0xaa, 0xce, 0x15, 0xb4, 0x9f, 0x32, 0x54,
	0x85, 0xb6, 0x81, 0xe4, 0x6c, 0x60, 0x09, 0x88, 0x6d, 0x45, 0xb1, 0xb3, 0xbe, 0x30, 0xa4, 0xab,
	0xb0, 0x03, 0x8d, 0xbc, 0x31, 0xa4, 0x36, 0x30, 0xb1, 0x9c, 0xc5, 0xa4, 0xaa, 0xa0, 0x37, 0x6b,
	0x5f, 0xad, 0x50, 0x62, 0xa1, 0x3d, 0xfd, 0x4b, 0xf1, 0x88, 0x8a, 0x00, 0x33, 0xbb, 0x0d, 0xa6,
	0xd0, 0xbf, 0xb1, 0x48, 0xba, 0x8a, 0x96, 0xf0, 0x67, 0x77, 0xc1, 0xba, 0x09, 0x65, 0x57, 0x4a,
	0x77, 0x78, 0x46, 0x36, 0x30, 0xf8, 0x3d, 0x2d, 0x65, 0xa0, 0x47, 0x35, 0x78, 0x0d, 0xc1, 0x03,
	0xba, 0x00, 0xb7, 0xc0, 0x44, 0x4d, 0x8c, 0xf4, 0x3a, 0x56, 0x07, 0xd5, 0x75, 0x90, 0x5b, 0x60,
	0xa2, 0x36, 0x12, 0x36, 0x91, 0x80, 0x26, 0x34, 0xe1, 0x2e, 0x58, 0xee, 0x64, 0x22, 0xf8, 0x6c,
	0x69, 0x16, 0x9a, 0xf6, 0xb5, 0x28, 0x76, 0x1a, 0x7b, 0x88, 0xe4, 0x6e, 0xfe, 0x3e, 0x5c, 0xf3,
	0xfc, 0xf0, 0x2d, 0x1a, 0x37, 0xec, 0x66, 0x14, 0x3b, 0x1b, 0x07, 0x19, 0x98, 0x53, 0xfa, 0x0c,
	0xae, 0xe3, 0xa6, 0xf3, 0x39, 0xeb, 0x2f, 0x5d, 0x96, 0x8d, 0x5a, 0x27, 0x29, 0x9a, 0xbf, 0xb5,
	0x4f, 0xc0, 0x5a, 0x68, 0x65, 0xcd, 0x7f, 0x13, 0x5b, 0x32, 0xd3, 0x48, 0xa7, 0x60, 0xc9, 0x87,
	0xe0, 0x5c, 0xf6, 0x71, 0x45, 0x7a, 0xe4, 0xa3, 0xd7, 0x7c, 0x74, 0x39, 0x97, 0xfb, 0x88, 0xed,
	0xfc, 0x5e, 0x84, 0xfa, 0x9e, 0x94, 0xc2, 0x1f, 0x4c, 0x25, 0xfd, 0x86, 0xce, 0x2f, 0xb0, 0x3b,
	0x92, 0xe7, 0x09, 0x31, 0xec, 0x6a, 0x14, 0x3b, 0xc5, 0x63, 0xf5, 0x3c, 0x49, 0x1e, 0x1d, 0x64,
	0x15, 0xcf, 0x1e, 0xaa, 0x47, 0xc7, 0xf2, 0x1e, 0x24, 0x05, 0xac, 0xfc, 0x7e, 0xba, 0x07, 0x0f,
	0xd4, 0x48, 0xe3, 0xf4, 0xf8, 0x1e, 0x29, 0xe2, 0x48, 0xeb, 0x4b, 0x3d, 0x3a, 0xb0, 0x36, 0xa0,
	0xc4, 0x9f, 0x32, 0x2a, 0x48, 0xc9, 0xae, 0x45, 0xb1, 0x53, 0x3a, 0x51, 0x82, 0x7a, 0x04, 0xe1,
	0xbe, 0x23, 0x65, 0x5c, 0x1b, 0x7b, 0x5a, 0xca, 0x3f, 0x6f, 0x48, 0x05, 0xc7, 0xe7, 0x20, 0x7d,
	0xde, 0xa8, 0xe5, 0xe0, 0x86, 0xb4, 0xef, 0x07, 0xa3, 0xfe, 0x54, 0xf8, 0xd9, 0x72, 0x70, 0x43,
	0x7a, 0x14, 0x8c, 0x9e, 0x74, 0x8f, 0xf2, 0x0f, 0x20, 0x52, 0x43, 0xed, 0x87, 0x89, 0x6c, 0xdd,
	0x02, 0xc8, 0x0d, 0x38, 0xd8, 0x6b, 0x51, 0xec, 0xd4, 0x16, 0xa3, 0x9d, 0xfc, 0x9e, 0x12, 0x13,
	0xd3, 0x3e, 0xcc, 0x5e, 0xc4, 0xa4, 0x6e, 0x97, 0xa3, 0xd8, 0x59, 0xed, 0x71, 0xc5, 0xd1, 0xad,
	0xbf, 0x86, 0x1c, 0xd5, 0xf4, 0x56, 0x0b, 0x4c, 0xc9, 0xfb, 0x59, 0xf2, 0xeb, 0xa9, 0xdd, 0x34,
	0x7d, 0x07, 0x4c, 0x65, 0x2b, 0x11, 0xd3, 0x89, 0xce, 0x1d, 0xa9, 0xa0, 0x93, 0xde, 0x14, 0x84,
	0x60, 0xd0, 0xa9, 0xac, 0x8a, 0xf7, 0x48, 0xf0, 0x67, 0x73, 0xd2, 0xc0, 0xe2, 0x69, 0xc1, 0x6a,
	0x43, 0x83, 0x8f, 0x3d, 0xec, 0x8c, 0xcc, 0xb3, 0x85, 0x65, 0x3f, 0x19, 0x7b, 0xaa, 0x29, 0x14,
	0x87, 0xd1, 0xa7, 0xaf, 0x71, 0xae, 0x22, 0xe7, 0x98, 0x3e, 0x55, 0x9c, 0x07, 0x5f, 0x3e, 0x7f,
	0xd9, 0x32, 0x5e, 0xbc, 0x6c, 0x19, 0xff, 0xbc, 0x6c, 0x19, 0x3f, 0xbf, 0x6a, 0xad, 0xbc, 0x78,
	0xd5, 0x5a, 0xf9, 0xeb, 0x55, 0x6b, 0xe5, 0xdb, 0xdb, 0x23, 0x5f, 0x9e, 0x4d, 0x07, 0xbb, 0x43,
	0x1e, 0x74, 0xc6, 0x3e, 0xa3, 0x9d, 0xf1, 0x20, 0xb8, 0x1b, 0x7a, 0xe7, 0x9d, 0x67, 0xb9, 0xbf,
	0x25, 0x83, 0xb2, 0xfe, 0x5f, 0x72, 0xff, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5c, 0xa3, 0xb1,
	0xef, 0x05, 0x0d, 0x00, 0x00,
}

func (m *EventSent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAuthorizedOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAuthorizedOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAuthorizedOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventRevokedOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRevokedOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRevokedOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventIssue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventIssue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventIssue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mintable {
		i--
		if m.Mintable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Decimals != 0 {
		i = encodeVarintEvent(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Meta) > 0 {
		i -= len(m.Meta)
		copy(dAtA[i:], m.Meta)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Meta)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Granter) > 0 {
		i -= len(m.Granter)
		copy(dAtA[i:], m.Granter)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Granter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAbandon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAbandon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAbandon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMinted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMinted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMinted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBurned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBurned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBurned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventModified) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventModified) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventModified) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventSpent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSpent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSpent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Spender) > 0 {
		i -= len(m.Spender)
		copy(dAtA[i:], m.Spender)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Spender)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventReceived) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventReceived) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventReceived) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventSent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventAuthorizedOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventRevokedOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventIssue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Meta)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovEvent(uint64(m.Decimals))
	}
	if m.Mintable {
		n += 2
	}
	return n
}

func (m *EventGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Granter)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventAbandon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventMinted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventBurned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventModified) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventSpent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Spender)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventReceived) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func sovEvent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventSent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAuthorizedOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAuthorizedOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAuthorizedOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRevokedOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRevokedOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRevokedOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventIssue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventIssue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventIssue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Meta = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mintable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mintable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Granter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAbandon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAbandon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAbandon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMinted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMinted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMinted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBurned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBurned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBurned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventModified) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventModified: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventModified: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, Pair{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventSpent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSpent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSpent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventReceived) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventReceived: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventReceived: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvent = fmt.Errorf("proto: unexpected end of group")
)
