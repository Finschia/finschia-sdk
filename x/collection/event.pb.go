// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lbm/collection/v1/event.proto

package collection

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/line/lbm-sdk/codec/types"
	_ "github.com/regen-network/cosmos-proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventType enumerates the valid event types on x/collection.
// For the legacy events.
type EventType int32

const (
	EventType_Unspecified          EventType = 0
	EventType_CreateCollection     EventType = 1
	EventType_IssueFT              EventType = 2
	EventType_IssueNFT             EventType = 3
	EventType_MintFT               EventType = 4
	EventType_BurnFT               EventType = 5
	EventType_MintNFT              EventType = 6
	EventType_BurnNFT              EventType = 7
	EventType_BurnFTFrom           EventType = 8
	EventType_BurnNFTFrom          EventType = 9
	EventType_ModifyCollection     EventType = 10
	EventType_ModifyTokenType      EventType = 11
	EventType_ModifyToken          EventType = 12
	EventType_Transfer             EventType = 13
	EventType_TransferFT           EventType = 14
	EventType_TransferNFT          EventType = 15
	EventType_TransferFTFrom       EventType = 16
	EventType_TransferNFTFrom      EventType = 17
	EventType_GrantPermToken       EventType = 18
	EventType_RevokePermToken      EventType = 19
	EventType_AttachToken          EventType = 20
	EventType_DetachToken          EventType = 21
	EventType_AttachFrom           EventType = 22
	EventType_DetachFrom           EventType = 23
	EventType_ApproveCollection    EventType = 24
	EventType_DisapproveCollection EventType = 25
	EventType_OperationTransferNFT EventType = 26
	EventType_OperationBurnNFT     EventType = 27
	EventType_OperationRootChanged EventType = 28
)

var EventType_name = map[int32]string{
	0:  "unspecified",
	1:  "create_collection",
	2:  "issue_ft",
	3:  "issue_nft",
	4:  "mint_ft",
	5:  "burn_ft",
	6:  "mint_nft",
	7:  "burn_nft",
	8:  "burn_ft_from",
	9:  "burn_nft_from",
	10: "modify_collection",
	11: "modify_token_type",
	12: "modify_token",
	13: "transfer",
	14: "transfer_ft",
	15: "transfer_nft",
	16: "transfer_ft_from",
	17: "transfer_nft_from",
	18: "grant_perm",
	19: "revoke_perm",
	20: "attach",
	21: "detach",
	22: "attach_from",
	23: "detach_from",
	24: "approve_collection",
	25: "disapprove_collection",
	26: "operation_transfer_nft",
	27: "operation_burn_nft",
	28: "operation_root_changed",
}

var EventType_value = map[string]int32{
	"unspecified":            0,
	"create_collection":      1,
	"issue_ft":               2,
	"issue_nft":              3,
	"mint_ft":                4,
	"burn_ft":                5,
	"mint_nft":               6,
	"burn_nft":               7,
	"burn_ft_from":           8,
	"burn_nft_from":          9,
	"modify_collection":      10,
	"modify_token_type":      11,
	"modify_token":           12,
	"transfer":               13,
	"transfer_ft":            14,
	"transfer_nft":           15,
	"transfer_ft_from":       16,
	"transfer_nft_from":      17,
	"grant_perm":             18,
	"revoke_perm":            19,
	"attach":                 20,
	"detach":                 21,
	"attach_from":            22,
	"detach_from":            23,
	"approve_collection":     24,
	"disapprove_collection":  25,
	"operation_transfer_nft": 26,
	"operation_burn_nft":     27,
	"operation_root_changed": 28,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{0}
}

// AttributeKey enumerates the valid attribute keys on x/collection.
// For the legacy events.
type AttributeKey int32

const (
	AttributeKey_Unspecified AttributeKey = 0
	AttributeKey_Name        AttributeKey = 1
	AttributeKey_Meta        AttributeKey = 2
	AttributeKey_ContractID  AttributeKey = 3
	AttributeKey_TokenID     AttributeKey = 4
	AttributeKey_Owner       AttributeKey = 5
	AttributeKey_Amount      AttributeKey = 6
	AttributeKey_Decimals    AttributeKey = 7
	AttributeKey_BaseImgURI  AttributeKey = 8
	AttributeKey_Mintable    AttributeKey = 9
	AttributeKey_TokenType   AttributeKey = 10
	AttributeKey_From        AttributeKey = 11
	AttributeKey_To          AttributeKey = 12
	AttributeKey_Perm        AttributeKey = 13
	AttributeKey_ToTokenID   AttributeKey = 14
	AttributeKey_FromTokenID AttributeKey = 15
	AttributeKey_Approver    AttributeKey = 16
	AttributeKey_Proxy       AttributeKey = 17
	AttributeKey_OldRoot     AttributeKey = 18
	AttributeKey_NewRoot     AttributeKey = 19
)

var AttributeKey_name = map[int32]string{
	0:  "unspecified",
	1:  "name",
	2:  "meta",
	3:  "contract_id",
	4:  "token_id",
	5:  "owner",
	6:  "amount",
	7:  "decimals",
	8:  "base_img_uri",
	9:  "mintable",
	10: "token_type",
	11: "from",
	12: "to",
	13: "perm",
	14: "to_token_id",
	15: "FromTokenID",
	16: "Approver",
	17: "Proxy",
	18: "old_root_token_id",
	19: "new_root_token_id",
}

var AttributeKey_value = map[string]int32{
	"unspecified":       0,
	"name":              1,
	"meta":              2,
	"contract_id":       3,
	"token_id":          4,
	"owner":             5,
	"amount":            6,
	"decimals":          7,
	"base_img_uri":      8,
	"mintable":          9,
	"token_type":        10,
	"from":              11,
	"to":                12,
	"perm":              13,
	"to_token_id":       14,
	"FromTokenID":       15,
	"Approver":          16,
	"Proxy":             17,
	"old_root_token_id": 18,
	"new_root_token_id": 19,
}

func (x AttributeKey) String() string {
	return proto.EnumName(AttributeKey_name, int32(x))
}

func (AttributeKey) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{1}
}

// EventSent is emitted when tokens are transferred.
//
// Since: 0.46.0 (finschia)
type EventSent struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggered the send.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// holder whose tokens were sent.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// recipient of the tokens.
	To string `protobuf:"bytes,4,opt,name=to,proto3" json:"to,omitempty"`
	// amount of tokens sent.
	Amount []Coin `protobuf:"bytes,5,rep,name=amount,proto3" json:"amount"`
}

func (m *EventSent) Reset()         { *m = EventSent{} }
func (m *EventSent) String() string { return proto.CompactTextString(m) }
func (*EventSent) ProtoMessage()    {}
func (*EventSent) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{0}
}
func (m *EventSent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventSent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventSent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventSent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventSent.Merge(m, src)
}
func (m *EventSent) XXX_Size() int {
	return m.Size()
}
func (m *EventSent) XXX_DiscardUnknown() {
	xxx_messageInfo_EventSent.DiscardUnknown(m)
}

var xxx_messageInfo_EventSent proto.InternalMessageInfo

func (m *EventSent) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventSent) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventSent) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *EventSent) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *EventSent) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// EventAuthorizedOperator is emitted when a holder authorizes an operator to manipulate its tokens.
//
// Since: 0.46.0 (finschia)
type EventAuthorizedOperator struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of a holder which authorized the `operator` address as an operator.
	Holder string `protobuf:"bytes,2,opt,name=holder,proto3" json:"holder,omitempty"`
	// address which became an operator of `holder`.
	Operator string `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *EventAuthorizedOperator) Reset()         { *m = EventAuthorizedOperator{} }
func (m *EventAuthorizedOperator) String() string { return proto.CompactTextString(m) }
func (*EventAuthorizedOperator) ProtoMessage()    {}
func (*EventAuthorizedOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{1}
}
func (m *EventAuthorizedOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAuthorizedOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAuthorizedOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAuthorizedOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAuthorizedOperator.Merge(m, src)
}
func (m *EventAuthorizedOperator) XXX_Size() int {
	return m.Size()
}
func (m *EventAuthorizedOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAuthorizedOperator.DiscardUnknown(m)
}

var xxx_messageInfo_EventAuthorizedOperator proto.InternalMessageInfo

func (m *EventAuthorizedOperator) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventAuthorizedOperator) GetHolder() string {
	if m != nil {
		return m.Holder
	}
	return ""
}

func (m *EventAuthorizedOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// EventRevokedOperator is emitted when an authorization is revoked.
//
// Since: 0.46.0 (finschia)
type EventRevokedOperator struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of a holder which revoked the `operator` address as an operator.
	Holder string `protobuf:"bytes,2,opt,name=holder,proto3" json:"holder,omitempty"`
	// address which was revoked as an operator of `holder`.
	Operator string `protobuf:"bytes,3,opt,name=operator,proto3" json:"operator,omitempty"`
}

func (m *EventRevokedOperator) Reset()         { *m = EventRevokedOperator{} }
func (m *EventRevokedOperator) String() string { return proto.CompactTextString(m) }
func (*EventRevokedOperator) ProtoMessage()    {}
func (*EventRevokedOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{2}
}
func (m *EventRevokedOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRevokedOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRevokedOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRevokedOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRevokedOperator.Merge(m, src)
}
func (m *EventRevokedOperator) XXX_Size() int {
	return m.Size()
}
func (m *EventRevokedOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRevokedOperator.DiscardUnknown(m)
}

var xxx_messageInfo_EventRevokedOperator proto.InternalMessageInfo

func (m *EventRevokedOperator) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventRevokedOperator) GetHolder() string {
	if m != nil {
		return m.Holder
	}
	return ""
}

func (m *EventRevokedOperator) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

// EventCreatedTokenClass is emitted when a new token class is created.
//
// Since: 0.46.0 (finschia)
type EventCreatedTokenClass struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// class id associated with the token class.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// new token class.
	Class types.Any `protobuf:"bytes,3,opt,name=class,proto3" json:"class"`
}

func (m *EventCreatedTokenClass) Reset()         { *m = EventCreatedTokenClass{} }
func (m *EventCreatedTokenClass) String() string { return proto.CompactTextString(m) }
func (*EventCreatedTokenClass) ProtoMessage()    {}
func (*EventCreatedTokenClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{3}
}
func (m *EventCreatedTokenClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventCreatedTokenClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventCreatedTokenClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventCreatedTokenClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventCreatedTokenClass.Merge(m, src)
}
func (m *EventCreatedTokenClass) XXX_Size() int {
	return m.Size()
}
func (m *EventCreatedTokenClass) XXX_DiscardUnknown() {
	xxx_messageInfo_EventCreatedTokenClass.DiscardUnknown(m)
}

var xxx_messageInfo_EventCreatedTokenClass proto.InternalMessageInfo

func (m *EventCreatedTokenClass) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventCreatedTokenClass) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *EventCreatedTokenClass) GetClass() types.Any {
	if m != nil {
		return m.Class
	}
	return types.Any{}
}

// EventGrant is emitted when a granter grants its permission to a grantee.
//
// Since: 0.46.0 (finschia)
type EventGrant struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the granter which grants the permission.
	Granter string `protobuf:"bytes,2,opt,name=granter,proto3" json:"granter,omitempty"`
	// address of the grantee.
	Grantee string `protobuf:"bytes,3,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// permission on the contract.
	Permission string `protobuf:"bytes,4,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (m *EventGrant) Reset()         { *m = EventGrant{} }
func (m *EventGrant) String() string { return proto.CompactTextString(m) }
func (*EventGrant) ProtoMessage()    {}
func (*EventGrant) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{4}
}
func (m *EventGrant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventGrant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventGrant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventGrant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventGrant.Merge(m, src)
}
func (m *EventGrant) XXX_Size() int {
	return m.Size()
}
func (m *EventGrant) XXX_DiscardUnknown() {
	xxx_messageInfo_EventGrant.DiscardUnknown(m)
}

var xxx_messageInfo_EventGrant proto.InternalMessageInfo

func (m *EventGrant) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventGrant) GetGranter() string {
	if m != nil {
		return m.Granter
	}
	return ""
}

func (m *EventGrant) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *EventGrant) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

// EventAbandon is emitted when a grantee abandons its permission.
//
// Since: 0.46.0 (finschia)
type EventAbandon struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address of the grantee which abandons its grant.
	Grantee string `protobuf:"bytes,2,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// permission on the contract.
	Permission string `protobuf:"bytes,3,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (m *EventAbandon) Reset()         { *m = EventAbandon{} }
func (m *EventAbandon) String() string { return proto.CompactTextString(m) }
func (*EventAbandon) ProtoMessage()    {}
func (*EventAbandon) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{5}
}
func (m *EventAbandon) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAbandon) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAbandon.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAbandon) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAbandon.Merge(m, src)
}
func (m *EventAbandon) XXX_Size() int {
	return m.Size()
}
func (m *EventAbandon) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAbandon.DiscardUnknown(m)
}

var xxx_messageInfo_EventAbandon proto.InternalMessageInfo

func (m *EventAbandon) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventAbandon) GetGrantee() string {
	if m != nil {
		return m.Grantee
	}
	return ""
}

func (m *EventAbandon) GetPermission() string {
	if m != nil {
		return m.Permission
	}
	return ""
}

// EventMinted is emitted when tokens are minted.
//
// Since: 0.46.0 (finschia)
type EventMinted struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggered the mint.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// recipient of the tokens.
	To string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// amount of tokens minted.
	Amount Coin `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount"`
	// attributes of the token.
	Attributes []Attribute `protobuf:"bytes,5,rep,name=attributes,proto3" json:"attributes"`
}

func (m *EventMinted) Reset()         { *m = EventMinted{} }
func (m *EventMinted) String() string { return proto.CompactTextString(m) }
func (*EventMinted) ProtoMessage()    {}
func (*EventMinted) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{6}
}
func (m *EventMinted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMinted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMinted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMinted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMinted.Merge(m, src)
}
func (m *EventMinted) XXX_Size() int {
	return m.Size()
}
func (m *EventMinted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMinted.DiscardUnknown(m)
}

var xxx_messageInfo_EventMinted proto.InternalMessageInfo

func (m *EventMinted) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventMinted) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventMinted) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *EventMinted) GetAmount() Coin {
	if m != nil {
		return m.Amount
	}
	return Coin{}
}

func (m *EventMinted) GetAttributes() []Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// EventBurned is emitted when tokens are burnt.
//
// Since: 0.46.0 (finschia)
type EventBurned struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggered the burn.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// holder whose tokens were burned.
	From string `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// amount of tokens burned.
	Amount []Coin `protobuf:"bytes,4,rep,name=amount,proto3" json:"amount"`
}

func (m *EventBurned) Reset()         { *m = EventBurned{} }
func (m *EventBurned) String() string { return proto.CompactTextString(m) }
func (*EventBurned) ProtoMessage()    {}
func (*EventBurned) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{7}
}
func (m *EventBurned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventBurned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventBurned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventBurned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventBurned.Merge(m, src)
}
func (m *EventBurned) XXX_Size() int {
	return m.Size()
}
func (m *EventBurned) XXX_DiscardUnknown() {
	xxx_messageInfo_EventBurned.DiscardUnknown(m)
}

var xxx_messageInfo_EventBurned proto.InternalMessageInfo

func (m *EventBurned) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventBurned) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventBurned) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *EventBurned) GetAmount() []Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// EventModifiedContract is emitted when the information of a contract is modified.
//
// Since: 0.46.0 (finschia)
type EventModifiedContract struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggered the modify.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// changes of the attributes applied.
	Changes []Attribute `protobuf:"bytes,3,rep,name=changes,proto3" json:"changes"`
}

func (m *EventModifiedContract) Reset()         { *m = EventModifiedContract{} }
func (m *EventModifiedContract) String() string { return proto.CompactTextString(m) }
func (*EventModifiedContract) ProtoMessage()    {}
func (*EventModifiedContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{8}
}
func (m *EventModifiedContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventModifiedContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventModifiedContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventModifiedContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventModifiedContract.Merge(m, src)
}
func (m *EventModifiedContract) XXX_Size() int {
	return m.Size()
}
func (m *EventModifiedContract) XXX_DiscardUnknown() {
	xxx_messageInfo_EventModifiedContract.DiscardUnknown(m)
}

var xxx_messageInfo_EventModifiedContract proto.InternalMessageInfo

func (m *EventModifiedContract) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventModifiedContract) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventModifiedContract) GetChanges() []Attribute {
	if m != nil {
		return m.Changes
	}
	return nil
}

// EventModifiedTokenClass is emitted when the information of a token class is modified.
//
// Since: 0.46.0 (finschia)
type EventModifiedTokenClass struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggered the modify.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// class id associated with the token class.
	ClassId string `protobuf:"bytes,3,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// changes of the attributes applied.
	Changes []Attribute `protobuf:"bytes,4,rep,name=changes,proto3" json:"changes"`
}

func (m *EventModifiedTokenClass) Reset()         { *m = EventModifiedTokenClass{} }
func (m *EventModifiedTokenClass) String() string { return proto.CompactTextString(m) }
func (*EventModifiedTokenClass) ProtoMessage()    {}
func (*EventModifiedTokenClass) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{9}
}
func (m *EventModifiedTokenClass) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventModifiedTokenClass) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventModifiedTokenClass.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventModifiedTokenClass) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventModifiedTokenClass.Merge(m, src)
}
func (m *EventModifiedTokenClass) XXX_Size() int {
	return m.Size()
}
func (m *EventModifiedTokenClass) XXX_DiscardUnknown() {
	xxx_messageInfo_EventModifiedTokenClass.DiscardUnknown(m)
}

var xxx_messageInfo_EventModifiedTokenClass proto.InternalMessageInfo

func (m *EventModifiedTokenClass) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventModifiedTokenClass) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventModifiedTokenClass) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *EventModifiedTokenClass) GetChanges() []Attribute {
	if m != nil {
		return m.Changes
	}
	return nil
}

// EventModifiedNFT is emitted when the information of a non-fungible token is modified.
//
// Since: 0.46.0 (finschia)
type EventModifiedNFT struct {
	// contract id associated with the contract.
	ContractId string `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	// address which triggered the modify.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// token id associated with the non-fungible token.
	TokenId string `protobuf:"bytes,3,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	// changes of the attributes applied.
	Changes []Attribute `protobuf:"bytes,4,rep,name=changes,proto3" json:"changes"`
}

func (m *EventModifiedNFT) Reset()         { *m = EventModifiedNFT{} }
func (m *EventModifiedNFT) String() string { return proto.CompactTextString(m) }
func (*EventModifiedNFT) ProtoMessage()    {}
func (*EventModifiedNFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_478cfab12ea1b00e, []int{10}
}
func (m *EventModifiedNFT) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventModifiedNFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventModifiedNFT.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventModifiedNFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventModifiedNFT.Merge(m, src)
}
func (m *EventModifiedNFT) XXX_Size() int {
	return m.Size()
}
func (m *EventModifiedNFT) XXX_DiscardUnknown() {
	xxx_messageInfo_EventModifiedNFT.DiscardUnknown(m)
}

var xxx_messageInfo_EventModifiedNFT proto.InternalMessageInfo

func (m *EventModifiedNFT) GetContractId() string {
	if m != nil {
		return m.ContractId
	}
	return ""
}

func (m *EventModifiedNFT) GetOperator() string {
	if m != nil {
		return m.Operator
	}
	return ""
}

func (m *EventModifiedNFT) GetTokenId() string {
	if m != nil {
		return m.TokenId
	}
	return ""
}

func (m *EventModifiedNFT) GetChanges() []Attribute {
	if m != nil {
		return m.Changes
	}
	return nil
}

func init() {
	proto.RegisterEnum("lbm.collection.v1.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("lbm.collection.v1.AttributeKey", AttributeKey_name, AttributeKey_value)
	proto.RegisterType((*EventSent)(nil), "lbm.collection.v1.EventSent")
	proto.RegisterType((*EventAuthorizedOperator)(nil), "lbm.collection.v1.EventAuthorizedOperator")
	proto.RegisterType((*EventRevokedOperator)(nil), "lbm.collection.v1.EventRevokedOperator")
	proto.RegisterType((*EventCreatedTokenClass)(nil), "lbm.collection.v1.EventCreatedTokenClass")
	proto.RegisterType((*EventGrant)(nil), "lbm.collection.v1.EventGrant")
	proto.RegisterType((*EventAbandon)(nil), "lbm.collection.v1.EventAbandon")
	proto.RegisterType((*EventMinted)(nil), "lbm.collection.v1.EventMinted")
	proto.RegisterType((*EventBurned)(nil), "lbm.collection.v1.EventBurned")
	proto.RegisterType((*EventModifiedContract)(nil), "lbm.collection.v1.EventModifiedContract")
	proto.RegisterType((*EventModifiedTokenClass)(nil), "lbm.collection.v1.EventModifiedTokenClass")
	proto.RegisterType((*EventModifiedNFT)(nil), "lbm.collection.v1.EventModifiedNFT")
}

func init() { proto.RegisterFile("lbm/collection/v1/event.proto", fileDescriptor_478cfab12ea1b00e) }

var fileDescriptor_478cfab12ea1b00e = []byte{
	// 1332 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x3f, 0x6f, 0xdb, 0x56,
	0x10, 0x37, 0x25, 0x59, 0x96, 0x8e, 0xb2, 0xf3, 0xc4, 0xc8, 0xb6, 0xcc, 0x24, 0x32, 0x2b, 0x64,
	0x08, 0x9c, 0x46, 0x42, 0x92, 0x76, 0x2b, 0x02, 0xf8, 0x4f, 0x5d, 0x08, 0x45, 0xec, 0xc0, 0x55,
	0x96, 0x2e, 0x02, 0x25, 0x3e, 0xcb, 0x84, 0xc5, 0xf7, 0x04, 0xf2, 0xc9, 0x89, 0xba, 0x75, 0x2c,
	0xa7, 0xa2, 0x40, 0x47, 0x4e, 0x5d, 0xba, 0x65, 0x29, 0xfa, 0x19, 0x82, 0x4e, 0x59, 0x0a, 0x74,
	0x2a, 0x8a, 0xe4, 0x8b, 0x14, 0xef, 0x1d, 0x49, 0x51, 0xb6, 0xd1, 0xd8, 0x30, 0xba, 0xe9, 0xde,
	0xfd, 0xee, 0xee, 0x77, 0xf7, 0xee, 0xee, 0x51, 0x70, 0x6f, 0xd4, 0xf7, 0xda, 0x03, 0x3e, 0x1a,
	0xd1, 0x81, 0x70, 0x39, 0x6b, 0x9f, 0x3d, 0x6e, 0xd3, 0x33, 0xca, 0x44, 0x6b, 0xec, 0x73, 0xc1,
	0x8d, 0xea, 0xa8, 0xef, 0xb5, 0x66, 0xea, 0xd6, 0xd9, 0x63, 0x73, 0x63, 0xc8, 0xf9, 0x70, 0x44,
	0xdb, 0x0a, 0xd0, 0x9f, 0x1c, 0xb7, 0x6d, 0x36, 0x45, 0xb4, 0x59, 0x1b, 0xf2, 0x21, 0x57, 0x3f,
	0xdb, 0xf2, 0x57, 0x7c, 0xba, 0x31, 0xe0, 0x81, 0xc7, 0x83, 0x1e, 0x2a, 0x50, 0x88, 0x55, 0xcd,
	0x8b, 0xd1, 0x33, 0xc1, 0x14, 0xa6, 0xf9, 0x8b, 0x06, 0xe5, 0x2f, 0x25, 0xa5, 0x6f, 0x28, 0x13,
	0xc6, 0x26, 0xe8, 0x03, 0xce, 0x84, 0x6f, 0x0f, 0x44, 0xcf, 0x75, 0xea, 0x9a, 0xa5, 0x3d, 0x28,
	0x1f, 0x41, 0x72, 0xd4, 0x71, 0x0c, 0x13, 0x4a, 0x7c, 0x4c, 0x7d, 0x5b, 0x70, 0xbf, 0x9e, 0x53,
	0xda, 0x54, 0x36, 0x0c, 0x28, 0x1c, 0xfb, 0xdc, 0xab, 0xe7, 0xd5, 0xb9, 0xfa, 0x6d, 0xac, 0x40,
	0x4e, 0xf0, 0x7a, 0x41, 0x9d, 0xe4, 0x04, 0x37, 0x3e, 0x87, 0xa2, 0xed, 0xf1, 0x09, 0x13, 0xf5,
	0x45, 0x2b, 0xff, 0x40, 0x7f, 0xb2, 0xde, 0xba, 0x50, 0x82, 0xd6, 0x2e, 0x77, 0xd9, 0x4e, 0xe1,
	0xed, 0xdf, 0x9b, 0x0b, 0x47, 0x31, 0xb8, 0xc9, 0x60, 0x5d, 0x91, 0xdc, 0x9e, 0x88, 0x13, 0xee,
	0xbb, 0xdf, 0x51, 0xe7, 0x30, 0x89, 0xfa, 0x51, 0xca, 0x6b, 0x50, 0x3c, 0xe1, 0x23, 0x87, 0x26,
	0x84, 0x63, 0x69, 0x2e, 0x95, 0xfc, 0x7c, 0x2a, 0xcd, 0x53, 0xa8, 0xa9, 0x78, 0x47, 0xf4, 0x8c,
	0x9f, 0xfe, 0xdf, 0xc1, 0x7e, 0xd0, 0x60, 0x4d, 0x45, 0xdb, 0xf5, 0xa9, 0x2d, 0xa8, 0xd3, 0xe5,
	0xa7, 0x94, 0xed, 0x8e, 0xec, 0x20, 0xf8, 0x78, 0xbc, 0x15, 0xc8, 0xb9, 0x4e, 0x1c, 0x2b, 0xe7,
	0x3a, 0xc6, 0x33, 0x58, 0x1c, 0x48, 0x4b, 0x15, 0x44, 0x7f, 0x52, 0x6b, 0x61, 0x3b, 0xb5, 0x92,
	0x76, 0x6a, 0x6d, 0xb3, 0xe9, 0x8e, 0x21, 0x6b, 0xfb, 0xc7, 0x6f, 0x8f, 0x60, 0x16, 0xe9, 0x08,
	0xcd, 0x9a, 0xdf, 0x6b, 0x00, 0x8a, 0xcb, 0x57, 0xbe, 0x7d, 0x95, 0x7e, 0xa8, 0xc3, 0xd2, 0x50,
	0x22, 0xd3, 0x84, 0x13, 0x71, 0xa6, 0xa1, 0x71, 0xc2, 0x89, 0x68, 0x34, 0x00, 0xc6, 0xd4, 0xf7,
	0xdc, 0x20, 0x70, 0x39, 0x8b, 0x7b, 0x23, 0x73, 0xd2, 0x74, 0xa1, 0x82, 0x97, 0xdd, 0xb7, 0x99,
	0xc3, 0xd9, 0x35, 0x48, 0xd0, 0x79, 0x12, 0xe7, 0x43, 0xe5, 0x2f, 0x84, 0xfa, 0x53, 0x03, 0x5d,
	0xc5, 0x7a, 0xee, 0x32, 0x41, 0x9d, 0x9b, 0xf5, 0x3f, 0xf6, 0x7a, 0xfe, 0x92, 0x5e, 0x2f, 0xa8,
	0xcb, 0xb8, 0x5a, 0xaf, 0x1b, 0x3b, 0x00, 0xb6, 0x10, 0xbe, 0xdb, 0x9f, 0x08, 0x1a, 0xc4, 0x63,
	0x72, 0xf7, 0x12, 0xd3, 0xed, 0x04, 0x14, 0xdb, 0x67, 0xac, 0x9a, 0x3f, 0x27, 0x79, 0xed, 0x4c,
	0x7c, 0x76, 0xd3, 0xbc, 0x2e, 0x9b, 0xeb, 0x6c, 0x6e, 0xd7, 0x98, 0xe3, 0x9f, 0x34, 0x58, 0xc5,
	0x7a, 0x73, 0xc7, 0x3d, 0x76, 0xa9, 0xb3, 0x1b, 0x53, 0xb8, 0x19, 0xc3, 0x2f, 0x60, 0x69, 0x70,
	0x62, 0xb3, 0x21, 0x95, 0x7d, 0x7f, 0xd5, 0x7a, 0x25, 0x26, 0xcd, 0x37, 0x5a, 0xbc, 0x5d, 0x12,
	0x52, 0xd7, 0x19, 0xc0, 0xff, 0xa2, 0xb5, 0x01, 0x25, 0x35, 0x55, 0xd2, 0x32, 0x9e, 0x01, 0x25,
	0x77, 0x9c, 0x2c, 0xe3, 0xc2, 0xf5, 0x19, 0xff, 0xaa, 0x01, 0x99, 0x63, 0x7c, 0xb0, 0xdf, 0xbd,
	0x31, 0x55, 0x21, 0xb3, 0xce, 0x50, 0x55, 0xf2, 0x4d, 0xa9, 0x6e, 0xfd, 0x5e, 0x8a, 0xdf, 0x97,
	0xee, 0x74, 0x4c, 0x0d, 0x0b, 0xf4, 0x09, 0x0b, 0xc6, 0x74, 0xa0, 0x58, 0x93, 0x05, 0xf3, 0x56,
	0x18, 0x59, 0xfa, 0xcb, 0xd9, 0x91, 0xf1, 0x10, 0xaa, 0x03, 0xb5, 0x06, 0x7b, 0xb3, 0x00, 0x44,
	0x33, 0x6b, 0x61, 0x64, 0x11, 0xdc, 0x8f, 0xbb, 0xe9, 0xb9, 0x64, 0xed, 0x06, 0xc1, 0x84, 0xf6,
	0x8e, 0x05, 0xc9, 0x99, 0x7a, 0x18, 0x59, 0x4b, 0x1d, 0x29, 0xef, 0x77, 0x8d, 0x3b, 0x50, 0x46,
	0x15, 0x3b, 0x16, 0x24, 0x6f, 0x56, 0xc2, 0xc8, 0x2a, 0x29, 0x9d, 0x2c, 0xd5, 0x3a, 0x2c, 0x79,
	0x2e, 0x13, 0xd2, 0xac, 0x60, 0x42, 0x18, 0x59, 0x45, 0x39, 0xff, 0xa8, 0xe8, 0x4f, 0x7c, 0x26,
	0x15, 0x8b, 0xa8, 0x90, 0x03, 0xb4, 0xdf, 0x95, 0x91, 0x94, 0x85, 0xf4, 0x56, 0xc4, 0x48, 0xd2,
	0xe4, 0x00, 0x55, 0xca, 0x46, 0xaa, 0x96, 0x50, 0x25, 0x8d, 0xa4, 0xca, 0x82, 0x4a, 0xec, 0xae,
	0x27, 0xa7, 0x86, 0x94, 0xcc, 0x95, 0x30, 0xb2, 0x00, 0x7d, 0xee, 0xcb, 0x39, 0x6a, 0xc2, 0x72,
	0x62, 0x8c, 0x90, 0x32, 0x96, 0x24, 0xf6, 0xa0, 0x30, 0x0f, 0xa1, 0xea, 0xc9, 0x7b, 0x9e, 0x66,
	0x4b, 0x02, 0x58, 0x12, 0xd5, 0x00, 0xd3, 0x4c, 0x49, 0xb6, 0x52, 0x30, 0xde, 0xa7, 0x98, 0x8e,
	0x29, 0xd1, 0xcd, 0xdb, 0x61, 0x64, 0xdd, 0x42, 0xb0, 0xea, 0x6e, 0x75, 0x1b, 0x9f, 0x40, 0x25,
	0x8b, 0x25, 0x15, 0x8c, 0x9d, 0x81, 0xc9, 0x9e, 0x11, 0xbe, 0xcd, 0x82, 0x63, 0xea, 0x93, 0x65,
	0xac, 0x62, 0x37, 0x96, 0x65, 0xc3, 0x25, 0x3a, 0x59, 0xb0, 0x15, 0x4c, 0x2e, 0x51, 0xef, 0x77,
	0xa5, 0xff, 0x14, 0x20, 0xab, 0x73, 0x0b, 0xfd, 0x27, 0x08, 0x59, 0xa1, 0x07, 0x40, 0x32, 0x3e,
	0xb0, 0x04, 0xc4, 0x34, 0xc2, 0xc8, 0x5a, 0x99, 0x39, 0x52, 0x55, 0xd8, 0x82, 0x6a, 0xd6, 0x19,
	0x42, 0xab, 0x98, 0x58, 0xc6, 0x63, 0x5c, 0x55, 0x50, 0x2f, 0x40, 0x4f, 0xae, 0x7a, 0x62, 0xa0,
	0x3f, 0xf5, 0xa2, 0xbd, 0xa0, 0xbe, 0x87, 0x99, 0xdd, 0x07, 0xdd, 0x57, 0xaf, 0x3b, 0x82, 0x6e,
	0xa3, 0x27, 0x7c, 0xf0, 0x67, 0xa8, 0x3b, 0x50, 0xb4, 0x85, 0xb0, 0x07, 0x27, 0xa4, 0x86, 0xe4,
	0xb7, 0x95, 0x94, 0x2a, 0x1d, 0xaa, 0x94, 0xab, 0xa8, 0xdc, 0xa3, 0x33, 0xe5, 0x26, 0xe8, 0x68,
	0x89, 0x4c, 0xd7, 0xb0, 0x3a, 0x68, 0xae, 0x48, 0x6e, 0x82, 0x8e, 0xd6, 0x08, 0x58, 0x47, 0x00,
	0xba, 0x50, 0x80, 0x47, 0x60, 0xd8, 0xe3, 0xb1, 0xcf, 0xcf, 0xe6, 0x66, 0xa1, 0x6e, 0xae, 0x86,
	0x91, 0x55, 0xdd, 0x46, 0x4d, 0xe6, 0xe6, 0x9f, 0xc2, 0xaa, 0xe3, 0x06, 0x97, 0x58, 0x6c, 0x98,
	0xf5, 0x30, 0xb2, 0x6a, 0x7b, 0xa9, 0x32, 0x63, 0xf4, 0x19, 0xac, 0xe1, 0x0e, 0x70, 0x39, 0xeb,
	0xcd, 0x5d, 0x96, 0x89, 0x56, 0x87, 0x89, 0x36, 0x7b, 0x6b, 0x9f, 0x82, 0x31, 0xb3, 0x4a, 0x9b,
	0xff, 0x0e, 0xb6, 0x64, 0x6a, 0x91, 0x4c, 0xc1, 0x5c, 0x0c, 0x9f, 0x73, 0xd1, 0xc3, 0xe5, 0xe0,
	0x90, 0xbb, 0xe7, 0x62, 0x1c, 0x71, 0x2e, 0x76, 0x51, 0xb7, 0xf5, 0xa6, 0x00, 0x95, 0x74, 0xab,
	0x7c, 0x4d, 0xa7, 0x57, 0xd8, 0x1d, 0x06, 0x14, 0x98, 0xed, 0x51, 0xa2, 0x99, 0xa5, 0x30, 0xb2,
	0x0a, 0x07, 0xb6, 0x47, 0xe5, 0x99, 0x47, 0x85, 0x4d, 0x72, 0x78, 0xf6, 0x9c, 0x0a, 0xfb, 0xdc,
	0xa6, 0x24, 0x79, 0xac, 0x7c, 0xf2, 0x14, 0x75, 0xf6, 0xb2, 0xdb, 0x90, 0x14, 0x70, 0xa4, 0xd5,
	0xa5, 0x76, 0xf6, 0x8c, 0x1a, 0x2c, 0xf2, 0x57, 0x8c, 0xfa, 0x64, 0xd1, 0x2c, 0x87, 0x91, 0xb5,
	0x78, 0x28, 0x05, 0xf9, 0xd9, 0x87, 0x2f, 0x1c, 0x29, 0xe2, 0xda, 0xd8, 0xc6, 0xb7, 0xdc, 0x84,
	0x92, 0x43, 0x07, 0xae, 0x67, 0x8f, 0x02, 0xb2, 0x84, 0xe3, 0xb3, 0x17, 0xcb, 0x6a, 0x39, 0xd8,
	0x01, 0xed, 0xb9, 0xde, 0xb0, 0x37, 0xf1, 0xdd, 0x74, 0x39, 0xd8, 0x01, 0xed, 0x78, 0xc3, 0x97,
	0x47, 0x1d, 0x69, 0x2d, 0x97, 0x8e, 0xdd, 0x1f, 0x51, 0x52, 0x46, 0xeb, 0xe7, 0xb1, 0x6c, 0xdc,
	0x03, 0xc8, 0x0c, 0x38, 0x98, 0xcb, 0x61, 0x64, 0x95, 0x67, 0xa3, 0x1d, 0xbf, 0xd9, 0x44, 0xc7,
	0xb4, 0xf7, 0xd3, 0x6f, 0x71, 0x52, 0x31, 0x8b, 0x61, 0x64, 0xe5, 0xba, 0x5c, 0x62, 0x54, 0xeb,
	0x2f, 0x23, 0x46, 0x36, 0xbd, 0xd1, 0x00, 0x5d, 0xf0, 0x5e, 0x9a, 0xfc, 0x4a, 0xe2, 0x37, 0x49,
	0xdf, 0x02, 0x5d, 0xfa, 0x8a, 0xc5, 0x64, 0xa2, 0x33, 0x47, 0x92, 0x74, 0xdc, 0x9b, 0x3e, 0x21,
	0x48, 0x3a, 0x91, 0x65, 0xf1, 0x5e, 0xf8, 0xfc, 0xf5, 0x94, 0x54, 0xb1, 0x78, 0x4a, 0x30, 0x9a,
	0x50, 0xe5, 0x23, 0x07, 0x3b, 0x23, 0x8d, 0x6c, 0x60, 0xd9, 0x0f, 0x47, 0x8e, 0x6c, 0x0a, 0x89,
	0x61, 0xf4, 0xd5, 0x39, 0xcc, 0x6d, 0xc4, 0x1c, 0xd0, 0x57, 0x12, 0xb3, 0xf3, 0xec, 0xed, 0xfb,
	0x86, 0xf6, 0xee, 0x7d, 0x43, 0xfb, 0xe7, 0x7d, 0x43, 0xfb, 0xf1, 0x43, 0x63, 0xe1, 0xdd, 0x87,
	0xc6, 0xc2, 0x5f, 0x1f, 0x1a, 0x0b, 0xdf, 0xde, 0x1f, 0xba, 0xe2, 0x64, 0xd2, 0x6f, 0x0d, 0xb8,
	0xd7, 0x1e, 0xb9, 0x8c, 0xb6, 0x47, 0x7d, 0xef, 0x51, 0xe0, 0x9c, 0xb6, 0x5f, 0x67, 0xfe, 0x10,
	0xf5, 0x8b, 0xea, 0x23, 0xf9, 0xe9, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x62, 0xf0, 0x80, 0x7c,
	0xb5, 0x0d, 0x00, 0x00,
}

func (m *EventSent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventSent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventSent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAuthorizedOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAuthorizedOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAuthorizedOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventRevokedOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRevokedOperator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRevokedOperator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Holder) > 0 {
		i -= len(m.Holder)
		copy(dAtA[i:], m.Holder)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Holder)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventCreatedTokenClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventCreatedTokenClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventCreatedTokenClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Class.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventGrant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventGrant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventGrant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Granter) > 0 {
		i -= len(m.Granter)
		copy(dAtA[i:], m.Granter)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Granter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAbandon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAbandon) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAbandon) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Grantee) > 0 {
		i -= len(m.Grantee)
		copy(dAtA[i:], m.Grantee)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Grantee)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMinted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMinted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMinted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvent(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventBurned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventBurned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventBurned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventModifiedContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventModifiedContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventModifiedContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventModifiedTokenClass) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventModifiedTokenClass) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventModifiedTokenClass) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventModifiedNFT) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventModifiedNFT) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventModifiedNFT) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvent(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TokenId) > 0 {
		i -= len(m.TokenId)
		copy(dAtA[i:], m.TokenId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.TokenId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Operator) > 0 {
		i -= len(m.Operator)
		copy(dAtA[i:], m.Operator)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.Operator)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractId) > 0 {
		i -= len(m.ContractId)
		copy(dAtA[i:], m.ContractId)
		i = encodeVarintEvent(dAtA, i, uint64(len(m.ContractId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvent(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvent(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventSent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventAuthorizedOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventRevokedOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Holder)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventCreatedTokenClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.Class.Size()
	n += 1 + l + sovEvent(uint64(l))
	return n
}

func (m *EventGrant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Granter)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventAbandon) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Grantee)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	return n
}

func (m *EventMinted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovEvent(uint64(l))
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventBurned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventModifiedContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventModifiedTokenClass) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func (m *EventModifiedNFT) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	l = len(m.TokenId)
	if l > 0 {
		n += 1 + l + sovEvent(uint64(l))
	}
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovEvent(uint64(l))
		}
	}
	return n
}

func sovEvent(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvent(x uint64) (n int) {
	return sovEvent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventSent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventSent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventSent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAuthorizedOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAuthorizedOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAuthorizedOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRevokedOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRevokedOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRevokedOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Holder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Holder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventCreatedTokenClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventCreatedTokenClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventCreatedTokenClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Class", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Class.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventGrant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventGrant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventGrant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Granter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAbandon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAbandon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAbandon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMinted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMinted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMinted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, Attribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventBurned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventBurned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventBurned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventModifiedContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventModifiedContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventModifiedContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, Attribute{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventModifiedTokenClass) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventModifiedTokenClass: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventModifiedTokenClass: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, Attribute{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventModifiedNFT) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventModifiedNFT: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventModifiedNFT: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvent
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvent
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, Attribute{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvent(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvent(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvent
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvent
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvent
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvent        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvent          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvent = fmt.Errorf("proto: unexpected end of group")
)
