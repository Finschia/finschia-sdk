package mips

import (
	"crypto/sha256"
	"encoding/hex"
	"math/rand"
	"testing"
	"time"

	"github.com/Finschia/finschia-sdk/x/or/settlement/types"
	"github.com/stretchr/testify/require"
)

func TestStepWitnessMemory(t *testing.T) {
	statebytes, err := hex.DecodeString("0B87556AFA51677D1F4D377E608C48367190537A643CF619AD2DE5513A749A7D6433433D3F48974B10083D3FF6799E9D448B47406168FF2EE9DA2E1E2035101B0000004800011FB800011FBC5555600000000055243CC00000000000000000072BFA000000000000000000000FA3000000000000000540438040000000200000000000000000000000000000000100000000000000010000000000000020FFFFFFFF000000010000000000000001000000002438FFF8000CA07840424D6C0000000000000004000D8FC400000000000000000000032040424C80404000F000011F5C")
	require.NoError(t, err)
	state, err := types.DecodeState(statebytes)
	require.NoError(t, err)
	proofs, err := hex.DecodeString("8FA7002C8FA800308FA90034AFA80010AFA90014000018250000000C10E0000800000000AFBFFFE827BDFFE8AFBF00008FA2001C8FA400208FA500248FA60028BA0354642ADC7BC1BC81F7D6A2762BFC42E32011A3D5D577B774321EA10B1010914692F6421777A2B51EF3D4889956C7659CB7AC9C2877D62254CC5AA1639042417E071AC24843DA997409F127CC081262227F8F40D6F1A54654974FA707A429C790C747FD177EDF4931516606FCA4C5A2C0BDFAE1648A95949E5ADAC0B4DA8A21E9FCB8EC9919946DC2B10C81B3D55A7CD536486DCB16C6448E0CD8551F625DF923EB2573090BFB0CDA35CF68999DEECB00932950932646509D8ECC19D54FF88C1FEF53CF28FD6F25F5E2A696FA469FD174356FAACAA4999628F508F10C82316D445432B56A95CE6166845E0A70F380450051FC4737DCEA2AD72346CE9E1BA74B190AFDA4A6D3F01F1BB81515C5C00880C4598933054B6428711848E13F0C7BC9B9BEEF8C4F407920471E9015723392E76811965E8B29DFEECAE92FCBE38CA9F8B13A49E282F609C317A833FB8D976D11517C571D1221A265D25AF778ECF8920D722A5C9CD27774098FA2ED6F63740B740CCC30D2032D49310481422D88F59E2C2C4649BE0BFC9D0F386DBE6C7820A83BD9C829E99FF450649C42528BC6B8DA1DCBC355AA1DEA9D202E267913852F3C8A17936A5C37C5B755D24563936932000DB96ECF45CE5C3BC68CDA1497FB1531A5A2E83C5B13136FF3ECCB26006FBDBF2733E50F526EC2FA19A22B31E8ED50F23CD1FDF94C9154ED3A7609A2F1FF981FE1D3B5C807B281E4683CC6D6315CF95B9ADE8641DEFCB32372F1C126E398EF7A5A2DCE0A8A7F68BB74560F8F71837C2C2EBBCBF7FFFB42AE1896F13F7C7479A0B46A28B6F55540F89444F63DE0378E3D121BE09E06CC9DED1C20E65876D36AA0C65E9645644786B620E2DD2AD648DDFCBF4A7E5B1A3A4ECFE7F64667A3F0B7E2F4418588ED35A2458CFFEB39B93D26F18D2AB13BDCE6AEE58E7B99359EC2DFD95A9C16DC00D6EF18B7933A6F8DC65CCB55667138776F7DEA101070DC8796E3774DF84F40AE0C8229D0D6069E5C8F39A7C299677A09D367FC7B05E3BC380EE652C071F435789A51072894EF105B64991FD027E02EE71698912816079F06D50D508CC3FA344DEBB8B17CA1D02EAAEA559506657966E1FEBA18893CC7064345E3A4B8CD74046FF337F0A7BF2C8E03E10F642C1886798D71806AB1E888D9E5EE87D00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000038B5E116F44E8A3C406B4DE3E5EE367BFDB62BA0BE83BA430A91B7F9CA263D57B4C11951957C6F8F642C4AF61CD6B24640FEC6DC7FC607EE8206A99E92410D3021DDB9A356815C3FAC1026B6DEC5DF3124AFBADB485C9BA5A3E3398A04B7BA85E58769B32A1BEAF1EA27375A44095A0D1FB664CE2DD358E7FCBFB78C26A193440EB01EBFC9ED27500CD4DFC979272D1F0913CC9F66540D7E8005811109E1CF2D887C22BD8750D34016AC3C66B5FF102DACDD73F6B014E710B51E8022AF9A1968FFD70157E48063FC33C97A050F7F640233BF646CC98D9524C6B92BCF3AB56F839867CC5F7F196B93BAE1E27E6320742445D290F2263827498B54FEC539F756AFCEFAD4E508C098B9A7E1D8FEB19955FB02BA9675585078710969D3440F5054E03DE664EB1755D5344FA4BD1FAF9FF6C98CA7B8DB069EE01E78FFA1A43DA8A77332A8D7884817F747AC8B3E400A5BBEB2C1F5E25B6A015B8F0BF0A517DDE39E9065C2F060C67B57BCC67B9B834D452252BBA927A3BCC0DA11A22BF2FD38B15591C1DF82D9C4B87413EAE2EF048F94B4D3554CEA73D92B0F7AF96E0271C691E2BB5C67ADD7C6CAF302256ADEDF7AB114DA0ACFE870D449A3A489F781D659E8BECCDA7BCE9F4E8618B6BD2F4132CE798CDC7A60E7E1460A7299E3C6342A579626D22733E50F526EC2FA19A22B31E8ED50F23CD1FDF94C9154ED3A7609A2F1FF981FE1D3B5C807B281E4683CC6D6315CF95B9ADE8641DEFCB32372F1C126E398EF7A5A2DCE0A8A7F68BB74560F8F71837C2C2EBBCBF7FFFB42AE1896F13F7C7479A0B46A28B6F55540F89444F63DE0378E3D121BE09E06CC9DED1C20E65876D36AA0C65E9645644786B620E2DD2AD648DDFCBF4A7E5B1A3A4ECFE7F64667A3F0B7E2F4418588ED35A2458CFFEB39B93D26F18D2AB13BDCE6AEE58E7B99359EC2DFD95A9C16DC00D6EF18B7933A6F8DC65CCB55667138776F7DEA101070DC8796E3774DF84F40AE0C8229D0D6069E5C8F39A7C299677A09D367FC7B05E3BC380EE65216883EE87C1488BC3C88F4DC95CD8A293C5260E838A792894ADCF265A37CE99E7B913E817C282C39B6898CDA8EBFF953FA5EF360944CA473F1D6BA8A67490C82B8CD74046FF337F0A7BF2C8E03E10F642C1886798D71806AB1E888D9E5EE87D0")
	require.NoError(t, err)
	key, err := hex.DecodeString("6433433D3F48974B10083D3FF6799E9D448B47406168FF2EE9DA2E1E2035101B")
	require.NoError(t, err)
	val, err := hex.DecodeString("000000000000006054710D7FC08E1AAE43C7981A6B01692DE5856BBB3C41D4BD253099AE556C507924015B8C922747C864EF2C2835D340E25BE09979CAD65D5E53462ACCA78A9AFE3A6EB0790F39AC87C94F3856B2DD2C5D110E6811602261A9A923D3BB23ADC8B7")
	require.NoError(t, err)
	offset := uint32(72)

	witness := &types.Witness{
		State:          state,
		Proofs:         proofs,
		PreimageKey:    key,
		PreimageValue:  val,
		PreimageOffset: offset,
	}

	preStep := uint64(4700010)
	postStep := uint64(4700011)
	preState, err := hex.DecodeString("6C2FD13D20BB4F87E32B7864DB052632709D718656F812EEE355EDB5CD2D6D0F")
	require.NoError(t, err)
	postState, err := hex.DecodeString("AAB64A1E64EFF4DC96262BC877873D0FAF3DA02BB52391644BC2959DF32D6738")
	require.NoError(t, err)

	challenge := &types.Challenge{
		L: preStep,
		R: postStep,
		AssertedStateHashes: map[uint64][]byte{
			preStep:  preState,
			postStep: postState,
		},
	}

	stepedState, err := WitnessStep(witness, challenge)
	require.NoError(t, err)
	require.Equal(t, *(*[32]byte)(postState), sha256.Sum256(stepedState.EncodeWitness()))
}

// TODO: Use random not fixed value.
func TestWitnessMemorySet(t *testing.T) {
	s := rand.NewSource(time.Now().UnixNano())
	r := rand.New(s)

	m := NewMemory()
	for i := uint32(0x100000); i < 0x800000; i = i + 4 {
		m.SetMemory(i, r.Uint32())
	}
	addr := uint32(0x400000)
	proof := m.MerkleProof(addr)

	wm := WitnessMemory{
		initialRoot: m.MerkleRoot(),
		root:        m.MerkleRoot(),
		proofs: [2][MemProofSize]byte{
			{},
			proof,
		},
		pc: 0,
	}

	require.Equal(t, m.GetMemory(addr), wm.GetMemory(addr))

	val := r.Uint32()
	m.SetMemory(addr, val)
	wm.SetMemory(addr, val)

	require.NotEqual(t, m.MerkleRoot(), wm.initialRoot)
	require.Equal(t, m.MerkleRoot(), wm.root)
}
