// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: finschia/or/da/v1/da.proto

package types

import (
	fmt "fmt"
	github_com_Finschia_finschia_sdk_types "github.com/Finschia/finschia-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CompressionOption int32

const (
	// COMPRESSION_OPTION_UNSPECIFIED defines a no-op compress option.
	OptionEmpty CompressionOption = 0
	// Go standard library fo zlib compression (RFC 1950).
	OptionZLIB CompressionOption = 1
	// Zstandard is a fast compression algorithm, providing high compression ratios.
	// It also offers a special mode for small data, called dictionary compression.
	OptionZSTD CompressionOption = 2
)

var CompressionOption_name = map[int32]string{
	0: "COMPRESSION_OPTION_UNSPECIFIED",
	1: "COMPRESSION_OPTION_ZLIB",
	2: "COMPRESSION_OPTION_ZSTD",
}

var CompressionOption_value = map[string]int32{
	"COMPRESSION_OPTION_UNSPECIFIED": 0,
	"COMPRESSION_OPTION_ZLIB":        1,
	"COMPRESSION_OPTION_ZSTD":        2,
}

func (x CompressionOption) String() string {
	return proto.EnumName(CompressionOption_name, int32(x))
}

func (CompressionOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{0}
}

// BatchContext denotes a range of transactions that belong the same batch.
// It is used to compress shared fields that would otherwise be repeated for each transaction.
type CTCBatchContext struct {
	// num_sequenced_txs specifies the number of sequencer txs included in
	// the batch.
	NumSequencedTxs uint64 `protobuf:"varint,1,opt,name=num_sequenced_txs,json=numSequencedTxs,proto3" json:"num_sequenced_txs,omitempty"`
	// num_subsequent_queue_txs specifies the number of queued txs included in
	// the batch
	NumSubsequentQueueTxs uint64 `protobuf:"varint,2,opt,name=num_subsequent_queue_txs,json=numSubsequentQueueTxs,proto3" json:"num_subsequent_queue_txs,omitempty"`
	// timestamp is the L1 unix timestamp of the batch.
	L1Timestamp time.Time `protobuf:"bytes,3,opt,name=l1_timestamp,json=l1Timestamp,proto3,stdtime" json:"l1_timestamp"`
	// blockNumber is the L1 BlockNumber of the batch.
	L1Height uint64 `protobuf:"varint,4,opt,name=l1_height,json=l1Height,proto3" json:"l1_height,omitempty"`
}

func (m *CTCBatchContext) Reset()         { *m = CTCBatchContext{} }
func (m *CTCBatchContext) String() string { return proto.CompactTextString(m) }
func (*CTCBatchContext) ProtoMessage()    {}
func (*CTCBatchContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{0}
}
func (m *CTCBatchContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CTCBatchContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CTCBatchContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CTCBatchContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTCBatchContext.Merge(m, src)
}
func (m *CTCBatchContext) XXX_Size() int {
	return m.Size()
}
func (m *CTCBatchContext) XXX_DiscardUnknown() {
	xxx_messageInfo_CTCBatchContext.DiscardUnknown(m)
}

var xxx_messageInfo_CTCBatchContext proto.InternalMessageInfo

func (m *CTCBatchContext) GetNumSequencedTxs() uint64 {
	if m != nil {
		return m.NumSequencedTxs
	}
	return 0
}

func (m *CTCBatchContext) GetNumSubsequentQueueTxs() uint64 {
	if m != nil {
		return m.NumSubsequentQueueTxs
	}
	return 0
}

func (m *CTCBatchContext) GetL1Timestamp() time.Time {
	if m != nil {
		return m.L1Timestamp
	}
	return time.Time{}
}

func (m *CTCBatchContext) GetL1Height() uint64 {
	if m != nil {
		return m.L1Height
	}
	return 0
}

type CTCBatchElement struct {
	IsSequenced bool `protobuf:"varint,1,opt,name=is_sequenced,json=isSequenced,proto3" json:"is_sequenced,omitempty"`
	// timestamp is the L1 unix timestamp of the batch.
	// SEQUENCER TX ONLY
	L1Timestamp time.Time `protobuf:"bytes,2,opt,name=l1_timestamp,json=l1Timestamp,proto3,stdtime" json:"l1_timestamp"`
	// blockNumber is the L1 BlockNumber of the batch.
	// SEQUENCER TX ONLY
	L1Height uint64 `protobuf:"varint,3,opt,name=l1_height,json=l1Height,proto3" json:"l1_height,omitempty"`
	// SEQUENCER TX ONLY
	Txraw []byte `protobuf:"bytes,4,opt,name=txraw,proto3" json:"txraw,omitempty"`
	// QUEUED TX ONLY
	QueueIndex uint64 `protobuf:"varint,5,opt,name=queue_index,json=queueIndex,proto3" json:"queue_index,omitempty"`
	// l2_height is required when we reconstruct the L2 chain without relying on the L2 sequencer.
	L2Height uint64 `protobuf:"varint,6,opt,name=l2_height,json=l2Height,proto3" json:"l2_height,omitempty"`
}

func (m *CTCBatchElement) Reset()         { *m = CTCBatchElement{} }
func (m *CTCBatchElement) String() string { return proto.CompactTextString(m) }
func (*CTCBatchElement) ProtoMessage()    {}
func (*CTCBatchElement) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{1}
}
func (m *CTCBatchElement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CTCBatchElement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CTCBatchElement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CTCBatchElement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTCBatchElement.Merge(m, src)
}
func (m *CTCBatchElement) XXX_Size() int {
	return m.Size()
}
func (m *CTCBatchElement) XXX_DiscardUnknown() {
	xxx_messageInfo_CTCBatchElement.DiscardUnknown(m)
}

var xxx_messageInfo_CTCBatchElement proto.InternalMessageInfo

func (m *CTCBatchElement) GetIsSequenced() bool {
	if m != nil {
		return m.IsSequenced
	}
	return false
}

func (m *CTCBatchElement) GetL1Timestamp() time.Time {
	if m != nil {
		return m.L1Timestamp
	}
	return time.Time{}
}

func (m *CTCBatchElement) GetL1Height() uint64 {
	if m != nil {
		return m.L1Height
	}
	return 0
}

func (m *CTCBatchElement) GetTxraw() []byte {
	if m != nil {
		return m.Txraw
	}
	return nil
}

func (m *CTCBatchElement) GetQueueIndex() uint64 {
	if m != nil {
		return m.QueueIndex
	}
	return 0
}

func (m *CTCBatchElement) GetL2Height() uint64 {
	if m != nil {
		return m.L2Height
	}
	return 0
}

// Sequencer use CTCBatch when they submit.
type CTCBatch struct {
	// previous total batch elements.
	ShouldStartAtElement github_com_Finschia_finschia_sdk_types.Int `protobuf:"bytes,1,opt,name=should_start_at_element,json=shouldStartAtElement,proto3,customtype=github.com/Finschia/finschia-sdk/types.Int" json:"should_start_at_element"`
	BatchContexts        []*CTCBatchContext                         `protobuf:"bytes,2,rep,name=batch_contexts,json=batchContexts,proto3" json:"batch_contexts,omitempty"`
	Elements             []*CTCBatchElement                         `protobuf:"bytes,3,rep,name=elements,proto3" json:"elements,omitempty"`
}

func (m *CTCBatch) Reset()         { *m = CTCBatch{} }
func (m *CTCBatch) String() string { return proto.CompactTextString(m) }
func (*CTCBatch) ProtoMessage()    {}
func (*CTCBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{2}
}
func (m *CTCBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CTCBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CTCBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CTCBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTCBatch.Merge(m, src)
}
func (m *CTCBatch) XXX_Size() int {
	return m.Size()
}
func (m *CTCBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_CTCBatch.DiscardUnknown(m)
}

var xxx_messageInfo_CTCBatch proto.InternalMessageInfo

func (m *CTCBatch) GetBatchContexts() []*CTCBatchContext {
	if m != nil {
		return m.BatchContexts
	}
	return nil
}

func (m *CTCBatch) GetElements() []*CTCBatchElement {
	if m != nil {
		return m.Elements
	}
	return nil
}

// CTCRef is a data type that forms an element of Canonical Transaction Chain.
type CTCRef struct {
	// Reference for accessing batch data.
	Header *BatchHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
}

func (m *CTCRef) Reset()         { *m = CTCRef{} }
func (m *CTCRef) String() string { return proto.CompactTextString(m) }
func (*CTCRef) ProtoMessage()    {}
func (*CTCRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{3}
}
func (m *CTCRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CTCRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CTCRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CTCRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTCRef.Merge(m, src)
}
func (m *CTCRef) XXX_Size() int {
	return m.Size()
}
func (m *CTCRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CTCRef.DiscardUnknown(m)
}

var xxx_messageInfo_CTCRef proto.InternalMessageInfo

func (m *CTCRef) GetHeader() *BatchHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

// L1toL2Queue is a queued tx for L2 batch.
// Sequencer must process this transaction in time.
type L1ToL2Queue struct {
	// timestamp is the L1 unix timestamp of the batch.
	// It is set when the type of tx is L1toL2
	L1Timestamp time.Time `protobuf:"bytes,1,opt,name=l1_timestamp,json=l1Timestamp,proto3,stdtime" json:"l1_timestamp"`
	// blockNumber is the L1 BlockNumber of the batch.
	L1Height uint64 `protobuf:"varint,2,opt,name=l1_height,json=l1Height,proto3" json:"l1_height,omitempty"`
	Txraw    []byte `protobuf:"bytes,3,opt,name=txraw,proto3" json:"txraw,omitempty"`
}

func (m *L1ToL2Queue) Reset()         { *m = L1ToL2Queue{} }
func (m *L1ToL2Queue) String() string { return proto.CompactTextString(m) }
func (*L1ToL2Queue) ProtoMessage()    {}
func (*L1ToL2Queue) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{4}
}
func (m *L1ToL2Queue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L1ToL2Queue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L1ToL2Queue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L1ToL2Queue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L1ToL2Queue.Merge(m, src)
}
func (m *L1ToL2Queue) XXX_Size() int {
	return m.Size()
}
func (m *L1ToL2Queue) XXX_DiscardUnknown() {
	xxx_messageInfo_L1ToL2Queue.DiscardUnknown(m)
}

var xxx_messageInfo_L1ToL2Queue proto.InternalMessageInfo

func (m *L1ToL2Queue) GetL1Timestamp() time.Time {
	if m != nil {
		return m.L1Timestamp
	}
	return time.Time{}
}

func (m *L1ToL2Queue) GetL1Height() uint64 {
	if m != nil {
		return m.L1Height
	}
	return 0
}

func (m *L1ToL2Queue) GetTxraw() []byte {
	if m != nil {
		return m.Txraw
	}
	return nil
}

// Proposer use SCCBatch when they submit.
type SCCBatch struct {
	// previous total batch elements.
	ShouldStartAtElement github_com_Finschia_finschia_sdk_types.Int `protobuf:"bytes,1,opt,name=should_start_at_element,json=shouldStartAtElement,proto3,customtype=github.com/Finschia/finschia-sdk/types.Int" json:"should_start_at_element"`
	// IntermediateStateRoots for a specific range of CTCs.
	IntermediateStateRoots [][]byte `protobuf:"bytes,2,rep,name=IntermediateStateRoots,proto3" json:"IntermediateStateRoots,omitempty"`
}

func (m *SCCBatch) Reset()         { *m = SCCBatch{} }
func (m *SCCBatch) String() string { return proto.CompactTextString(m) }
func (*SCCBatch) ProtoMessage()    {}
func (*SCCBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{5}
}
func (m *SCCBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCCBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCCBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCCBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCCBatch.Merge(m, src)
}
func (m *SCCBatch) XXX_Size() int {
	return m.Size()
}
func (m *SCCBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_SCCBatch.DiscardUnknown(m)
}

var xxx_messageInfo_SCCBatch proto.InternalMessageInfo

func (m *SCCBatch) GetIntermediateStateRoots() [][]byte {
	if m != nil {
		return m.IntermediateStateRoots
	}
	return nil
}

// CTCRef is a data type that forms an element of Canonical Transaction Chain.
type SCCRef struct {
	// Reference for accessing batch data.
	Header *BatchHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
}

func (m *SCCRef) Reset()         { *m = SCCRef{} }
func (m *SCCRef) String() string { return proto.CompactTextString(m) }
func (*SCCRef) ProtoMessage()    {}
func (*SCCRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{6}
}
func (m *SCCRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCCRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCCRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCCRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCCRef.Merge(m, src)
}
func (m *SCCRef) XXX_Size() int {
	return m.Size()
}
func (m *SCCRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SCCRef.DiscardUnknown(m)
}

var xxx_messageInfo_SCCRef proto.InternalMessageInfo

func (m *SCCRef) GetHeader() *BatchHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type BatchHeader struct {
	// Reference for accessing batch data.
	TxHash []byte `protobuf:"bytes,1,opt,name=txhash,proto3" json:"txhash,omitempty"`
	// Total number of elements submitted.
	TotalElements github_com_Finschia_finschia_sdk_types.Int `protobuf:"bytes,2,opt,name=total_elements,json=totalElements,proto3,customtype=github.com/Finschia/finschia-sdk/types.Int" json:"total_elements"`
	// Number of elements in the batch.
	BatchSize  uint64 `protobuf:"varint,3,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	BatchIndex uint64 `protobuf:"varint,4,opt,name=batch_index,json=batchIndex,proto3" json:"batch_index,omitempty"`
	// CTC Batch : previous block hash.
	// SCC Batch : Merkle Root of IntermediateStateRoots.
	BatchRoot []byte `protobuf:"bytes,5,opt,name=batch_root,json=batchRoot,proto3" json:"batch_root,omitempty"`
}

func (m *BatchHeader) Reset()         { *m = BatchHeader{} }
func (m *BatchHeader) String() string { return proto.CompactTextString(m) }
func (*BatchHeader) ProtoMessage()    {}
func (*BatchHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{7}
}
func (m *BatchHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchHeader.Merge(m, src)
}
func (m *BatchHeader) XXX_Size() int {
	return m.Size()
}
func (m *BatchHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchHeader.DiscardUnknown(m)
}

var xxx_messageInfo_BatchHeader proto.InternalMessageInfo

func (m *BatchHeader) GetTxHash() []byte {
	if m != nil {
		return m.TxHash
	}
	return nil
}

func (m *BatchHeader) GetBatchSize() uint64 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *BatchHeader) GetBatchIndex() uint64 {
	if m != nil {
		return m.BatchIndex
	}
	return 0
}

func (m *BatchHeader) GetBatchRoot() []byte {
	if m != nil {
		return m.BatchRoot
	}
	return nil
}

// BatchChainState is the state of target batch chain.
type CTCState struct {
	// Assumed to contain all contiguous batches between base and height (inclusive).
	Base   uint64 `protobuf:"varint,1,opt,name=base,proto3" json:"base,omitempty"`
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// The name of rollup chain (use as key).
	Name []byte `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The ratio between the cost of gas on L1 and L2.
	// This is a positive integer.
	L1ToL2GasRatio uint64 `protobuf:"varint,4,opt,name=l1_to_l2_gas_ratio,json=l1ToL2GasRatio,proto3" json:"l1_to_l2_gas_ratio,omitempty"`
	// Index of the next queue element.
	NextQueueIndex uint64 `protobuf:"varint,5,opt,name=next_queue_index,json=nextQueueIndex,proto3" json:"next_queue_index,omitempty"`
	// The latest batch timestamp.
	L1Timestamp time.Time `protobuf:"bytes,6,opt,name=l1_timestamp,json=l1Timestamp,proto3,stdtime" json:"l1_timestamp"`
	// The latest batch L1 blockNumber.
	L1Height uint64 `protobuf:"varint,7,opt,name=l1_height,json=l1Height,proto3" json:"l1_height,omitempty"`
}

func (m *CTCState) Reset()         { *m = CTCState{} }
func (m *CTCState) String() string { return proto.CompactTextString(m) }
func (*CTCState) ProtoMessage()    {}
func (*CTCState) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{8}
}
func (m *CTCState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CTCState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CTCState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CTCState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTCState.Merge(m, src)
}
func (m *CTCState) XXX_Size() int {
	return m.Size()
}
func (m *CTCState) XXX_DiscardUnknown() {
	xxx_messageInfo_CTCState.DiscardUnknown(m)
}

var xxx_messageInfo_CTCState proto.InternalMessageInfo

func (m *CTCState) GetBase() uint64 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *CTCState) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *CTCState) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *CTCState) GetL1ToL2GasRatio() uint64 {
	if m != nil {
		return m.L1ToL2GasRatio
	}
	return 0
}

func (m *CTCState) GetNextQueueIndex() uint64 {
	if m != nil {
		return m.NextQueueIndex
	}
	return 0
}

func (m *CTCState) GetL1Timestamp() time.Time {
	if m != nil {
		return m.L1Timestamp
	}
	return time.Time{}
}

func (m *CTCState) GetL1Height() uint64 {
	if m != nil {
		return m.L1Height
	}
	return 0
}

// BatchChainState is the state of target batch chain.
type SCCState struct {
	// Assumed to contain all contiguous batches between base and height (inclusive).
	Base   uint64 `protobuf:"varint,1,opt,name=base,proto3" json:"base,omitempty"`
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// The name of rollup chain (use as key).
	Name []byte `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The latest batch timestamp when the sequencer submits.
	LastSequencerSubmit time.Time `protobuf:"bytes,4,opt,name=last_sequencer_submit,json=lastSequencerSubmit,proto3,stdtime" json:"last_sequencer_submit"`
}

func (m *SCCState) Reset()         { *m = SCCState{} }
func (m *SCCState) String() string { return proto.CompactTextString(m) }
func (*SCCState) ProtoMessage()    {}
func (*SCCState) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{9}
}
func (m *SCCState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCCState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCCState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCCState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCCState.Merge(m, src)
}
func (m *SCCState) XXX_Size() int {
	return m.Size()
}
func (m *SCCState) XXX_DiscardUnknown() {
	xxx_messageInfo_SCCState.DiscardUnknown(m)
}

var xxx_messageInfo_SCCState proto.InternalMessageInfo

func (m *SCCState) GetBase() uint64 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *SCCState) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SCCState) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *SCCState) GetLastSequencerSubmit() time.Time {
	if m != nil {
		return m.LastSequencerSubmit
	}
	return time.Time{}
}

func init() {
	proto.RegisterEnum("finschia.or.da.v1.CompressionOption", CompressionOption_name, CompressionOption_value)
	proto.RegisterType((*CTCBatchContext)(nil), "finschia.or.da.v1.CTCBatchContext")
	proto.RegisterType((*CTCBatchElement)(nil), "finschia.or.da.v1.CTCBatchElement")
	proto.RegisterType((*CTCBatch)(nil), "finschia.or.da.v1.CTCBatch")
	proto.RegisterType((*CTCRef)(nil), "finschia.or.da.v1.CTCRef")
	proto.RegisterType((*L1ToL2Queue)(nil), "finschia.or.da.v1.L1toL2Queue")
	proto.RegisterType((*SCCBatch)(nil), "finschia.or.da.v1.SCCBatch")
	proto.RegisterType((*SCCRef)(nil), "finschia.or.da.v1.SCCRef")
	proto.RegisterType((*BatchHeader)(nil), "finschia.or.da.v1.BatchHeader")
	proto.RegisterType((*CTCState)(nil), "finschia.or.da.v1.CTCState")
	proto.RegisterType((*SCCState)(nil), "finschia.or.da.v1.SCCState")
}

func init() { proto.RegisterFile("finschia/or/da/v1/da.proto", fileDescriptor_5f98d06b06a65392) }

var fileDescriptor_5f98d06b06a65392 = []byte{
	// 926 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4f, 0x6f, 0xdc, 0x44,
	0x14, 0x5f, 0xef, 0xa6, 0xcb, 0x66, 0xbc, 0xdd, 0x24, 0x43, 0xda, 0xae, 0x16, 0xe1, 0x0d, 0x7b,
	0x8a, 0x82, 0xb0, 0xb5, 0xae, 0x54, 0x6e, 0x08, 0xd6, 0xd9, 0x36, 0x2b, 0x85, 0x26, 0xb5, 0x8d,
	0x04, 0xbd, 0x58, 0xb3, 0xeb, 0xc9, 0xda, 0xc2, 0xf6, 0x6c, 0x3d, 0xe3, 0xe2, 0xf6, 0xc4, 0x09,
	0x41, 0x4f, 0xfd, 0x02, 0x3d, 0xc1, 0x81, 0x0b, 0xdf, 0xa3, 0xc7, 0x1e, 0x11, 0x42, 0x01, 0x25,
	0x47, 0x24, 0x3e, 0x03, 0x9a, 0x19, 0xdb, 0xdd, 0x26, 0x8d, 0x8a, 0x20, 0xea, 0x69, 0x3d, 0xef,
	0xcf, 0xcf, 0xef, 0xfd, 0xfc, 0x7b, 0x6f, 0x16, 0xf4, 0x8e, 0xc2, 0x84, 0xce, 0x82, 0x10, 0x19,
	0x24, 0x35, 0x7c, 0x64, 0x3c, 0x1c, 0x1a, 0x3e, 0xd2, 0x17, 0x29, 0x61, 0x04, 0x6e, 0x94, 0x3e,
	0x9d, 0xa4, 0xba, 0x8f, 0xf4, 0x87, 0xc3, 0xde, 0xe6, 0x9c, 0xcc, 0x89, 0xf0, 0x1a, 0xfc, 0x49,
	0x06, 0xf6, 0xfa, 0x73, 0x42, 0xe6, 0x11, 0x36, 0xc4, 0x69, 0x9a, 0x1d, 0x19, 0x2c, 0x8c, 0x31,
	0x65, 0x28, 0x5e, 0x14, 0x01, 0xda, 0xf9, 0xb7, 0x2c, 0x50, 0x8a, 0x62, 0x2a, 0xfd, 0x83, 0xdf,
	0x15, 0xb0, 0x66, 0xb9, 0xd6, 0x08, 0xb1, 0x59, 0x60, 0x91, 0x84, 0xe1, 0x9c, 0xc1, 0x1d, 0xb0,
	0x91, 0x64, 0xb1, 0x47, 0xf1, 0x83, 0x0c, 0x27, 0x33, 0xec, 0x7b, 0x2c, 0xa7, 0x5d, 0x65, 0x4b,
	0xd9, 0x5e, 0xb1, 0xd7, 0x92, 0x2c, 0x76, 0x4a, 0xbb, 0x9b, 0x53, 0xf8, 0x31, 0xe8, 0x8a, 0xd8,
	0x6c, 0x2a, 0xc3, 0x99, 0xf7, 0x20, 0xc3, 0x19, 0x16, 0x29, 0x75, 0x91, 0x72, 0x8d, 0xa7, 0x54,
	0xee, 0x7b, 0xdc, 0xcb, 0x13, 0xef, 0x80, 0x76, 0x34, 0xf4, 0xaa, 0x72, 0xbb, 0x8d, 0x2d, 0x65,
	0x5b, 0x35, 0x7b, 0xba, 0x6c, 0x48, 0x2f, 0x1b, 0xd2, 0xdd, 0x32, 0x62, 0xd4, 0x7a, 0x7e, 0xdc,
	0xaf, 0x3d, 0xfd, 0xa3, 0xaf, 0xd8, 0x6a, 0x34, 0xac, 0xcc, 0xf0, 0x3d, 0xb0, 0x1a, 0x0d, 0xbd,
	0x00, 0x87, 0xf3, 0x80, 0x75, 0x57, 0xc4, 0x2b, 0x5b, 0xd1, 0x70, 0x4f, 0x9c, 0x07, 0x7f, 0x2f,
	0xb5, 0x37, 0x8e, 0x70, 0x8c, 0x13, 0x06, 0x3f, 0x00, 0xed, 0x90, 0xbe, 0xec, 0x4e, 0x74, 0xd6,
	0xb2, 0xd5, 0x90, 0x56, 0x8d, 0x9d, 0x2b, 0xae, 0x7e, 0x29, 0xc5, 0x35, 0x5e, 0x2d, 0x0e, 0x6e,
	0x82, 0x2b, 0x2c, 0x4f, 0xd1, 0x37, 0xa2, 0xea, 0xb6, 0x2d, 0x0f, 0xb0, 0x0f, 0x54, 0x49, 0x61,
	0x98, 0xf8, 0x38, 0xef, 0x5e, 0x11, 0x49, 0x40, 0x98, 0x26, 0xdc, 0x22, 0x30, 0xcd, 0x12, 0xb3,
	0x59, 0x60, 0x9a, 0x45, 0xc3, 0xdf, 0xd6, 0x41, 0xab, 0x6c, 0x18, 0x86, 0xe0, 0x06, 0x0d, 0x48,
	0x16, 0xf9, 0x1e, 0x65, 0x28, 0x65, 0x1e, 0x62, 0x1e, 0x96, 0x24, 0x88, 0xa6, 0x57, 0x47, 0x26,
	0xaf, 0xfa, 0xb7, 0xe3, 0xfe, 0xce, 0x3c, 0x64, 0x41, 0x36, 0xd5, 0x67, 0x24, 0x36, 0x6e, 0x97,
	0x82, 0x29, 0x95, 0xf3, 0x11, 0xf5, 0xbf, 0x36, 0xd8, 0xa3, 0x05, 0xa6, 0xfa, 0x24, 0x61, 0xf6,
	0xa6, 0x84, 0x74, 0x38, 0xe2, 0x67, 0xac, 0x24, 0x75, 0x02, 0x3a, 0x53, 0xfe, 0x4e, 0x6f, 0x26,
	0x45, 0xc4, 0xbf, 0x7e, 0x63, 0x5b, 0x35, 0x07, 0xfa, 0x39, 0x29, 0xeb, 0x67, 0xf4, 0x66, 0x5f,
	0x9d, 0x2e, 0x9d, 0x28, 0xfc, 0x04, 0xb4, 0x8a, 0x2a, 0x69, 0xb7, 0xf1, 0x46, 0x90, 0xa2, 0x00,
	0xbb, 0xca, 0x19, 0x7c, 0x0a, 0x9a, 0x96, 0x6b, 0xd9, 0xf8, 0x08, 0xde, 0x02, 0xcd, 0x00, 0x23,
	0x1f, 0xa7, 0xa2, 0x5d, 0xd5, 0xd4, 0x5e, 0x83, 0x23, 0x40, 0xf6, 0x44, 0x94, 0x5d, 0x44, 0x0f,
	0x7e, 0x50, 0x80, 0xba, 0x3f, 0x64, 0x64, 0xdf, 0x14, 0x72, 0x3d, 0x27, 0x07, 0xe5, 0x52, 0xe4,
	0x50, 0xbf, 0x48, 0x0e, 0x8d, 0x25, 0x39, 0x0c, 0x7e, 0x51, 0x40, 0xcb, 0xb1, 0xde, 0xfe, 0x07,
	0xbd, 0x05, 0xae, 0x4f, 0x12, 0x86, 0xd3, 0x18, 0xfb, 0x21, 0x62, 0xd8, 0x61, 0x88, 0x61, 0x9b,
	0x90, 0xe2, 0xc3, 0xb6, 0xed, 0x0b, 0xbc, 0x9c, 0x7d, 0xc7, 0xfa, 0x5f, 0xec, 0xff, 0xa5, 0x00,
	0x75, 0xc9, 0x0e, 0x07, 0xa0, 0xc9, 0xf2, 0x00, 0xd1, 0x40, 0xe0, 0xb4, 0x47, 0xe0, 0xe4, 0xb8,
	0xdf, 0x74, 0xf3, 0x3d, 0x44, 0x03, 0xbb, 0xf0, 0xc0, 0xaf, 0x40, 0x87, 0x11, 0x86, 0x22, 0xaf,
	0x52, 0x4e, 0xfd, 0x3f, 0xf3, 0x71, 0x55, 0x20, 0x15, 0x3c, 0x50, 0xf8, 0x3e, 0x00, 0x52, 0xd9,
	0x34, 0x7c, 0x8c, 0x8b, 0x19, 0x5e, 0x15, 0x16, 0x27, 0x7c, 0x8c, 0xf9, 0xb8, 0x4a, 0xb7, 0x1c,
	0x57, 0xb9, 0x80, 0x64, 0x86, 0x1c, 0xd7, 0x2a, 0x3f, 0x25, 0x84, 0x89, 0x71, 0x6e, 0x17, 0xf9,
	0x9c, 0xb0, 0xc1, 0x77, 0x72, 0x60, 0x05, 0x83, 0x10, 0x82, 0x95, 0x29, 0xa2, 0xb8, 0x58, 0xb6,
	0xe2, 0x19, 0x5e, 0xe7, 0x34, 0x2e, 0x09, 0xa6, 0x38, 0xf1, 0xd8, 0x04, 0xc5, 0xb8, 0x50, 0x8b,
	0x78, 0x86, 0x3b, 0x00, 0x72, 0xa1, 0x12, 0x2f, 0x32, 0xbd, 0x39, 0xa2, 0x5e, 0x8a, 0x58, 0x48,
	0x8a, 0x9a, 0x3a, 0xd1, 0xd0, 0x25, 0xfb, 0xe6, 0x1d, 0x44, 0x6d, 0x6e, 0x85, 0xdb, 0x60, 0x3d,
	0xc1, 0x79, 0xb9, 0xaf, 0x97, 0x97, 0x4d, 0x87, 0xdb, 0xef, 0xbd, 0x5c, 0x38, 0x67, 0xe5, 0xdf,
	0xbc, 0x14, 0xf9, 0xbf, 0x73, 0x66, 0x55, 0xff, 0x24, 0x85, 0x7e, 0x39, 0x44, 0x7c, 0x09, 0xae,
	0x45, 0x88, 0xb2, 0x6a, 0xcb, 0xa7, 0xfc, 0x86, 0x8a, 0x43, 0x79, 0x41, 0xfc, 0xdb, 0xda, 0xdf,
	0xe5, 0x10, 0xe5, 0xa5, 0x90, 0x3a, 0x02, 0x60, 0xe7, 0x67, 0x05, 0x6c, 0x58, 0x24, 0x5e, 0xa4,
	0x98, 0xd2, 0x90, 0x24, 0x07, 0x0b, 0x16, 0x92, 0x04, 0xde, 0x04, 0x9a, 0x75, 0xf0, 0xf9, 0xa1,
	0x3d, 0x76, 0x9c, 0xc9, 0xc1, 0x5d, 0xef, 0xe0, 0xd0, 0xe5, 0x3f, 0x5f, 0xdc, 0x75, 0x0e, 0xc7,
	0xd6, 0xe4, 0xf6, 0x64, 0xbc, 0xbb, 0x5e, 0xeb, 0xad, 0x3d, 0x79, 0xb6, 0xa5, 0xca, 0xf8, 0x71,
	0xbc, 0x60, 0x8f, 0xe0, 0x87, 0xe0, 0xc6, 0x6b, 0x92, 0xee, 0xef, 0x4f, 0x46, 0xeb, 0x4a, 0xaf,
	0xf3, 0xe4, 0xd9, 0x16, 0x90, 0xd1, 0xdc, 0x72, 0x51, 0xb0, 0xe3, 0xee, 0xae, 0xd7, 0x5f, 0x09,
	0x76, 0xdc, 0xdd, 0xde, 0xca, 0xf7, 0x3f, 0x6a, 0xb5, 0xd1, 0xde, 0xf3, 0x13, 0x4d, 0x79, 0x71,
	0xa2, 0x29, 0x7f, 0x9e, 0x68, 0xca, 0xd3, 0x53, 0xad, 0xf6, 0xe2, 0x54, 0xab, 0xfd, 0x7a, 0xaa,
	0xd5, 0xee, 0xeb, 0x6f, 0x1c, 0x87, 0xbc, 0xf8, 0xbf, 0x20, 0xc6, 0x62, 0xda, 0x14, 0x3c, 0xdd,
	0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0x04, 0xb2, 0x4a, 0x58, 0xb4, 0x08, 0x00, 0x00,
}

func (m *CTCBatchContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTCBatchContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CTCBatchContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.L1Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Height))
		i--
		dAtA[i] = 0x20
	}
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.L1Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.L1Timestamp):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintDa(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x1a
	if m.NumSubsequentQueueTxs != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.NumSubsequentQueueTxs))
		i--
		dAtA[i] = 0x10
	}
	if m.NumSequencedTxs != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.NumSequencedTxs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CTCBatchElement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTCBatchElement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CTCBatchElement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.L2Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L2Height))
		i--
		dAtA[i] = 0x30
	}
	if m.QueueIndex != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.QueueIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Txraw) > 0 {
		i -= len(m.Txraw)
		copy(dAtA[i:], m.Txraw)
		i = encodeVarintDa(dAtA, i, uint64(len(m.Txraw)))
		i--
		dAtA[i] = 0x22
	}
	if m.L1Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Height))
		i--
		dAtA[i] = 0x18
	}
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.L1Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.L1Timestamp):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintDa(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x12
	if m.IsSequenced {
		i--
		if m.IsSequenced {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CTCBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTCBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CTCBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Elements) > 0 {
		for iNdEx := len(m.Elements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Elements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BatchContexts) > 0 {
		for iNdEx := len(m.BatchContexts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BatchContexts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.ShouldStartAtElement.Size()
		i -= size
		if _, err := m.ShouldStartAtElement.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CTCRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTCRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CTCRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L1ToL2Queue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L1ToL2Queue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L1ToL2Queue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Txraw) > 0 {
		i -= len(m.Txraw)
		copy(dAtA[i:], m.Txraw)
		i = encodeVarintDa(dAtA, i, uint64(len(m.Txraw)))
		i--
		dAtA[i] = 0x1a
	}
	if m.L1Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Height))
		i--
		dAtA[i] = 0x10
	}
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.L1Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.L1Timestamp):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintDa(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SCCBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCCBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCCBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IntermediateStateRoots) > 0 {
		for iNdEx := len(m.IntermediateStateRoots) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IntermediateStateRoots[iNdEx])
			copy(dAtA[i:], m.IntermediateStateRoots[iNdEx])
			i = encodeVarintDa(dAtA, i, uint64(len(m.IntermediateStateRoots[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size := m.ShouldStartAtElement.Size()
		i -= size
		if _, err := m.ShouldStartAtElement.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SCCRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCCRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCCRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchRoot) > 0 {
		i -= len(m.BatchRoot)
		copy(dAtA[i:], m.BatchRoot)
		i = encodeVarintDa(dAtA, i, uint64(len(m.BatchRoot)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BatchIndex != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.BatchIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.BatchSize != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalElements.Size()
		i -= size
		if _, err := m.TotalElements.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintDa(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CTCState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTCState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CTCState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.L1Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Height))
		i--
		dAtA[i] = 0x38
	}
	n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.L1Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.L1Timestamp):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintDa(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x32
	if m.NextQueueIndex != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.NextQueueIndex))
		i--
		dAtA[i] = 0x28
	}
	if m.L1ToL2GasRatio != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1ToL2GasRatio))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDa(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Base != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Base))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCCState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCCState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCCState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastSequencerSubmit, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSequencerSubmit):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintDa(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x22
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintDa(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Base != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Base))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDa(dAtA []byte, offset int, v uint64) int {
	offset -= sovDa(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CTCBatchContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumSequencedTxs != 0 {
		n += 1 + sovDa(uint64(m.NumSequencedTxs))
	}
	if m.NumSubsequentQueueTxs != 0 {
		n += 1 + sovDa(uint64(m.NumSubsequentQueueTxs))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.L1Timestamp)
	n += 1 + l + sovDa(uint64(l))
	if m.L1Height != 0 {
		n += 1 + sovDa(uint64(m.L1Height))
	}
	return n
}

func (m *CTCBatchElement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsSequenced {
		n += 2
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.L1Timestamp)
	n += 1 + l + sovDa(uint64(l))
	if m.L1Height != 0 {
		n += 1 + sovDa(uint64(m.L1Height))
	}
	l = len(m.Txraw)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	if m.QueueIndex != 0 {
		n += 1 + sovDa(uint64(m.QueueIndex))
	}
	if m.L2Height != 0 {
		n += 1 + sovDa(uint64(m.L2Height))
	}
	return n
}

func (m *CTCBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ShouldStartAtElement.Size()
	n += 1 + l + sovDa(uint64(l))
	if len(m.BatchContexts) > 0 {
		for _, e := range m.BatchContexts {
			l = e.Size()
			n += 1 + l + sovDa(uint64(l))
		}
	}
	if len(m.Elements) > 0 {
		for _, e := range m.Elements {
			l = e.Size()
			n += 1 + l + sovDa(uint64(l))
		}
	}
	return n
}

func (m *CTCRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovDa(uint64(l))
	}
	return n
}

func (m *L1ToL2Queue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.L1Timestamp)
	n += 1 + l + sovDa(uint64(l))
	if m.L1Height != 0 {
		n += 1 + sovDa(uint64(m.L1Height))
	}
	l = len(m.Txraw)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	return n
}

func (m *SCCBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ShouldStartAtElement.Size()
	n += 1 + l + sovDa(uint64(l))
	if len(m.IntermediateStateRoots) > 0 {
		for _, b := range m.IntermediateStateRoots {
			l = len(b)
			n += 1 + l + sovDa(uint64(l))
		}
	}
	return n
}

func (m *SCCRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovDa(uint64(l))
	}
	return n
}

func (m *BatchHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	l = m.TotalElements.Size()
	n += 1 + l + sovDa(uint64(l))
	if m.BatchSize != 0 {
		n += 1 + sovDa(uint64(m.BatchSize))
	}
	if m.BatchIndex != 0 {
		n += 1 + sovDa(uint64(m.BatchIndex))
	}
	l = len(m.BatchRoot)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	return n
}

func (m *CTCState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != 0 {
		n += 1 + sovDa(uint64(m.Base))
	}
	if m.Height != 0 {
		n += 1 + sovDa(uint64(m.Height))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	if m.L1ToL2GasRatio != 0 {
		n += 1 + sovDa(uint64(m.L1ToL2GasRatio))
	}
	if m.NextQueueIndex != 0 {
		n += 1 + sovDa(uint64(m.NextQueueIndex))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.L1Timestamp)
	n += 1 + l + sovDa(uint64(l))
	if m.L1Height != 0 {
		n += 1 + sovDa(uint64(m.L1Height))
	}
	return n
}

func (m *SCCState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != 0 {
		n += 1 + sovDa(uint64(m.Base))
	}
	if m.Height != 0 {
		n += 1 + sovDa(uint64(m.Height))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSequencerSubmit)
	n += 1 + l + sovDa(uint64(l))
	return n
}

func sovDa(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDa(x uint64) (n int) {
	return sovDa(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CTCBatchContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTCBatchContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTCBatchContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSequencedTxs", wireType)
			}
			m.NumSequencedTxs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSequencedTxs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSubsequentQueueTxs", wireType)
			}
			m.NumSubsequentQueueTxs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSubsequentQueueTxs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.L1Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Height", wireType)
			}
			m.L1Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTCBatchElement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTCBatchElement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTCBatchElement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSequenced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSequenced = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.L1Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Height", wireType)
			}
			m.L1Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txraw", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txraw = append(m.Txraw[:0], dAtA[iNdEx:postIndex]...)
			if m.Txraw == nil {
				m.Txraw = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueIndex", wireType)
			}
			m.QueueIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Height", wireType)
			}
			m.L2Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L2Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTCBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTCBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTCBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShouldStartAtElement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShouldStartAtElement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchContexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchContexts = append(m.BatchContexts, &CTCBatchContext{})
			if err := m.BatchContexts[len(m.BatchContexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elements = append(m.Elements, &CTCBatchElement{})
			if err := m.Elements[len(m.Elements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTCRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTCRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTCRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &BatchHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L1ToL2Queue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L1toL2Queue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L1toL2Queue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.L1Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Height", wireType)
			}
			m.L1Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txraw", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txraw = append(m.Txraw[:0], dAtA[iNdEx:postIndex]...)
			if m.Txraw == nil {
				m.Txraw = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCCBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCCBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCCBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShouldStartAtElement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShouldStartAtElement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntermediateStateRoots", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntermediateStateRoots = append(m.IntermediateStateRoots, make([]byte, postIndex-iNdEx))
			copy(m.IntermediateStateRoots[len(m.IntermediateStateRoots)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCCRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCCRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCCRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &BatchHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalElements", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalElements.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchIndex", wireType)
			}
			m.BatchIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchRoot = append(m.BatchRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.BatchRoot == nil {
				m.BatchRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTCState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTCState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTCState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			m.Base = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Base |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1ToL2GasRatio", wireType)
			}
			m.L1ToL2GasRatio = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1ToL2GasRatio |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextQueueIndex", wireType)
			}
			m.NextQueueIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextQueueIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.L1Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Height", wireType)
			}
			m.L1Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCCState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCCState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCCState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			m.Base = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Base |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSequencerSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastSequencerSubmit, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDa(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDa
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDa
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDa
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDa
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDa        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDa          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDa = fmt.Errorf("proto: unexpected end of group")
)
