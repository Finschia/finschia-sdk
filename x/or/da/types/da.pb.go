// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: finschia/or/da/v1/da.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CompressionOption int32

const (
	// COMPRESSION_OPTION_UNSPECIFIED defines a no-op compress option.
	OptionEmpty CompressionOption = 0
	// Go standard library fo zlib compression (RFC 1950).
	OptionZLIB CompressionOption = 1
	// Zstandard is a fast compression algorithm, providing high compression ratios.
	// It also offers a special mode for small data, called dictionary compression.
	OptionZSTD CompressionOption = 2
)

var CompressionOption_name = map[int32]string{
	0: "COMPRESSION_OPTION_UNSPECIFIED",
	1: "COMPRESSION_OPTION_ZLIB",
	2: "COMPRESSION_OPTION_ZSTD",
}

var CompressionOption_value = map[string]int32{
	"COMPRESSION_OPTION_UNSPECIFIED": 0,
	"COMPRESSION_OPTION_ZLIB":        1,
	"COMPRESSION_OPTION_ZSTD":        2,
}

func (x CompressionOption) String() string {
	return proto.EnumName(CompressionOption_name, int32(x))
}

func (CompressionOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{0}
}

type QueueTxStatus int32

const (
	// QUEUE_TX_PENDING defines the status where the Tx has not been submitted to L1 batch yet.
	QUEUE_TX_PENDING QueueTxStatus = 0
	// QUEUE_TX_FINALIZED defines the status where the Tx has been submitted to L1 batch.
	QUEUE_TX_FINALIZED QueueTxStatus = 1
	// QUEUE_TX_OUTDATED defines the status where the Tx has not been submitted until the expiration deadline.
	// Sequencers get penalty if queued txs reach this status.
	QUEUE_TX_OUTDATED QueueTxStatus = 2
)

var QueueTxStatus_name = map[int32]string{
	0: "QUEUE_TX_PENDING",
	1: "QUEUE_TX_FINALIZED",
	2: "QUEUE_TX_OUTDATED",
}

var QueueTxStatus_value = map[string]int32{
	"QUEUE_TX_PENDING":   0,
	"QUEUE_TX_FINALIZED": 1,
	"QUEUE_TX_OUTDATED":  2,
}

func (x QueueTxStatus) String() string {
	return proto.EnumName(QueueTxStatus_name, int32(x))
}

func (QueueTxStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{1}
}

// BatchContext denotes a range of transactions that belong the same batch.
// It is used to compress shared fields that would otherwise be repeated for each transaction.
type CCBatchHeader struct {
	// parent_hash is the parent L2 block hash
	ParentHash []byte `protobuf:"bytes,1,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	// timestamp is the L2 block unix timestamp of the batch.
	Timestamp time.Time `protobuf:"bytes,2,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	L2Height  uint64    `protobuf:"varint,3,opt,name=l2_height,json=l2Height,proto3" json:"l2_height,omitempty"`
	// blockNumber is the L1 BlockNumber of the batch.
	L1Height uint64 `protobuf:"varint,4,opt,name=l1_height,json=l1Height,proto3" json:"l1_height,omitempty"`
}

func (m *CCBatchHeader) Reset()         { *m = CCBatchHeader{} }
func (m *CCBatchHeader) String() string { return proto.CompactTextString(m) }
func (*CCBatchHeader) ProtoMessage()    {}
func (*CCBatchHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{0}
}
func (m *CCBatchHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCBatchHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCBatchHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCBatchHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCBatchHeader.Merge(m, src)
}
func (m *CCBatchHeader) XXX_Size() int {
	return m.Size()
}
func (m *CCBatchHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_CCBatchHeader.DiscardUnknown(m)
}

var xxx_messageInfo_CCBatchHeader proto.InternalMessageInfo

func (m *CCBatchHeader) GetParentHash() []byte {
	if m != nil {
		return m.ParentHash
	}
	return nil
}

func (m *CCBatchHeader) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *CCBatchHeader) GetL2Height() uint64 {
	if m != nil {
		return m.L2Height
	}
	return 0
}

func (m *CCBatchHeader) GetL1Height() uint64 {
	if m != nil {
		return m.L1Height
	}
	return 0
}

type CCBatchElement struct {
	// SEQUENCER TX ONLY
	Txraw []byte `protobuf:"bytes,1,opt,name=txraw,proto3" json:"txraw,omitempty"`
	// QUEUED TX ONLY
	QueueIndex uint64 `protobuf:"varint,2,opt,name=queue_index,json=queueIndex,proto3" json:"queue_index,omitempty"`
}

func (m *CCBatchElement) Reset()         { *m = CCBatchElement{} }
func (m *CCBatchElement) String() string { return proto.CompactTextString(m) }
func (*CCBatchElement) ProtoMessage()    {}
func (*CCBatchElement) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{1}
}
func (m *CCBatchElement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCBatchElement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCBatchElement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCBatchElement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCBatchElement.Merge(m, src)
}
func (m *CCBatchElement) XXX_Size() int {
	return m.Size()
}
func (m *CCBatchElement) XXX_DiscardUnknown() {
	xxx_messageInfo_CCBatchElement.DiscardUnknown(m)
}

var xxx_messageInfo_CCBatchElement proto.InternalMessageInfo

func (m *CCBatchElement) GetTxraw() []byte {
	if m != nil {
		return m.Txraw
	}
	return nil
}

func (m *CCBatchElement) GetQueueIndex() uint64 {
	if m != nil {
		return m.QueueIndex
	}
	return 0
}

type CCBatchFrame struct {
	Hedaer   *CCBatchHeader    `protobuf:"bytes,1,opt,name=hedaer,proto3" json:"hedaer,omitempty"`
	Elements []*CCBatchElement `protobuf:"bytes,2,rep,name=elements,proto3" json:"elements,omitempty"`
}

func (m *CCBatchFrame) Reset()         { *m = CCBatchFrame{} }
func (m *CCBatchFrame) String() string { return proto.CompactTextString(m) }
func (*CCBatchFrame) ProtoMessage()    {}
func (*CCBatchFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{2}
}
func (m *CCBatchFrame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCBatchFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCBatchFrame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCBatchFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCBatchFrame.Merge(m, src)
}
func (m *CCBatchFrame) XXX_Size() int {
	return m.Size()
}
func (m *CCBatchFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_CCBatchFrame.DiscardUnknown(m)
}

var xxx_messageInfo_CCBatchFrame proto.InternalMessageInfo

func (m *CCBatchFrame) GetHedaer() *CCBatchHeader {
	if m != nil {
		return m.Hedaer
	}
	return nil
}

func (m *CCBatchFrame) GetElements() []*CCBatchElement {
	if m != nil {
		return m.Elements
	}
	return nil
}

// CCBatch is a data unit per batch epoch.
type CCBatch struct {
	// previous total batch frames.
	ShouldStartAtFrame uint64 `protobuf:"varint,1,opt,name=should_start_at_frame,json=shouldStartAtFrame,proto3" json:"should_start_at_frame,omitempty"`
	// One batch frame matches one roll-up block.
	Frames []*CCBatchFrame `protobuf:"bytes,2,rep,name=frames,proto3" json:"frames,omitempty"`
}

func (m *CCBatch) Reset()         { *m = CCBatch{} }
func (m *CCBatch) String() string { return proto.CompactTextString(m) }
func (*CCBatch) ProtoMessage()    {}
func (*CCBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{3}
}
func (m *CCBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCBatch.Merge(m, src)
}
func (m *CCBatch) XXX_Size() int {
	return m.Size()
}
func (m *CCBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_CCBatch.DiscardUnknown(m)
}

var xxx_messageInfo_CCBatch proto.InternalMessageInfo

func (m *CCBatch) GetShouldStartAtFrame() uint64 {
	if m != nil {
		return m.ShouldStartAtFrame
	}
	return 0
}

func (m *CCBatch) GetFrames() []*CCBatchFrame {
	if m != nil {
		return m.Frames
	}
	return nil
}

// // CompressedCCBatch is used  when the sequencer submits.
type CompressedCCBatch struct {
	// data is a byte array which is generated by compressing CCBatch using the option below.
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	// compression is the compression algorithm used for the batch.
	Compression CompressionOption `protobuf:"varint,2,opt,name=compression,proto3,enum=finschia.or.da.v1.CompressionOption" json:"compression,omitempty"`
}

func (m *CompressedCCBatch) Reset()         { *m = CompressedCCBatch{} }
func (m *CompressedCCBatch) String() string { return proto.CompactTextString(m) }
func (*CompressedCCBatch) ProtoMessage()    {}
func (*CompressedCCBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{4}
}
func (m *CompressedCCBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompressedCCBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompressedCCBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompressedCCBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompressedCCBatch.Merge(m, src)
}
func (m *CompressedCCBatch) XXX_Size() int {
	return m.Size()
}
func (m *CompressedCCBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_CompressedCCBatch.DiscardUnknown(m)
}

var xxx_messageInfo_CompressedCCBatch proto.InternalMessageInfo

func (m *CompressedCCBatch) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *CompressedCCBatch) GetCompression() CompressionOption {
	if m != nil {
		return m.Compression
	}
	return OptionEmpty
}

// L1toL2Queue is a queued tx for L2 batch.
// Sequencer must process this transaction on time in order.
// Queue index start from 1.
type L1ToL2Queue struct {
	// timestamp is the L1 unix timestamp of the batch.
	// It is set when the type of tx is L1toL2
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// blockNumber is the L1 BlockNumber of the batch.
	L1Height uint64        `protobuf:"varint,2,opt,name=l1_height,json=l1Height,proto3" json:"l1_height,omitempty"`
	Txraw    []byte        `protobuf:"bytes,3,opt,name=txraw,proto3" json:"txraw,omitempty"`
	Status   QueueTxStatus `protobuf:"varint,4,opt,name=status,proto3,enum=finschia.or.da.v1.QueueTxStatus" json:"status,omitempty"`
}

func (m *L1ToL2Queue) Reset()         { *m = L1ToL2Queue{} }
func (m *L1ToL2Queue) String() string { return proto.CompactTextString(m) }
func (*L1ToL2Queue) ProtoMessage()    {}
func (*L1ToL2Queue) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{5}
}
func (m *L1ToL2Queue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L1ToL2Queue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L1ToL2Queue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L1ToL2Queue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L1ToL2Queue.Merge(m, src)
}
func (m *L1ToL2Queue) XXX_Size() int {
	return m.Size()
}
func (m *L1ToL2Queue) XXX_DiscardUnknown() {
	xxx_messageInfo_L1ToL2Queue.DiscardUnknown(m)
}

var xxx_messageInfo_L1ToL2Queue proto.InternalMessageInfo

func (m *L1ToL2Queue) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *L1ToL2Queue) GetL1Height() uint64 {
	if m != nil {
		return m.L1Height
	}
	return 0
}

func (m *L1ToL2Queue) GetTxraw() []byte {
	if m != nil {
		return m.Txraw
	}
	return nil
}

func (m *L1ToL2Queue) GetStatus() QueueTxStatus {
	if m != nil {
		return m.Status
	}
	return QUEUE_TX_PENDING
}

// CCRef is a data type that forms an element of the reference chain of Rollup Canonical Chain.
type CCRef struct {
	// Reference for accessing batch data.
	TxHash []byte `protobuf:"bytes,1,opt,name=txhash,proto3" json:"txhash,omitempty"`
	// Reference for accessing batch data.
	MsgIndex uint32 `protobuf:"varint,2,opt,name=msg_index,json=msgIndex,proto3" json:"msg_index,omitempty"`
	// Total number of batch frames submitted.
	// It is the same as the height of the L2 block submitted so far
	TotalFrames uint64 `protobuf:"varint,3,opt,name=total_frames,json=totalFrames,proto3" json:"total_frames,omitempty"`
	// Number of batch frames in the batch.
	BatchSize uint32 `protobuf:"varint,4,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	// Hash of CompressedCCBatch data.
	BatchRoot []byte `protobuf:"bytes,5,opt,name=batch_root,json=batchRoot,proto3" json:"batch_root,omitempty"`
}

func (m *CCRef) Reset()         { *m = CCRef{} }
func (m *CCRef) String() string { return proto.CompactTextString(m) }
func (*CCRef) ProtoMessage()    {}
func (*CCRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{6}
}
func (m *CCRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCRef.Merge(m, src)
}
func (m *CCRef) XXX_Size() int {
	return m.Size()
}
func (m *CCRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CCRef.DiscardUnknown(m)
}

var xxx_messageInfo_CCRef proto.InternalMessageInfo

func (m *CCRef) GetTxHash() []byte {
	if m != nil {
		return m.TxHash
	}
	return nil
}

func (m *CCRef) GetMsgIndex() uint32 {
	if m != nil {
		return m.MsgIndex
	}
	return 0
}

func (m *CCRef) GetTotalFrames() uint64 {
	if m != nil {
		return m.TotalFrames
	}
	return 0
}

func (m *CCRef) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *CCRef) GetBatchRoot() []byte {
	if m != nil {
		return m.BatchRoot
	}
	return nil
}

// BatchChainState is the state of target batch chain.
type CCState struct {
	// Assumed to contain all contiguous batches between base and height (inclusive).
	Base   uint64 `protobuf:"varint,1,opt,name=base,proto3" json:"base,omitempty"`
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// Index of the processed queue element.
	// Queue elements up to this index were submitted via CC batch or timeout.
	ProcessedQueueIndex uint64 `protobuf:"varint,3,opt,name=processed_queue_index,json=processedQueueIndex,proto3" json:"processed_queue_index,omitempty"`
	// Index of the next queue element.
	NextQueueIndex uint64 `protobuf:"varint,4,opt,name=next_queue_index,json=nextQueueIndex,proto3" json:"next_queue_index,omitempty"`
	// The latest batch timestamp.
	Timestamp time.Time `protobuf:"bytes,5,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// The latest batch L1 blockNumber.
	L1Height uint64 `protobuf:"varint,6,opt,name=l1_height,json=l1Height,proto3" json:"l1_height,omitempty"`
}

func (m *CCState) Reset()         { *m = CCState{} }
func (m *CCState) String() string { return proto.CompactTextString(m) }
func (*CCState) ProtoMessage()    {}
func (*CCState) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{7}
}
func (m *CCState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CCState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CCState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CCState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CCState.Merge(m, src)
}
func (m *CCState) XXX_Size() int {
	return m.Size()
}
func (m *CCState) XXX_DiscardUnknown() {
	xxx_messageInfo_CCState.DiscardUnknown(m)
}

var xxx_messageInfo_CCState proto.InternalMessageInfo

func (m *CCState) GetBase() uint64 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *CCState) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *CCState) GetProcessedQueueIndex() uint64 {
	if m != nil {
		return m.ProcessedQueueIndex
	}
	return 0
}

func (m *CCState) GetNextQueueIndex() uint64 {
	if m != nil {
		return m.NextQueueIndex
	}
	return 0
}

func (m *CCState) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *CCState) GetL1Height() uint64 {
	if m != nil {
		return m.L1Height
	}
	return 0
}

// Proposer use SCCBatch when they submit.
type SCCBatch struct {
	// previous total batch frames.
	ShouldStartAtFrame uint64 `protobuf:"varint,1,opt,name=should_start_at_frame,json=shouldStartAtFrame,proto3" json:"should_start_at_frame,omitempty"`
	// IntermediateStateRoots for a specific range of CCs.
	// len(IntermediateStateRoots) = len(CCBatchFrame) * (len(CCBatchElement) + 2)
	// BeginBlock + DeliverTX for each CCBatchElement + EndBlock
	IntermediateStateRoots [][]byte `protobuf:"bytes,2,rep,name=IntermediateStateRoots,proto3" json:"IntermediateStateRoots,omitempty"`
}

func (m *SCCBatch) Reset()         { *m = SCCBatch{} }
func (m *SCCBatch) String() string { return proto.CompactTextString(m) }
func (*SCCBatch) ProtoMessage()    {}
func (*SCCBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{8}
}
func (m *SCCBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCCBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCCBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCCBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCCBatch.Merge(m, src)
}
func (m *SCCBatch) XXX_Size() int {
	return m.Size()
}
func (m *SCCBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_SCCBatch.DiscardUnknown(m)
}

var xxx_messageInfo_SCCBatch proto.InternalMessageInfo

func (m *SCCBatch) GetShouldStartAtFrame() uint64 {
	if m != nil {
		return m.ShouldStartAtFrame
	}
	return 0
}

func (m *SCCBatch) GetIntermediateStateRoots() [][]byte {
	if m != nil {
		return m.IntermediateStateRoots
	}
	return nil
}

// SCCRef is a data type that forms an element of State Commitment Chain.
type SCCRef struct {
	// Reference for accessing batch data.
	TotalFrames uint64 `protobuf:"varint,1,opt,name=total_frames,json=totalFrames,proto3" json:"total_frames,omitempty"`
	// Number of batch frames in the batch.
	BatchSize uint32 `protobuf:"varint,2,opt,name=batch_size,json=batchSize,proto3" json:"batch_size,omitempty"`
	// timestamp is data to determine if this batch is within the challenge period.
	Timestamp time.Time `protobuf:"bytes,3,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// Merkle Root of IntermediateStateRoots.
	BatchRoot              []byte   `protobuf:"bytes,4,opt,name=batch_root,json=batchRoot,proto3" json:"batch_root,omitempty"`
	IntermediateStateRoots [][]byte `protobuf:"bytes,6,rep,name=IntermediateStateRoots,proto3" json:"IntermediateStateRoots,omitempty"`
}

func (m *SCCRef) Reset()         { *m = SCCRef{} }
func (m *SCCRef) String() string { return proto.CompactTextString(m) }
func (*SCCRef) ProtoMessage()    {}
func (*SCCRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{9}
}
func (m *SCCRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCCRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCCRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCCRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCCRef.Merge(m, src)
}
func (m *SCCRef) XXX_Size() int {
	return m.Size()
}
func (m *SCCRef) XXX_DiscardUnknown() {
	xxx_messageInfo_SCCRef.DiscardUnknown(m)
}

var xxx_messageInfo_SCCRef proto.InternalMessageInfo

func (m *SCCRef) GetTotalFrames() uint64 {
	if m != nil {
		return m.TotalFrames
	}
	return 0
}

func (m *SCCRef) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *SCCRef) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *SCCRef) GetBatchRoot() []byte {
	if m != nil {
		return m.BatchRoot
	}
	return nil
}

func (m *SCCRef) GetIntermediateStateRoots() [][]byte {
	if m != nil {
		return m.IntermediateStateRoots
	}
	return nil
}

// BatchChainState is the state of target batch chain.
type SCCState struct {
	// Assumed to contain all contiguous batches between base and height (inclusive).
	Base   uint64 `protobuf:"varint,1,opt,name=base,proto3" json:"base,omitempty"`
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// The latest batch timestamp when the sequencer submits.
	LastSequencerSubmit time.Time `protobuf:"bytes,3,opt,name=last_sequencer_submit,json=lastSequencerSubmit,proto3,stdtime" json:"last_sequencer_submit"`
}

func (m *SCCState) Reset()         { *m = SCCState{} }
func (m *SCCState) String() string { return proto.CompactTextString(m) }
func (*SCCState) ProtoMessage()    {}
func (*SCCState) Descriptor() ([]byte, []int) {
	return fileDescriptor_5f98d06b06a65392, []int{10}
}
func (m *SCCState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SCCState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SCCState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SCCState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SCCState.Merge(m, src)
}
func (m *SCCState) XXX_Size() int {
	return m.Size()
}
func (m *SCCState) XXX_DiscardUnknown() {
	xxx_messageInfo_SCCState.DiscardUnknown(m)
}

var xxx_messageInfo_SCCState proto.InternalMessageInfo

func (m *SCCState) GetBase() uint64 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *SCCState) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *SCCState) GetLastSequencerSubmit() time.Time {
	if m != nil {
		return m.LastSequencerSubmit
	}
	return time.Time{}
}

func init() {
	proto.RegisterEnum("finschia.or.da.v1.CompressionOption", CompressionOption_name, CompressionOption_value)
	proto.RegisterEnum("finschia.or.da.v1.QueueTxStatus", QueueTxStatus_name, QueueTxStatus_value)
	proto.RegisterType((*CCBatchHeader)(nil), "finschia.or.da.v1.CCBatchHeader")
	proto.RegisterType((*CCBatchElement)(nil), "finschia.or.da.v1.CCBatchElement")
	proto.RegisterType((*CCBatchFrame)(nil), "finschia.or.da.v1.CCBatchFrame")
	proto.RegisterType((*CCBatch)(nil), "finschia.or.da.v1.CCBatch")
	proto.RegisterType((*CompressedCCBatch)(nil), "finschia.or.da.v1.CompressedCCBatch")
	proto.RegisterType((*L1ToL2Queue)(nil), "finschia.or.da.v1.L1toL2Queue")
	proto.RegisterType((*CCRef)(nil), "finschia.or.da.v1.CCRef")
	proto.RegisterType((*CCState)(nil), "finschia.or.da.v1.CCState")
	proto.RegisterType((*SCCBatch)(nil), "finschia.or.da.v1.SCCBatch")
	proto.RegisterType((*SCCRef)(nil), "finschia.or.da.v1.SCCRef")
	proto.RegisterType((*SCCState)(nil), "finschia.or.da.v1.SCCState")
}

func init() { proto.RegisterFile("finschia/or/da/v1/da.proto", fileDescriptor_5f98d06b06a65392) }

var fileDescriptor_5f98d06b06a65392 = []byte{
	// 970 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x4f, 0x6f, 0x1a, 0x47,
	0x14, 0x67, 0x30, 0xa6, 0xe4, 0x61, 0x53, 0x3c, 0xb1, 0x5d, 0x44, 0x55, 0x20, 0xab, 0x1e, 0x50,
	0xaa, 0x2e, 0x82, 0x48, 0x6d, 0x2e, 0x3d, 0x18, 0x58, 0x62, 0x24, 0x17, 0xec, 0x5d, 0x2c, 0x45,
	0xbe, 0xac, 0x06, 0x76, 0xcc, 0xae, 0xca, 0x32, 0x64, 0x67, 0x36, 0x25, 0xf9, 0x02, 0xad, 0x72,
	0xf2, 0x17, 0xc8, 0xa9, 0x97, 0xf6, 0xd2, 0x8f, 0xd0, 0x73, 0x8e, 0x39, 0xf6, 0x94, 0x56, 0xb6,
	0xfa, 0x0d, 0xfa, 0x01, 0xaa, 0x9d, 0xdd, 0xe5, 0x8f, 0x63, 0xa7, 0x4a, 0xda, 0x13, 0x3b, 0xef,
	0xf7, 0x9b, 0x99, 0xdf, 0x7b, 0xef, 0xf7, 0x46, 0x40, 0xf1, 0xdc, 0x99, 0xf2, 0x91, 0xed, 0x90,
	0x1a, 0xf3, 0x6a, 0x16, 0xa9, 0x3d, 0xad, 0xd7, 0x2c, 0xa2, 0xce, 0x3c, 0x26, 0x18, 0xde, 0x89,
	0x31, 0x95, 0x79, 0xaa, 0x45, 0xd4, 0xa7, 0xf5, 0xe2, 0xee, 0x98, 0x8d, 0x99, 0x44, 0x6b, 0xc1,
	0x57, 0x48, 0x2c, 0x96, 0xc7, 0x8c, 0x8d, 0x27, 0xb4, 0x26, 0x57, 0x43, 0xff, 0xbc, 0x26, 0x1c,
	0x97, 0x72, 0x41, 0xdc, 0x59, 0x44, 0x28, 0xbd, 0x7d, 0xcb, 0x8c, 0x78, 0xc4, 0xe5, 0x21, 0xae,
	0xfc, 0x8a, 0x60, 0xbb, 0xd5, 0x6a, 0x12, 0x31, 0xb2, 0x0f, 0x29, 0xb1, 0xa8, 0x87, 0xcb, 0x90,
	0x9d, 0x11, 0x8f, 0x4e, 0x85, 0x69, 0x13, 0x6e, 0x17, 0x50, 0x05, 0x55, 0xb7, 0x74, 0x08, 0x43,
	0x87, 0x84, 0xdb, 0xb8, 0x09, 0x77, 0x16, 0xb7, 0x14, 0x92, 0x15, 0x54, 0xcd, 0x36, 0x8a, 0x6a,
	0xa8, 0x43, 0x8d, 0x75, 0xa8, 0x83, 0x98, 0xd1, 0xcc, 0xbc, 0x7a, 0x53, 0x4e, 0x5c, 0xfc, 0x51,
	0x46, 0xfa, 0x72, 0x1b, 0xfe, 0x14, 0xee, 0x4c, 0x1a, 0xa6, 0x4d, 0x9d, 0xb1, 0x2d, 0x0a, 0x1b,
	0x15, 0x54, 0x4d, 0xe9, 0x99, 0x49, 0xe3, 0x50, 0xae, 0x25, 0x58, 0x8f, 0xc1, 0x54, 0x04, 0xd6,
	0x43, 0x50, 0x79, 0x04, 0xb9, 0x48, 0xaf, 0x36, 0xa1, 0x2e, 0x9d, 0x0a, 0xbc, 0x0b, 0x9b, 0x62,
	0xee, 0x91, 0xef, 0x23, 0xa9, 0xe1, 0x22, 0x48, 0xe3, 0x89, 0x4f, 0x7d, 0x6a, 0x3a, 0x53, 0x8b,
	0xce, 0xa5, 0xce, 0x94, 0x0e, 0x32, 0xd4, 0x0d, 0x22, 0xca, 0x0f, 0x08, 0xb6, 0xa2, 0x93, 0x3a,
	0x1e, 0x71, 0x29, 0x7e, 0x08, 0x69, 0x9b, 0x5a, 0x84, 0x7a, 0xf2, 0xa0, 0x6c, 0xa3, 0xa2, 0xbe,
	0xd5, 0x05, 0x75, 0xad, 0x54, 0x7a, 0xc4, 0xc7, 0xdf, 0x40, 0x86, 0x86, 0x62, 0x78, 0x21, 0x59,
	0xd9, 0xa8, 0x66, 0x1b, 0xf7, 0x6e, 0xdf, 0x1b, 0xc9, 0xd6, 0x17, 0x5b, 0x14, 0x1f, 0x3e, 0x8a,
	0x30, 0x5c, 0x87, 0x3d, 0x6e, 0x33, 0x7f, 0x62, 0x99, 0x5c, 0x10, 0x4f, 0x98, 0x44, 0x98, 0xe7,
	0x81, 0x38, 0x29, 0x29, 0xa5, 0xe3, 0x10, 0x34, 0x02, 0xec, 0x40, 0x84, 0xb2, 0xbf, 0x86, 0xb4,
	0xa4, 0xc4, 0x57, 0x97, 0x6f, 0xbf, 0x5a, 0x6e, 0xd0, 0x23, 0xba, 0xc2, 0x60, 0xa7, 0xc5, 0xdc,
	0x99, 0x47, 0x39, 0xa7, 0x56, 0x2c, 0x00, 0x43, 0xca, 0x22, 0x82, 0x44, 0xb5, 0x94, 0xdf, 0xb8,
	0x03, 0xd9, 0x51, 0x44, 0x74, 0xd8, 0x54, 0x96, 0x32, 0xd7, 0xf8, 0xfc, 0xa6, 0x6b, 0x96, 0xac,
	0xfe, 0x4c, 0x38, 0x6c, 0xaa, 0xaf, 0x6e, 0x54, 0x7e, 0x43, 0x90, 0x3d, 0xaa, 0x0b, 0x76, 0xd4,
	0x38, 0x09, 0xda, 0xb0, 0x6e, 0x24, 0xf4, 0xe1, 0x46, 0x5a, 0x78, 0x25, 0xb9, 0xee, 0x95, 0xa5,
	0x33, 0x36, 0x56, 0x9d, 0xf1, 0x10, 0xd2, 0x5c, 0x10, 0xe1, 0x73, 0xe9, 0xad, 0xdc, 0x8d, 0x7d,
	0x96, 0x02, 0x07, 0x73, 0x43, 0xf2, 0xf4, 0x88, 0xaf, 0xfc, 0x82, 0x60, 0xb3, 0xd5, 0xd2, 0xe9,
	0x39, 0x56, 0x20, 0x2d, 0xe6, 0xcb, 0xf9, 0x68, 0xc2, 0xe5, 0x9b, 0x72, 0x7a, 0x30, 0x0f, 0xe6,
	0x43, 0x8f, 0x90, 0x40, 0x9a, 0xcb, 0xc7, 0x2b, 0xfe, 0xdb, 0xd6, 0x33, 0x2e, 0x1f, 0x4b, 0xf7,
	0xe1, 0x7b, 0xb0, 0x25, 0x98, 0x20, 0x13, 0x33, 0xea, 0x5d, 0x38, 0x03, 0x59, 0x19, 0x93, 0x6d,
	0xe2, 0xf8, 0x33, 0x80, 0x61, 0xd0, 0x13, 0x93, 0x3b, 0xcf, 0xa9, 0xd4, 0xba, 0xad, 0xdf, 0x91,
	0x11, 0xc3, 0x79, 0x4e, 0x97, 0xb0, 0xc7, 0x98, 0x28, 0x6c, 0xca, 0x0c, 0x43, 0x58, 0x67, 0x4c,
	0x28, 0x7f, 0xa3, 0xc0, 0x55, 0x41, 0x02, 0x34, 0x68, 0xea, 0x90, 0xf0, 0xd8, 0x44, 0xf2, 0x1b,
	0xef, 0x07, 0x6e, 0x5f, 0xa9, 0x5a, 0xb4, 0xc2, 0x0d, 0xd8, 0x9b, 0x79, 0x6c, 0x24, 0x4d, 0x61,
	0xae, 0x4e, 0x50, 0xa8, 0xf0, 0xee, 0x02, 0x3c, 0x59, 0x8c, 0x12, 0xae, 0x42, 0x7e, 0x4a, 0xe7,
	0x62, 0x8d, 0x1e, 0xce, 0x6d, 0x2e, 0x88, 0xaf, 0x30, 0xd7, 0x5a, 0xbe, 0xf9, 0x3f, 0xb4, 0x3c,
	0x7d, 0xed, 0x79, 0xf0, 0x21, 0x63, 0xfc, 0x87, 0x61, 0xfa, 0x0a, 0xf6, 0xbb, 0x53, 0x41, 0x3d,
	0x97, 0x5a, 0x0e, 0x11, 0x54, 0x96, 0x2f, 0x28, 0x67, 0x38, 0x5c, 0x5b, 0xfa, 0x2d, 0xa8, 0xf2,
	0x17, 0x82, 0xb4, 0x11, 0x5a, 0xe3, 0x7a, 0x67, 0xd1, 0xbf, 0x75, 0x36, 0x79, 0xbd, 0xb3, 0x6b,
	0x45, 0xda, 0xf8, 0xb0, 0x22, 0xad, 0xbb, 0x23, 0x75, 0xcd, 0x1d, 0xef, 0xc8, 0x33, 0xfd, 0xce,
	0x3c, 0x2f, 0x90, 0xac, 0xef, 0xfb, 0xdb, 0xea, 0x31, 0xec, 0x4d, 0x08, 0x17, 0x26, 0xa7, 0x4f,
	0x7c, 0x3a, 0x1d, 0x51, 0xcf, 0xe4, 0xfe, 0xd0, 0x75, 0xc4, 0x7b, 0xe5, 0x77, 0x37, 0x38, 0xc2,
	0x88, 0x4f, 0x30, 0xe4, 0x01, 0xf7, 0x7f, 0x46, 0xcb, 0x77, 0x6c, 0xf1, 0xf0, 0xe0, 0x07, 0x50,
	0x6a, 0xf5, 0xbf, 0x3d, 0xd6, 0x35, 0xc3, 0xe8, 0xf6, 0x7b, 0x66, 0xff, 0x78, 0x10, 0xfc, 0x9c,
	0xf6, 0x8c, 0x63, 0xad, 0xd5, 0xed, 0x74, 0xb5, 0x76, 0x3e, 0x51, 0xfc, 0xf8, 0xc5, 0xcb, 0x4a,
	0x36, 0xe4, 0x6b, 0xee, 0x4c, 0x3c, 0xc3, 0x5f, 0xc0, 0x27, 0x37, 0x6c, 0x3a, 0x3b, 0xea, 0x36,
	0xf3, 0xa8, 0x98, 0x7b, 0xf1, 0xb2, 0x02, 0x21, 0x3b, 0x88, 0xdc, 0x46, 0x36, 0x06, 0xed, 0x7c,
	0x72, 0x8d, 0x6c, 0x0c, 0xda, 0xc5, 0xd4, 0x8f, 0x3f, 0x95, 0x12, 0xf7, 0xcf, 0x60, 0x7b, 0xed,
	0x61, 0xc1, 0xbb, 0x90, 0x3f, 0x39, 0xd5, 0x4e, 0x35, 0x73, 0xf0, 0xd8, 0x3c, 0xd6, 0x7a, 0xed,
	0x6e, 0xef, 0x51, 0x3e, 0x81, 0xf7, 0x01, 0x2f, 0xa2, 0x9d, 0x6e, 0xef, 0xe0, 0xa8, 0x7b, 0xa6,
	0xb5, 0xf3, 0x08, 0xef, 0xc1, 0xce, 0x22, 0xde, 0x3f, 0x1d, 0xb4, 0x0f, 0x06, 0x5a, 0x70, 0x97,
	0x3c, 0xbb, 0x79, 0xf8, 0xea, 0xb2, 0x84, 0x5e, 0x5f, 0x96, 0xd0, 0x9f, 0x97, 0x25, 0x74, 0x71,
	0x55, 0x4a, 0xbc, 0xbe, 0x2a, 0x25, 0x7e, 0xbf, 0x2a, 0x25, 0xce, 0xd4, 0xb1, 0x23, 0x6c, 0x7f,
	0xa8, 0x8e, 0x98, 0x5b, 0xeb, 0xc4, 0xff, 0x06, 0xe2, 0x27, 0xef, 0x4b, 0x6e, 0x7d, 0x57, 0x9b,
	0x47, 0x7f, 0x0e, 0xc4, 0xb3, 0x19, 0xe5, 0xc3, 0xb4, 0xec, 0xc1, 0x83, 0x7f, 0x02, 0x00, 0x00,
	0xff, 0xff, 0x49, 0xd9, 0x25, 0xde, 0xa1, 0x08, 0x00, 0x00,
}

func (m *CCBatchHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCBatchHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CCBatchHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.L1Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Height))
		i--
		dAtA[i] = 0x20
	}
	if m.L2Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L2Height))
		i--
		dAtA[i] = 0x18
	}
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintDa(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x12
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintDa(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CCBatchElement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCBatchElement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CCBatchElement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QueueIndex != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.QueueIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Txraw) > 0 {
		i -= len(m.Txraw)
		copy(dAtA[i:], m.Txraw)
		i = encodeVarintDa(dAtA, i, uint64(len(m.Txraw)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CCBatchFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCBatchFrame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CCBatchFrame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Elements) > 0 {
		for iNdEx := len(m.Elements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Elements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Hedaer != nil {
		{
			size, err := m.Hedaer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CCBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CCBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Frames) > 0 {
		for iNdEx := len(m.Frames) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Frames[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ShouldStartAtFrame != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.ShouldStartAtFrame))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompressedCCBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompressedCCBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompressedCCBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Compression != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Compression))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintDa(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *L1ToL2Queue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L1ToL2Queue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L1ToL2Queue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Txraw) > 0 {
		i -= len(m.Txraw)
		copy(dAtA[i:], m.Txraw)
		i = encodeVarintDa(dAtA, i, uint64(len(m.Txraw)))
		i--
		dAtA[i] = 0x1a
	}
	if m.L1Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Height))
		i--
		dAtA[i] = 0x10
	}
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintDa(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CCRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CCRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BatchRoot) > 0 {
		i -= len(m.BatchRoot)
		copy(dAtA[i:], m.BatchRoot)
		i = encodeVarintDa(dAtA, i, uint64(len(m.BatchRoot)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BatchSize != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalFrames != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.TotalFrames))
		i--
		dAtA[i] = 0x18
	}
	if m.MsgIndex != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.MsgIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintDa(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CCState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CCState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CCState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.L1Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Height))
		i--
		dAtA[i] = 0x30
	}
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintDa(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x2a
	if m.NextQueueIndex != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.NextQueueIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.ProcessedQueueIndex != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.ProcessedQueueIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Base != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Base))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCCBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCCBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCCBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IntermediateStateRoots) > 0 {
		for iNdEx := len(m.IntermediateStateRoots) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IntermediateStateRoots[iNdEx])
			copy(dAtA[i:], m.IntermediateStateRoots[iNdEx])
			i = encodeVarintDa(dAtA, i, uint64(len(m.IntermediateStateRoots[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.ShouldStartAtFrame != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.ShouldStartAtFrame))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCCRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCCRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCCRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IntermediateStateRoots) > 0 {
		for iNdEx := len(m.IntermediateStateRoots) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IntermediateStateRoots[iNdEx])
			copy(dAtA[i:], m.IntermediateStateRoots[iNdEx])
			i = encodeVarintDa(dAtA, i, uint64(len(m.IntermediateStateRoots[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.BatchRoot) > 0 {
		i -= len(m.BatchRoot)
		copy(dAtA[i:], m.BatchRoot)
		i = encodeVarintDa(dAtA, i, uint64(len(m.BatchRoot)))
		i--
		dAtA[i] = 0x22
	}
	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintDa(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x1a
	if m.BatchSize != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalFrames != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.TotalFrames))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SCCState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SCCState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SCCState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastSequencerSubmit, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSequencerSubmit):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintDa(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x1a
	if m.Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Base != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Base))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDa(dAtA []byte, offset int, v uint64) int {
	offset -= sovDa(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CCBatchHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovDa(uint64(l))
	if m.L2Height != 0 {
		n += 1 + sovDa(uint64(m.L2Height))
	}
	if m.L1Height != 0 {
		n += 1 + sovDa(uint64(m.L1Height))
	}
	return n
}

func (m *CCBatchElement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Txraw)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	if m.QueueIndex != 0 {
		n += 1 + sovDa(uint64(m.QueueIndex))
	}
	return n
}

func (m *CCBatchFrame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hedaer != nil {
		l = m.Hedaer.Size()
		n += 1 + l + sovDa(uint64(l))
	}
	if len(m.Elements) > 0 {
		for _, e := range m.Elements {
			l = e.Size()
			n += 1 + l + sovDa(uint64(l))
		}
	}
	return n
}

func (m *CCBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShouldStartAtFrame != 0 {
		n += 1 + sovDa(uint64(m.ShouldStartAtFrame))
	}
	if len(m.Frames) > 0 {
		for _, e := range m.Frames {
			l = e.Size()
			n += 1 + l + sovDa(uint64(l))
		}
	}
	return n
}

func (m *CompressedCCBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	if m.Compression != 0 {
		n += 1 + sovDa(uint64(m.Compression))
	}
	return n
}

func (m *L1ToL2Queue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovDa(uint64(l))
	if m.L1Height != 0 {
		n += 1 + sovDa(uint64(m.L1Height))
	}
	l = len(m.Txraw)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovDa(uint64(m.Status))
	}
	return n
}

func (m *CCRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	if m.MsgIndex != 0 {
		n += 1 + sovDa(uint64(m.MsgIndex))
	}
	if m.TotalFrames != 0 {
		n += 1 + sovDa(uint64(m.TotalFrames))
	}
	if m.BatchSize != 0 {
		n += 1 + sovDa(uint64(m.BatchSize))
	}
	l = len(m.BatchRoot)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	return n
}

func (m *CCState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != 0 {
		n += 1 + sovDa(uint64(m.Base))
	}
	if m.Height != 0 {
		n += 1 + sovDa(uint64(m.Height))
	}
	if m.ProcessedQueueIndex != 0 {
		n += 1 + sovDa(uint64(m.ProcessedQueueIndex))
	}
	if m.NextQueueIndex != 0 {
		n += 1 + sovDa(uint64(m.NextQueueIndex))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovDa(uint64(l))
	if m.L1Height != 0 {
		n += 1 + sovDa(uint64(m.L1Height))
	}
	return n
}

func (m *SCCBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShouldStartAtFrame != 0 {
		n += 1 + sovDa(uint64(m.ShouldStartAtFrame))
	}
	if len(m.IntermediateStateRoots) > 0 {
		for _, b := range m.IntermediateStateRoots {
			l = len(b)
			n += 1 + l + sovDa(uint64(l))
		}
	}
	return n
}

func (m *SCCRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalFrames != 0 {
		n += 1 + sovDa(uint64(m.TotalFrames))
	}
	if m.BatchSize != 0 {
		n += 1 + sovDa(uint64(m.BatchSize))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovDa(uint64(l))
	l = len(m.BatchRoot)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	if len(m.IntermediateStateRoots) > 0 {
		for _, b := range m.IntermediateStateRoots {
			l = len(b)
			n += 1 + l + sovDa(uint64(l))
		}
	}
	return n
}

func (m *SCCState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != 0 {
		n += 1 + sovDa(uint64(m.Base))
	}
	if m.Height != 0 {
		n += 1 + sovDa(uint64(m.Height))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastSequencerSubmit)
	n += 1 + l + sovDa(uint64(l))
	return n
}

func sovDa(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDa(x uint64) (n int) {
	return sovDa(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CCBatchHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCBatchHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCBatchHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = append(m.ParentHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentHash == nil {
				m.ParentHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2Height", wireType)
			}
			m.L2Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L2Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Height", wireType)
			}
			m.L1Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCBatchElement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCBatchElement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCBatchElement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txraw", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txraw = append(m.Txraw[:0], dAtA[iNdEx:postIndex]...)
			if m.Txraw == nil {
				m.Txraw = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueIndex", wireType)
			}
			m.QueueIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCBatchFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCBatchFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCBatchFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hedaer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hedaer == nil {
				m.Hedaer = &CCBatchHeader{}
			}
			if err := m.Hedaer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elements = append(m.Elements, &CCBatchElement{})
			if err := m.Elements[len(m.Elements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShouldStartAtFrame", wireType)
			}
			m.ShouldStartAtFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShouldStartAtFrame |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frames", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Frames = append(m.Frames, &CCBatchFrame{})
			if err := m.Frames[len(m.Frames)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompressedCCBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompressedCCBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompressedCCBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compression", wireType)
			}
			m.Compression = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Compression |= CompressionOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L1ToL2Queue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L1toL2Queue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L1toL2Queue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Height", wireType)
			}
			m.L1Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txraw", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txraw = append(m.Txraw[:0], dAtA[iNdEx:postIndex]...)
			if m.Txraw == nil {
				m.Txraw = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= QueueTxStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIndex", wireType)
			}
			m.MsgIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFrames", wireType)
			}
			m.TotalFrames = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFrames |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchRoot = append(m.BatchRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.BatchRoot == nil {
				m.BatchRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CCState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CCState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CCState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			m.Base = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Base |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessedQueueIndex", wireType)
			}
			m.ProcessedQueueIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessedQueueIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextQueueIndex", wireType)
			}
			m.NextQueueIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextQueueIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Height", wireType)
			}
			m.L1Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCCBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCCBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCCBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShouldStartAtFrame", wireType)
			}
			m.ShouldStartAtFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShouldStartAtFrame |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntermediateStateRoots", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntermediateStateRoots = append(m.IntermediateStateRoots, make([]byte, postIndex-iNdEx))
			copy(m.IntermediateStateRoots[len(m.IntermediateStateRoots)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCCRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCCRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCCRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFrames", wireType)
			}
			m.TotalFrames = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFrames |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchRoot = append(m.BatchRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.BatchRoot == nil {
				m.BatchRoot = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntermediateStateRoots", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntermediateStateRoots = append(m.IntermediateStateRoots, make([]byte, postIndex-iNdEx))
			copy(m.IntermediateStateRoots[len(m.IntermediateStateRoots)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SCCState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SCCState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SCCState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			m.Base = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Base |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSequencerSubmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastSequencerSubmit, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDa(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDa
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDa
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDa
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDa
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDa        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDa          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDa = fmt.Errorf("proto: unexpected end of group")
)
