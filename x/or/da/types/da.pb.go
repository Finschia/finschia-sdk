// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: finschia/or/da/v1beta1/da.proto

package types

import (
	fmt "fmt"
	github_com_Finschia_finschia_sdk_types "github.com/Finschia/finschia-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CompressionOption int32

const (
	// COMPRESSION_OPTION_UNSPECIFIED defines a no-op compress option.
	OptionEmpty CompressionOption = 0
	// Zstandard is a fast compression algorithm, providing high compression ratios.
	// It also offers a special mode for small data, called dictionary compression.
	OptionZSTD CompressionOption = 1
)

var CompressionOption_name = map[int32]string{
	0: "COMPRESSION_OPTION_UNSPECIFIED",
	1: "COMPRESSION_OPTION_ZSTD",
}

var CompressionOption_value = map[string]int32{
	"COMPRESSION_OPTION_UNSPECIFIED": 0,
	"COMPRESSION_OPTION_ZSTD":        1,
}

func (x CompressionOption) String() string {
	return proto.EnumName(CompressionOption_name, int32(x))
}

func (CompressionOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b53f9b921c4114f3, []int{0}
}

// BatchContext denotes a range of transactions that belong the same batch.
// It is used to compress shared fields that would otherwise be repeated for each transaction.
type BatchContext struct {
	// num_sequenced_txs specifies the number of sequencer txs included in
	// the batch.
	NumSequencedTxs uint64 `protobuf:"varint,1,opt,name=num_sequenced_txs,json=numSequencedTxs,proto3" json:"num_sequenced_txs,omitempty"`
	// num_subsequent_queue_txs specifies the number of queued txs included in
	// the batch
	NumSubsequentQueueTxs uint64 `protobuf:"varint,2,opt,name=num_subsequent_queue_txs,json=numSubsequentQueueTxs,proto3" json:"num_subsequent_queue_txs,omitempty"`
	// timestamp is the L1 unix timestamp of the batch.
	L1Timestamp int64 `protobuf:"varint,3,opt,name=l1_timestamp,json=l1Timestamp,proto3" json:"l1_timestamp,omitempty"`
	// blockNumber is the L1 BlockNumber of the batch.
	L1Height int64 `protobuf:"varint,4,opt,name=l1_height,json=l1Height,proto3" json:"l1_height,omitempty"`
}

func (m *BatchContext) Reset()         { *m = BatchContext{} }
func (m *BatchContext) String() string { return proto.CompactTextString(m) }
func (*BatchContext) ProtoMessage()    {}
func (*BatchContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_b53f9b921c4114f3, []int{0}
}
func (m *BatchContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchContext.Merge(m, src)
}
func (m *BatchContext) XXX_Size() int {
	return m.Size()
}
func (m *BatchContext) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchContext.DiscardUnknown(m)
}

var xxx_messageInfo_BatchContext proto.InternalMessageInfo

func (m *BatchContext) GetNumSequencedTxs() uint64 {
	if m != nil {
		return m.NumSequencedTxs
	}
	return 0
}

func (m *BatchContext) GetNumSubsequentQueueTxs() uint64 {
	if m != nil {
		return m.NumSubsequentQueueTxs
	}
	return 0
}

func (m *BatchContext) GetL1Timestamp() int64 {
	if m != nil {
		return m.L1Timestamp
	}
	return 0
}

func (m *BatchContext) GetL1Height() int64 {
	if m != nil {
		return m.L1Height
	}
	return 0
}

type BatchElement struct {
	IsSequenced bool `protobuf:"varint,1,opt,name=is_sequenced,json=isSequenced,proto3" json:"is_sequenced,omitempty"`
	// timestamp is the L1 unix timestamp of the batch.
	// SEQUENCER TX ONLY
	L1Timestamp int64 `protobuf:"varint,2,opt,name=l1_timestamp,json=l1Timestamp,proto3" json:"l1_timestamp,omitempty"`
	// blockNumber is the L1 BlockNumber of the batch.
	// SEQUENCER TX ONLY
	L1Height int64 `protobuf:"varint,3,opt,name=l1_height,json=l1Height,proto3" json:"l1_height,omitempty"`
	// SEQUENCER TX ONLY
	Txraw []byte `protobuf:"bytes,4,opt,name=txraw,proto3" json:"txraw,omitempty"`
	// QUEUED TX ONLY
	QueueIndex uint64 `protobuf:"varint,5,opt,name=queue_index,json=queueIndex,proto3" json:"queue_index,omitempty"`
}

func (m *BatchElement) Reset()         { *m = BatchElement{} }
func (m *BatchElement) String() string { return proto.CompactTextString(m) }
func (*BatchElement) ProtoMessage()    {}
func (*BatchElement) Descriptor() ([]byte, []int) {
	return fileDescriptor_b53f9b921c4114f3, []int{1}
}
func (m *BatchElement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchElement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchElement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchElement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchElement.Merge(m, src)
}
func (m *BatchElement) XXX_Size() int {
	return m.Size()
}
func (m *BatchElement) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchElement.DiscardUnknown(m)
}

var xxx_messageInfo_BatchElement proto.InternalMessageInfo

func (m *BatchElement) GetIsSequenced() bool {
	if m != nil {
		return m.IsSequenced
	}
	return false
}

func (m *BatchElement) GetL1Timestamp() int64 {
	if m != nil {
		return m.L1Timestamp
	}
	return 0
}

func (m *BatchElement) GetL1Height() int64 {
	if m != nil {
		return m.L1Height
	}
	return 0
}

func (m *BatchElement) GetTxraw() []byte {
	if m != nil {
		return m.Txraw
	}
	return nil
}

func (m *BatchElement) GetQueueIndex() uint64 {
	if m != nil {
		return m.QueueIndex
	}
	return 0
}

// Sequencer use CTCBatch when they submit
type CTCBatch struct {
	//  total_elements_to_append is the number of txs to add in batch
	TotalElementsToAppend uint64 `protobuf:"varint,1,opt,name=total_elements_to_append,json=totalElementsToAppend,proto3" json:"total_elements_to_append,omitempty"`
	// previous total batch elements.
	ShouldStartAtElement github_com_Finschia_finschia_sdk_types.Int `protobuf:"bytes,2,opt,name=should_start_at_element,json=shouldStartAtElement,proto3,customtype=github.com/Finschia/finschia-sdk/types.Int" json:"should_start_at_element"`
	BatchContexts        []*BatchContext                            `protobuf:"bytes,3,rep,name=batch_contexts,json=batchContexts,proto3" json:"batch_contexts,omitempty"`
	Elements             []*BatchElement                            `protobuf:"bytes,4,rep,name=elements,proto3" json:"elements,omitempty"`
}

func (m *CTCBatch) Reset()         { *m = CTCBatch{} }
func (m *CTCBatch) String() string { return proto.CompactTextString(m) }
func (*CTCBatch) ProtoMessage()    {}
func (*CTCBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_b53f9b921c4114f3, []int{2}
}
func (m *CTCBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CTCBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CTCBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CTCBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTCBatch.Merge(m, src)
}
func (m *CTCBatch) XXX_Size() int {
	return m.Size()
}
func (m *CTCBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_CTCBatch.DiscardUnknown(m)
}

var xxx_messageInfo_CTCBatch proto.InternalMessageInfo

func (m *CTCBatch) GetTotalElementsToAppend() uint64 {
	if m != nil {
		return m.TotalElementsToAppend
	}
	return 0
}

func (m *CTCBatch) GetBatchContexts() []*BatchContext {
	if m != nil {
		return m.BatchContexts
	}
	return nil
}

func (m *CTCBatch) GetElements() []*BatchElement {
	if m != nil {
		return m.Elements
	}
	return nil
}

// L1toL2Queue is a queued tx for L2 batch.
// Sequencer must process this transaction in time.
type L1ToL2Queue struct {
	// timestamp is the L1 unix timestamp of the batch.
	// It is set when the type of tx is L1toL2
	L1Timestamp int64 `protobuf:"varint,1,opt,name=l1_timestamp,json=l1Timestamp,proto3" json:"l1_timestamp,omitempty"`
	// blockNumber is the L1 BlockNumber of the batch.
	L1Height int64  `protobuf:"varint,2,opt,name=l1_height,json=l1Height,proto3" json:"l1_height,omitempty"`
	Txraw    []byte `protobuf:"bytes,3,opt,name=txraw,proto3" json:"txraw,omitempty"`
}

func (m *L1ToL2Queue) Reset()         { *m = L1ToL2Queue{} }
func (m *L1ToL2Queue) String() string { return proto.CompactTextString(m) }
func (*L1ToL2Queue) ProtoMessage()    {}
func (*L1ToL2Queue) Descriptor() ([]byte, []int) {
	return fileDescriptor_b53f9b921c4114f3, []int{3}
}
func (m *L1ToL2Queue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L1ToL2Queue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L1ToL2Queue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L1ToL2Queue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L1ToL2Queue.Merge(m, src)
}
func (m *L1ToL2Queue) XXX_Size() int {
	return m.Size()
}
func (m *L1ToL2Queue) XXX_DiscardUnknown() {
	xxx_messageInfo_L1ToL2Queue.DiscardUnknown(m)
}

var xxx_messageInfo_L1ToL2Queue proto.InternalMessageInfo

func (m *L1ToL2Queue) GetL1Timestamp() int64 {
	if m != nil {
		return m.L1Timestamp
	}
	return 0
}

func (m *L1ToL2Queue) GetL1Height() int64 {
	if m != nil {
		return m.L1Height
	}
	return 0
}

func (m *L1ToL2Queue) GetTxraw() []byte {
	if m != nil {
		return m.Txraw
	}
	return nil
}

type CTCMetadata struct {
	// Assumed to contain all contiguous batches between base and height (inclusive)
	Base       uint64 `protobuf:"varint,1,opt,name=base,proto3" json:"base,omitempty"`
	Height     uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	PruningPtr uint64 `protobuf:"varint,3,opt,name=pruning_ptr,json=pruningPtr,proto3" json:"pruning_ptr,omitempty"`
}

func (m *CTCMetadata) Reset()         { *m = CTCMetadata{} }
func (m *CTCMetadata) String() string { return proto.CompactTextString(m) }
func (*CTCMetadata) ProtoMessage()    {}
func (*CTCMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_b53f9b921c4114f3, []int{4}
}
func (m *CTCMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CTCMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CTCMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CTCMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTCMetadata.Merge(m, src)
}
func (m *CTCMetadata) XXX_Size() int {
	return m.Size()
}
func (m *CTCMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_CTCMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_CTCMetadata proto.InternalMessageInfo

func (m *CTCMetadata) GetBase() uint64 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *CTCMetadata) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *CTCMetadata) GetPruningPtr() uint64 {
	if m != nil {
		return m.PruningPtr
	}
	return 0
}

// CTCRef is a data type that forms an element of Canonical Transaction Chain.
type CTC struct {
	// Hash value of current batch header
	BatchHash []byte `protobuf:"bytes,1,opt,name=batch_hash,json=batchHash,proto3" json:"batch_hash,omitempty"`
	// Total number of elements submitted.
	TotalElements github_com_Finschia_finschia_sdk_types.Int `protobuf:"bytes,2,opt,name=total_elements,json=totalElements,proto3,customtype=github.com/Finschia/finschia-sdk/types.Int" json:"total_elements"`
	// Index of the next queue element.
	NextQueueIndex uint64 `protobuf:"varint,3,opt,name=next_queue_index,json=nextQueueIndex,proto3" json:"next_queue_index,omitempty"`
	// The latest batch timestamp.
	Timestamp int64 `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The latest batch blockNumber
	BlockNumber int64 `protobuf:"varint,5,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// Reference for accessing CTC batch data.
	BatchRef *CTCRef `protobuf:"bytes,6,opt,name=batch_ref,json=batchRef,proto3" json:"batch_ref,omitempty"`
}

func (m *CTC) Reset()         { *m = CTC{} }
func (m *CTC) String() string { return proto.CompactTextString(m) }
func (*CTC) ProtoMessage()    {}
func (*CTC) Descriptor() ([]byte, []int) {
	return fileDescriptor_b53f9b921c4114f3, []int{5}
}
func (m *CTC) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CTC) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CTC.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CTC) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTC.Merge(m, src)
}
func (m *CTC) XXX_Size() int {
	return m.Size()
}
func (m *CTC) XXX_DiscardUnknown() {
	xxx_messageInfo_CTC.DiscardUnknown(m)
}

var xxx_messageInfo_CTC proto.InternalMessageInfo

func (m *CTC) GetBatchHash() []byte {
	if m != nil {
		return m.BatchHash
	}
	return nil
}

func (m *CTC) GetNextQueueIndex() uint64 {
	if m != nil {
		return m.NextQueueIndex
	}
	return 0
}

func (m *CTC) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *CTC) GetBlockNumber() int64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *CTC) GetBatchRef() *CTCRef {
	if m != nil {
		return m.BatchRef
	}
	return nil
}

type CTCRef struct {
	TxHash   []byte `protobuf:"bytes,1,opt,name=txhash,proto3" json:"txhash,omitempty"`
	MsgIndex int64  `protobuf:"varint,2,opt,name=msg_index,json=msgIndex,proto3" json:"msg_index,omitempty"`
}

func (m *CTCRef) Reset()         { *m = CTCRef{} }
func (m *CTCRef) String() string { return proto.CompactTextString(m) }
func (*CTCRef) ProtoMessage()    {}
func (*CTCRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_b53f9b921c4114f3, []int{6}
}
func (m *CTCRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CTCRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CTCRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CTCRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTCRef.Merge(m, src)
}
func (m *CTCRef) XXX_Size() int {
	return m.Size()
}
func (m *CTCRef) XXX_DiscardUnknown() {
	xxx_messageInfo_CTCRef.DiscardUnknown(m)
}

var xxx_messageInfo_CTCRef proto.InternalMessageInfo

func (m *CTCRef) GetTxHash() []byte {
	if m != nil {
		return m.TxHash
	}
	return nil
}

func (m *CTCRef) GetMsgIndex() int64 {
	if m != nil {
		return m.MsgIndex
	}
	return 0
}

func init() {
	proto.RegisterEnum("finschia.or.da.v1beta1.CompressionOption", CompressionOption_name, CompressionOption_value)
	proto.RegisterType((*BatchContext)(nil), "finschia.or.da.v1beta1.BatchContext")
	proto.RegisterType((*BatchElement)(nil), "finschia.or.da.v1beta1.BatchElement")
	proto.RegisterType((*CTCBatch)(nil), "finschia.or.da.v1beta1.CTCBatch")
	proto.RegisterType((*L1ToL2Queue)(nil), "finschia.or.da.v1beta1.L1toL2Queue")
	proto.RegisterType((*CTCMetadata)(nil), "finschia.or.da.v1beta1.CTCMetadata")
	proto.RegisterType((*CTC)(nil), "finschia.or.da.v1beta1.CTC")
	proto.RegisterType((*CTCRef)(nil), "finschia.or.da.v1beta1.CTCRef")
}

func init() { proto.RegisterFile("finschia/or/da/v1beta1/da.proto", fileDescriptor_b53f9b921c4114f3) }

var fileDescriptor_b53f9b921c4114f3 = []byte{
	// 813 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0x3d, 0x6f, 0xdb, 0x46,
	0x18, 0x16, 0x25, 0x45, 0x90, 0x5f, 0x3a, 0x8e, 0x73, 0x70, 0x12, 0x41, 0x6d, 0x29, 0x55, 0xed,
	0x20, 0xb8, 0x28, 0x05, 0x39, 0x43, 0x87, 0x2e, 0x8d, 0x19, 0x05, 0x16, 0x9a, 0xd8, 0xce, 0x89,
	0x1d, 0xea, 0x85, 0x38, 0x8a, 0x67, 0x91, 0x08, 0xc9, 0x63, 0x78, 0xc7, 0x96, 0x41, 0xff, 0x40,
	0x91, 0xa9, 0x7f, 0x20, 0x53, 0x87, 0x76, 0xef, 0xdc, 0x3d, 0x63, 0xc6, 0xa2, 0x83, 0x51, 0xd8,
	0x7f, 0xa4, 0xb8, 0x3b, 0xd2, 0x1f, 0x48, 0x0c, 0x17, 0xe8, 0x44, 0xde, 0xf3, 0x7e, 0xdc, 0xf3,
	0xbe, 0xcf, 0x43, 0xc2, 0xe0, 0x38, 0x4a, 0xf9, 0x32, 0x8c, 0xc8, 0x84, 0xe5, 0x93, 0x80, 0x4c,
	0x7e, 0x98, 0xfa, 0x54, 0x90, 0xe9, 0x24, 0x20, 0x76, 0x96, 0x33, 0xc1, 0xd0, 0xfd, 0x3a, 0xc1,
	0x66, 0xb9, 0x1d, 0x10, 0xbb, 0x4a, 0xe8, 0x6f, 0xad, 0xd8, 0x8a, 0xa9, 0x94, 0x89, 0x7c, 0xd3,
	0xd9, 0xfd, 0xcf, 0xae, 0x69, 0x97, 0x91, 0x9c, 0x24, 0x5c, 0x27, 0x8d, 0xfe, 0x30, 0x60, 0x7d,
	0x97, 0x88, 0x65, 0xe8, 0xb0, 0x54, 0xd0, 0x52, 0xa0, 0x6d, 0xb8, 0x9b, 0x16, 0x89, 0xc7, 0xe9,
	0xcb, 0x82, 0xa6, 0x4b, 0x1a, 0x78, 0xa2, 0xe4, 0x3d, 0x63, 0x68, 0x8c, 0xdb, 0xf8, 0x4e, 0x5a,
	0x24, 0x8b, 0x1a, 0x77, 0x4b, 0x8e, 0xbe, 0x82, 0x9e, 0xca, 0x2d, 0x7c, 0x9d, 0x2e, 0xbc, 0x97,
	0x05, 0x2d, 0xa8, 0x2a, 0x69, 0xaa, 0x92, 0x7b, 0xb2, 0xe4, 0x3c, 0xfc, 0x5c, 0x46, 0x65, 0xe1,
	0xa7, 0xb0, 0x1e, 0x4f, 0x3d, 0x11, 0x25, 0x94, 0x0b, 0x92, 0x64, 0xbd, 0xd6, 0xd0, 0x18, 0xb7,
	0xb0, 0x19, 0x4f, 0xdd, 0x1a, 0x42, 0x1f, 0xc1, 0x5a, 0x3c, 0xf5, 0x42, 0x1a, 0xad, 0x42, 0xd1,
	0x6b, 0xab, 0x78, 0x37, 0x9e, 0xee, 0xa9, 0xf3, 0xe8, 0xf7, 0x9a, 0xf5, 0x2c, 0xa6, 0x09, 0x4d,
	0x85, 0x6c, 0x18, 0xf1, 0x0b, 0xd2, 0x8a, 0x70, 0x17, 0x9b, 0x11, 0x3f, 0xe7, 0xfb, 0xde, 0x9d,
	0xcd, 0x1b, 0xee, 0x6c, 0x5d, 0xbd, 0x13, 0x6d, 0xc1, 0x2d, 0x51, 0xe6, 0xe4, 0x47, 0x45, 0x66,
	0x1d, 0xeb, 0x03, 0x1a, 0x80, 0xa9, 0x67, 0x8e, 0xd2, 0x80, 0x96, 0xbd, 0x5b, 0x6a, 0x6a, 0x50,
	0xd0, 0x5c, 0x22, 0xa3, 0x3f, 0x9b, 0xd0, 0x75, 0x5c, 0x47, 0xb1, 0x95, 0x0b, 0x13, 0x4c, 0x90,
	0xd8, 0xa3, 0x9a, 0x37, 0xf7, 0x04, 0xf3, 0x48, 0x96, 0xd1, 0x34, 0xa8, 0x76, 0x7c, 0x4f, 0xc5,
	0xab, 0xb1, 0xb8, 0xcb, 0x1e, 0xa9, 0x20, 0x8a, 0xe0, 0x01, 0x0f, 0x59, 0x11, 0x07, 0x1e, 0x17,
	0x24, 0x17, 0x1e, 0x11, 0x75, 0x0b, 0x35, 0xc7, 0xda, 0xee, 0xce, 0xdb, 0x93, 0x41, 0xe3, 0xef,
	0x93, 0xc1, 0xf6, 0x2a, 0x12, 0x61, 0xe1, 0xdb, 0x4b, 0x96, 0x4c, 0x9e, 0xd4, 0xfa, 0xd7, 0x46,
	0xf8, 0x92, 0x07, 0x2f, 0x26, 0xe2, 0x55, 0x46, 0xb9, 0x3d, 0x4f, 0x05, 0xde, 0xd2, 0x2d, 0x17,
	0xb2, 0xe3, 0x23, 0x51, 0xaf, 0xf2, 0x5b, 0xd8, 0xf0, 0x25, 0x59, 0x6f, 0xa9, 0x1d, 0xc1, 0x7b,
	0xad, 0x61, 0x6b, 0x6c, 0xee, 0x7c, 0x6e, 0x7f, 0xd8, 0x7d, 0xf6, 0x65, 0xfb, 0xe0, 0xdb, 0xfe,
	0xa5, 0x13, 0x47, 0xdf, 0x40, 0xb7, 0x1e, 0xb5, 0xd7, 0xfe, 0x0f, 0x6d, 0x2a, 0x12, 0xf8, 0xbc,
	0x6a, 0xb4, 0x04, 0xf3, 0xe9, 0x54, 0xb0, 0xa7, 0x3b, 0xca, 0x3c, 0xef, 0xa9, 0x68, 0xdc, 0xa0,
	0x62, 0xf3, 0x3a, 0x15, 0x5b, 0x97, 0x54, 0x1c, 0x1d, 0x81, 0xe9, 0xb8, 0xce, 0x33, 0x2a, 0x48,
	0x40, 0x04, 0x41, 0x08, 0xda, 0x3e, 0xe1, 0xb4, 0x92, 0x44, 0xbd, 0xa3, 0xfb, 0xd0, 0xb9, 0xd4,
	0xb2, 0x8d, 0xab, 0x93, 0x34, 0x40, 0x96, 0x17, 0x69, 0x94, 0xae, 0xbc, 0x4c, 0xe4, 0xaa, 0x6d,
	0x1b, 0x43, 0x05, 0x1d, 0x8a, 0x7c, 0xf4, 0x5b, 0x13, 0x5a, 0x8e, 0xeb, 0xa0, 0x4f, 0x00, 0xf4,
	0x5e, 0x43, 0xc2, 0x43, 0xd5, 0x7a, 0x1d, 0xaf, 0x29, 0x64, 0x8f, 0xf0, 0x10, 0x7d, 0x0f, 0x1b,
	0x57, 0xad, 0xf1, 0x3f, 0x84, 0xbd, 0x7d, 0xc5, 0x44, 0x68, 0x0c, 0x9b, 0x29, 0x2d, 0xeb, 0x8f,
	0x53, 0x1b, 0x55, 0xf3, 0xdc, 0x90, 0xf8, 0xf3, 0x73, 0xb3, 0xa2, 0x8f, 0x61, 0xed, 0x62, 0xb5,
	0xfa, 0xa3, 0xbb, 0x00, 0xe4, 0xee, 0xfd, 0x98, 0x2d, 0x5f, 0x78, 0x69, 0x91, 0xf8, 0x34, 0x57,
	0x66, 0x6f, 0x61, 0x53, 0x61, 0xfb, 0x0a, 0x42, 0x5f, 0x83, 0x1e, 0xc9, 0xcb, 0xe9, 0x71, 0xaf,
	0x33, 0x34, 0xc6, 0xe6, 0x8e, 0x75, 0x9d, 0xe0, 0x8e, 0xeb, 0x60, 0x7a, 0x8c, 0xbb, 0xaa, 0x00,
	0xd3, 0xe3, 0xd1, 0x1c, 0x3a, 0x1a, 0x43, 0x23, 0xe8, 0x88, 0xf2, 0x62, 0x4f, 0xbb, 0x70, 0x7a,
	0x32, 0xe8, 0xb8, 0xa5, 0x5c, 0x14, 0xae, 0x22, 0x52, 0xe6, 0x84, 0xaf, 0xaa, 0x71, 0x2a, 0x99,
	0x13, 0xbe, 0x52, 0x83, 0x6c, 0xff, 0x04, 0x77, 0x1d, 0x96, 0x64, 0x39, 0xe5, 0x3c, 0x62, 0xe9,
	0x41, 0x26, 0x22, 0x96, 0xa2, 0x87, 0x60, 0x39, 0x07, 0xcf, 0x0e, 0xf1, 0x6c, 0xb1, 0x98, 0x1f,
	0xec, 0x7b, 0x07, 0x87, 0xae, 0x7c, 0x7c, 0xb7, 0xbf, 0x38, 0x9c, 0x39, 0xf3, 0x27, 0xf3, 0xd9,
	0xe3, 0xcd, 0x46, 0xff, 0xce, 0xeb, 0x37, 0x43, 0x53, 0xe7, 0xcf, 0x92, 0x4c, 0xbc, 0x42, 0x5f,
	0xc0, 0x83, 0x0f, 0x14, 0x1d, 0x2d, 0xdc, 0xc7, 0x9b, 0x46, 0x7f, 0xe3, 0xf5, 0x9b, 0x21, 0xe8,
	0x6c, 0x89, 0xf4, 0xdb, 0x3f, 0xff, 0x6a, 0x35, 0x76, 0xf7, 0xde, 0x9e, 0x5a, 0xc6, 0xbb, 0x53,
	0xcb, 0xf8, 0xe7, 0xd4, 0x32, 0x7e, 0x39, 0xb3, 0x1a, 0xef, 0xce, 0xac, 0xc6, 0x5f, 0x67, 0x56,
	0xe3, 0xc8, 0xbe, 0x51, 0xc4, 0xb2, 0xfa, 0x59, 0x2b, 0x31, 0xfd, 0x8e, 0xfa, 0x49, 0x3f, 0xfc,
	0x37, 0x00, 0x00, 0xff, 0xff, 0x03, 0x8f, 0x81, 0x19, 0x1a, 0x06, 0x00, 0x00,
}

func (m *BatchContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.L1Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Height))
		i--
		dAtA[i] = 0x20
	}
	if m.L1Timestamp != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if m.NumSubsequentQueueTxs != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.NumSubsequentQueueTxs))
		i--
		dAtA[i] = 0x10
	}
	if m.NumSequencedTxs != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.NumSequencedTxs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchElement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchElement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchElement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QueueIndex != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.QueueIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Txraw) > 0 {
		i -= len(m.Txraw)
		copy(dAtA[i:], m.Txraw)
		i = encodeVarintDa(dAtA, i, uint64(len(m.Txraw)))
		i--
		dAtA[i] = 0x22
	}
	if m.L1Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Height))
		i--
		dAtA[i] = 0x18
	}
	if m.L1Timestamp != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if m.IsSequenced {
		i--
		if m.IsSequenced {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CTCBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTCBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CTCBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Elements) > 0 {
		for iNdEx := len(m.Elements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Elements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.BatchContexts) > 0 {
		for iNdEx := len(m.BatchContexts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BatchContexts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDa(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.ShouldStartAtElement.Size()
		i -= size
		if _, err := m.ShouldStartAtElement.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.TotalElementsToAppend != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.TotalElementsToAppend))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L1ToL2Queue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L1ToL2Queue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L1ToL2Queue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Txraw) > 0 {
		i -= len(m.Txraw)
		copy(dAtA[i:], m.Txraw)
		i = encodeVarintDa(dAtA, i, uint64(len(m.Txraw)))
		i--
		dAtA[i] = 0x1a
	}
	if m.L1Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Height))
		i--
		dAtA[i] = 0x10
	}
	if m.L1Timestamp != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.L1Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CTCMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTCMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CTCMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PruningPtr != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.PruningPtr))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Base != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Base))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CTC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTC) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CTC) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BatchRef != nil {
		{
			size, err := m.BatchRef.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDa(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.BlockNumber != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x28
	}
	if m.Timestamp != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.NextQueueIndex != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.NextQueueIndex))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.TotalElements.Size()
		i -= size
		if _, err := m.TotalElements.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintDa(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.BatchHash) > 0 {
		i -= len(m.BatchHash)
		copy(dAtA[i:], m.BatchHash)
		i = encodeVarintDa(dAtA, i, uint64(len(m.BatchHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CTCRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CTCRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CTCRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MsgIndex != 0 {
		i = encodeVarintDa(dAtA, i, uint64(m.MsgIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintDa(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDa(dAtA []byte, offset int, v uint64) int {
	offset -= sovDa(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BatchContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumSequencedTxs != 0 {
		n += 1 + sovDa(uint64(m.NumSequencedTxs))
	}
	if m.NumSubsequentQueueTxs != 0 {
		n += 1 + sovDa(uint64(m.NumSubsequentQueueTxs))
	}
	if m.L1Timestamp != 0 {
		n += 1 + sovDa(uint64(m.L1Timestamp))
	}
	if m.L1Height != 0 {
		n += 1 + sovDa(uint64(m.L1Height))
	}
	return n
}

func (m *BatchElement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsSequenced {
		n += 2
	}
	if m.L1Timestamp != 0 {
		n += 1 + sovDa(uint64(m.L1Timestamp))
	}
	if m.L1Height != 0 {
		n += 1 + sovDa(uint64(m.L1Height))
	}
	l = len(m.Txraw)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	if m.QueueIndex != 0 {
		n += 1 + sovDa(uint64(m.QueueIndex))
	}
	return n
}

func (m *CTCBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalElementsToAppend != 0 {
		n += 1 + sovDa(uint64(m.TotalElementsToAppend))
	}
	l = m.ShouldStartAtElement.Size()
	n += 1 + l + sovDa(uint64(l))
	if len(m.BatchContexts) > 0 {
		for _, e := range m.BatchContexts {
			l = e.Size()
			n += 1 + l + sovDa(uint64(l))
		}
	}
	if len(m.Elements) > 0 {
		for _, e := range m.Elements {
			l = e.Size()
			n += 1 + l + sovDa(uint64(l))
		}
	}
	return n
}

func (m *L1ToL2Queue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L1Timestamp != 0 {
		n += 1 + sovDa(uint64(m.L1Timestamp))
	}
	if m.L1Height != 0 {
		n += 1 + sovDa(uint64(m.L1Height))
	}
	l = len(m.Txraw)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	return n
}

func (m *CTCMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != 0 {
		n += 1 + sovDa(uint64(m.Base))
	}
	if m.Height != 0 {
		n += 1 + sovDa(uint64(m.Height))
	}
	if m.PruningPtr != 0 {
		n += 1 + sovDa(uint64(m.PruningPtr))
	}
	return n
}

func (m *CTC) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchHash)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	l = m.TotalElements.Size()
	n += 1 + l + sovDa(uint64(l))
	if m.NextQueueIndex != 0 {
		n += 1 + sovDa(uint64(m.NextQueueIndex))
	}
	if m.Timestamp != 0 {
		n += 1 + sovDa(uint64(m.Timestamp))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovDa(uint64(m.BlockNumber))
	}
	if m.BatchRef != nil {
		l = m.BatchRef.Size()
		n += 1 + l + sovDa(uint64(l))
	}
	return n
}

func (m *CTCRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovDa(uint64(l))
	}
	if m.MsgIndex != 0 {
		n += 1 + sovDa(uint64(m.MsgIndex))
	}
	return n
}

func sovDa(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDa(x uint64) (n int) {
	return sovDa(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BatchContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSequencedTxs", wireType)
			}
			m.NumSequencedTxs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSequencedTxs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSubsequentQueueTxs", wireType)
			}
			m.NumSubsequentQueueTxs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSubsequentQueueTxs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Timestamp", wireType)
			}
			m.L1Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Height", wireType)
			}
			m.L1Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchElement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchElement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchElement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSequenced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSequenced = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Timestamp", wireType)
			}
			m.L1Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Height", wireType)
			}
			m.L1Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txraw", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txraw = append(m.Txraw[:0], dAtA[iNdEx:postIndex]...)
			if m.Txraw == nil {
				m.Txraw = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueIndex", wireType)
			}
			m.QueueIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueueIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTCBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTCBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTCBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalElementsToAppend", wireType)
			}
			m.TotalElementsToAppend = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalElementsToAppend |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShouldStartAtElement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShouldStartAtElement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchContexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchContexts = append(m.BatchContexts, &BatchContext{})
			if err := m.BatchContexts[len(m.BatchContexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elements = append(m.Elements, &BatchElement{})
			if err := m.Elements[len(m.Elements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L1ToL2Queue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L1toL2Queue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L1toL2Queue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Timestamp", wireType)
			}
			m.L1Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field L1Height", wireType)
			}
			m.L1Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.L1Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txraw", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txraw = append(m.Txraw[:0], dAtA[iNdEx:postIndex]...)
			if m.Txraw == nil {
				m.Txraw = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTCMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTCMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTCMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			m.Base = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Base |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PruningPtr", wireType)
			}
			m.PruningPtr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PruningPtr |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchHash = append(m.BatchHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BatchHash == nil {
				m.BatchHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalElements", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalElements.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextQueueIndex", wireType)
			}
			m.NextQueueIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextQueueIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BatchRef == nil {
				m.BatchRef = &CTCRef{}
			}
			if err := m.BatchRef.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CTCRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDa
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CTCRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CTCRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDa
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDa
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIndex", wireType)
			}
			m.MsgIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDa
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgIndex |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDa(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDa
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDa(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDa
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDa
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDa
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDa
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDa
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDa        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDa          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDa = fmt.Errorf("proto: unexpected end of group")
)
