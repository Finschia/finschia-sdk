// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lbm/fbridge/v1/fbridge.proto

package types

import (
	fmt "fmt"
	github_com_Finschia_finschia_sdk_types "github.com/Finschia/finschia-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Role defines the role of the operator, guardian, and judge.
type Role int32

const (
	Role_UNSPECIFIED Role = 0
	Role_GUARDIAN    Role = 1
	Role_OPERATOR    Role = 2
	Role_JUDGE       Role = 3
)

var Role_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "GUARDIAN",
	2: "OPERATOR",
	3: "JUDGE",
}

var Role_value = map[string]int32{
	"UNSPECIFIED": 0,
	"GUARDIAN":    1,
	"OPERATOR":    2,
	"JUDGE":       3,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}

func (Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{0}
}

type Params struct {
	// ratio of how many operators' confirmations are needed to be valid.
	OperatorTrustLevel Fraction `protobuf:"bytes,1,opt,name=operator_trust_level,json=operatorTrustLevel,proto3" json:"operator_trust_level"`
	// ratio of how many guardians' confirmations are needed to be valid.
	GuardianTrustLevel Fraction `protobuf:"bytes,2,opt,name=guardian_trust_level,json=guardianTrustLevel,proto3" json:"guardian_trust_level"`
	// ratio of how many judges' confirmations are needed to be valid.
	JudgeTrustLevel Fraction `protobuf:"bytes,3,opt,name=judge_trust_level,json=judgeTrustLevel,proto3" json:"judge_trust_level"`
	// default timelock period for each provision (unix timestamp)
	TimelockPeriod uint64 `protobuf:"varint,4,opt,name=timelock_period,json=timelockPeriod,proto3" json:"timelock_period,omitempty"`
	// default period of the proposal to update the role
	ProposalPeriod uint64 `protobuf:"varint,5,opt,name=proposal_period,json=proposalPeriod,proto3" json:"proposal_period,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetOperatorTrustLevel() Fraction {
	if m != nil {
		return m.OperatorTrustLevel
	}
	return Fraction{}
}

func (m *Params) GetGuardianTrustLevel() Fraction {
	if m != nil {
		return m.GuardianTrustLevel
	}
	return Fraction{}
}

func (m *Params) GetJudgeTrustLevel() Fraction {
	if m != nil {
		return m.JudgeTrustLevel
	}
	return Fraction{}
}

func (m *Params) GetTimelockPeriod() uint64 {
	if m != nil {
		return m.TimelockPeriod
	}
	return 0
}

func (m *Params) GetProposalPeriod() uint64 {
	if m != nil {
		return m.ProposalPeriod
	}
	return 0
}

// Provision is a struct that represents a provision internally.
type ProvisionData struct {
	// the sequence number of the bridge request
	Seq uint64 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	// the amount of token to be claimed
	Amount github_com_Finschia_finschia_sdk_types.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=github.com/Finschia/finschia-sdk/types.Int" json:"amount"`
	// the sender address on the source chain
	Sender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	// the recipient address on the destination chain
	Receiver string `protobuf:"bytes,4,opt,name=receiver,proto3" json:"receiver,omitempty"`
}

func (m *ProvisionData) Reset()         { *m = ProvisionData{} }
func (m *ProvisionData) String() string { return proto.CompactTextString(m) }
func (*ProvisionData) ProtoMessage()    {}
func (*ProvisionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{1}
}
func (m *ProvisionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionData.Merge(m, src)
}
func (m *ProvisionData) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionData) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionData.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionData proto.InternalMessageInfo

func (m *ProvisionData) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ProvisionData) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *ProvisionData) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

// ProvisionStatus is a struct that represents the status of a provision.
// To optimize computational cost, we have collected frequently changing values from provision.
type ProvisionStatus struct {
	// the unix timestamp the provision will be able to be claimed (unix timestamp)
	TimelockEnd uint64 `protobuf:"varint,1,opt,name=timelock_end,json=timelockEnd,proto3" json:"timelock_end,omitempty"`
	// a value that tells how many operators have submitted this provision
	ConfirmCounts int32 `protobuf:"varint,2,opt,name=confirm_counts,json=confirmCounts,proto3" json:"confirm_counts,omitempty"`
	// whether the provision has been claimed
	IsClaimed bool `protobuf:"varint,3,opt,name=is_claimed,json=isClaimed,proto3" json:"is_claimed,omitempty"`
}

func (m *ProvisionStatus) Reset()         { *m = ProvisionStatus{} }
func (m *ProvisionStatus) String() string { return proto.CompactTextString(m) }
func (*ProvisionStatus) ProtoMessage()    {}
func (*ProvisionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{2}
}
func (m *ProvisionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionStatus.Merge(m, src)
}
func (m *ProvisionStatus) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionStatus proto.InternalMessageInfo

func (m *ProvisionStatus) GetTimelockEnd() uint64 {
	if m != nil {
		return m.TimelockEnd
	}
	return 0
}

func (m *ProvisionStatus) GetConfirmCounts() int32 {
	if m != nil {
		return m.ConfirmCounts
	}
	return 0
}

func (m *ProvisionStatus) GetIsClaimed() bool {
	if m != nil {
		return m.IsClaimed
	}
	return false
}

// Fraction defines the protobuf message type for tmmath.Fraction that only
// supports positive values.
type Fraction struct {
	Numerator   uint64 `protobuf:"varint,1,opt,name=numerator,proto3" json:"numerator,omitempty"`
	Denominator uint64 `protobuf:"varint,2,opt,name=denominator,proto3" json:"denominator,omitempty"`
}

func (m *Fraction) Reset()         { *m = Fraction{} }
func (m *Fraction) String() string { return proto.CompactTextString(m) }
func (*Fraction) ProtoMessage()    {}
func (*Fraction) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{3}
}
func (m *Fraction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fraction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fraction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fraction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fraction.Merge(m, src)
}
func (m *Fraction) XXX_Size() int {
	return m.Size()
}
func (m *Fraction) XXX_DiscardUnknown() {
	xxx_messageInfo_Fraction.DiscardUnknown(m)
}

var xxx_messageInfo_Fraction proto.InternalMessageInfo

func (m *Fraction) GetNumerator() uint64 {
	if m != nil {
		return m.Numerator
	}
	return 0
}

func (m *Fraction) GetDenominator() uint64 {
	if m != nil {
		return m.Denominator
	}
	return 0
}

type RoleProposal struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// the proposer address
	Proposer string `protobuf:"bytes,2,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// the address to update the role
	Target string `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	// the role to be updated
	// - unspecified : 0, used to remove the address from a group
	// - guardian : 1
	// - operator : 2
	// - judge : 3
	Role Role `protobuf:"varint,4,opt,name=role,proto3,enum=lbm.fbridge.v1.Role" json:"role,omitempty"`
	// the unix timestamp the proposal will be expired (unix timestamp)
	ExpiredAt uint64 `protobuf:"varint,5,opt,name=expired_at,json=expiredAt,proto3" json:"expired_at,omitempty"`
}

func (m *RoleProposal) Reset()         { *m = RoleProposal{} }
func (m *RoleProposal) String() string { return proto.CompactTextString(m) }
func (*RoleProposal) ProtoMessage()    {}
func (*RoleProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{4}
}
func (m *RoleProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleProposal.Merge(m, src)
}
func (m *RoleProposal) XXX_Size() int {
	return m.Size()
}
func (m *RoleProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RoleProposal proto.InternalMessageInfo

func (m *RoleProposal) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoleProposal) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *RoleProposal) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *RoleProposal) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return Role_UNSPECIFIED
}

func (m *RoleProposal) GetExpiredAt() uint64 {
	if m != nil {
		return m.ExpiredAt
	}
	return 0
}

func init() {
	proto.RegisterEnum("lbm.fbridge.v1.Role", Role_name, Role_value)
	proto.RegisterType((*Params)(nil), "lbm.fbridge.v1.Params")
	proto.RegisterType((*ProvisionData)(nil), "lbm.fbridge.v1.ProvisionData")
	proto.RegisterType((*ProvisionStatus)(nil), "lbm.fbridge.v1.ProvisionStatus")
	proto.RegisterType((*Fraction)(nil), "lbm.fbridge.v1.Fraction")
	proto.RegisterType((*RoleProposal)(nil), "lbm.fbridge.v1.RoleProposal")
}

func init() { proto.RegisterFile("lbm/fbridge/v1/fbridge.proto", fileDescriptor_62374d75fc6aa1ba) }

var fileDescriptor_62374d75fc6aa1ba = []byte{
	// 614 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x41, 0x4f, 0x1b, 0x3d,
	0x10, 0xcd, 0x86, 0x10, 0x65, 0x27, 0x90, 0xe4, 0xb3, 0xd0, 0x27, 0x84, 0x68, 0xa0, 0x91, 0xaa,
	0x22, 0xa4, 0x26, 0x85, 0xde, 0x2b, 0x05, 0x12, 0x50, 0xa2, 0x0a, 0x56, 0x06, 0x2e, 0xbd, 0x44,
	0xce, 0xae, 0x59, 0x5c, 0x76, 0xed, 0xad, 0xed, 0x8d, 0x68, 0x7f, 0x45, 0xef, 0x3d, 0xf5, 0xdf,
	0xa0, 0x9e, 0x38, 0x56, 0x3d, 0xa0, 0x0a, 0xfe, 0x48, 0x65, 0xef, 0x6e, 0x0a, 0xbd, 0x94, 0xdb,
	0xcc, 0xdb, 0x37, 0xcf, 0xcf, 0xcf, 0x93, 0xc0, 0x7a, 0x34, 0x8d, 0x7b, 0xe7, 0x53, 0xc9, 0x82,
	0x90, 0xf6, 0x66, 0x3b, 0x45, 0xd9, 0x4d, 0xa4, 0xd0, 0x02, 0x35, 0xa2, 0x69, 0xdc, 0x2d, 0xa0,
	0xd9, 0xce, 0xda, 0x4a, 0x28, 0x42, 0x61, 0x3f, 0xf5, 0x4c, 0x95, 0xb1, 0x3a, 0xdf, 0xcb, 0x50,
	0xf5, 0x88, 0x24, 0xb1, 0x42, 0x1e, 0xac, 0x88, 0x84, 0x4a, 0xa2, 0x85, 0x9c, 0x68, 0x99, 0x2a,
	0x3d, 0x89, 0xe8, 0x8c, 0x46, 0xab, 0xce, 0xa6, 0xb3, 0x55, 0xdf, 0x5d, 0xed, 0x3e, 0xd6, 0xeb,
	0x1e, 0x48, 0xe2, 0x6b, 0x26, 0xf8, 0x5e, 0xe5, 0xfa, 0x76, 0xa3, 0x84, 0x51, 0x31, 0x7b, 0x6a,
	0x46, 0xdf, 0x99, 0x49, 0xa3, 0x18, 0xa6, 0x44, 0x06, 0x8c, 0xf0, 0x47, 0x8a, 0xe5, 0xa7, 0x29,
	0x16, 0xb3, 0x0f, 0x14, 0xc7, 0xf0, 0xdf, 0x87, 0x34, 0x08, 0xe9, 0x23, 0xb9, 0x85, 0x27, 0xc9,
	0x35, 0xed, 0xe0, 0x03, 0xad, 0x97, 0xd0, 0xd4, 0x2c, 0xa6, 0x91, 0xf0, 0x2f, 0x27, 0x09, 0x95,
	0x4c, 0x04, 0xab, 0x95, 0x4d, 0x67, 0xab, 0x82, 0x1b, 0x05, 0xec, 0x59, 0xd4, 0x10, 0x13, 0x29,
	0x12, 0xa1, 0x48, 0x54, 0x10, 0x17, 0x33, 0x62, 0x01, 0x67, 0xc4, 0xce, 0x37, 0x07, 0x96, 0x3d,
	0x29, 0x66, 0x4c, 0x31, 0xc1, 0x07, 0x44, 0x13, 0xd4, 0x82, 0x05, 0x45, 0x3f, 0xda, 0x08, 0x2b,
	0xd8, 0x94, 0x68, 0x0c, 0x55, 0x12, 0x8b, 0x94, 0x6b, 0x9b, 0x82, 0xbb, 0xb7, 0x6b, 0xcc, 0xfd,
	0xbc, 0xdd, 0xd8, 0x0e, 0x99, 0xbe, 0x48, 0xa7, 0x5d, 0x5f, 0xc4, 0xbd, 0x03, 0xc6, 0x95, 0x7f,
	0xc1, 0x48, 0xef, 0x3c, 0x2f, 0x5e, 0xa9, 0xe0, 0xb2, 0xa7, 0x3f, 0x25, 0x54, 0x75, 0x47, 0x5c,
	0xe3, 0x5c, 0x01, 0xfd, 0x0f, 0x55, 0x45, 0x79, 0x40, 0xa5, 0x8d, 0xc0, 0xc5, 0x79, 0x87, 0xd6,
	0xa0, 0x26, 0xa9, 0x4f, 0xd9, 0x8c, 0x4a, 0x7b, 0x25, 0x17, 0xcf, 0xfb, 0xce, 0x67, 0x68, 0xce,
	0x2d, 0x9e, 0x68, 0xa2, 0x53, 0x85, 0x9e, 0xc3, 0xd2, 0x3c, 0x08, 0xca, 0x83, 0xdc, 0x6d, 0xbd,
	0xc0, 0x86, 0x3c, 0x40, 0x2f, 0xa0, 0xe1, 0x0b, 0x7e, 0xce, 0x64, 0x3c, 0xf1, 0xcd, 0xd1, 0xca,
	0xba, 0x5f, 0xc4, 0xcb, 0x39, 0xba, 0x6f, 0x41, 0xf4, 0x0c, 0x80, 0xa9, 0x89, 0x1f, 0x11, 0x16,
	0xd3, 0xc0, 0x9a, 0xaa, 0x61, 0x97, 0xa9, 0xfd, 0x0c, 0xe8, 0x8c, 0xa1, 0x56, 0x3c, 0x0a, 0x5a,
	0x07, 0x97, 0xa7, 0x71, 0xb6, 0x32, 0xf9, 0x89, 0x7f, 0x00, 0xb4, 0x09, 0xf5, 0x80, 0x72, 0x11,
	0x33, 0x6e, 0xbf, 0x97, 0x33, 0x47, 0x0f, 0xa0, 0xce, 0x57, 0x07, 0x96, 0xb0, 0x88, 0xa8, 0x97,
	0x3f, 0x01, 0x6a, 0x40, 0x99, 0x15, 0xde, 0xcb, 0x2c, 0x30, 0x21, 0x64, 0xcf, 0x43, 0xb3, 0x79,
	0x17, 0xcf, 0x7b, 0x13, 0x9c, 0x26, 0x32, 0xa4, 0xba, 0x08, 0x2e, 0xeb, 0xd0, 0x16, 0x54, 0xa4,
	0x88, 0xa8, 0x0d, 0xad, 0xb1, 0xbb, 0xf2, 0xf7, 0x46, 0x99, 0xf3, 0xb0, 0x65, 0x98, 0x9b, 0xd2,
	0xab, 0x84, 0x49, 0x1a, 0x4c, 0x88, 0xce, 0xd7, 0xc1, 0xcd, 0x91, 0xbe, 0xde, 0x7e, 0x0b, 0x15,
	0x43, 0x46, 0x4d, 0xa8, 0x9f, 0x1d, 0x9d, 0x78, 0xc3, 0xfd, 0xd1, 0xc1, 0x68, 0x38, 0x68, 0x95,
	0xd0, 0x12, 0xd4, 0x0e, 0xcf, 0xfa, 0x78, 0x30, 0xea, 0x1f, 0xb5, 0x1c, 0xd3, 0x1d, 0x7b, 0x43,
	0xdc, 0x3f, 0x3d, 0xc6, 0xad, 0x32, 0x72, 0x61, 0x71, 0x7c, 0x36, 0x38, 0x1c, 0xb6, 0x16, 0xf6,
	0xc6, 0xd7, 0x77, 0x6d, 0xe7, 0xe6, 0xae, 0xed, 0xfc, 0xba, 0x6b, 0x3b, 0x5f, 0xee, 0xdb, 0xa5,
	0x9b, 0xfb, 0x76, 0xe9, 0xc7, 0x7d, 0xbb, 0xf4, 0xfe, 0xf5, 0x3f, 0xf7, 0xe4, 0x6a, 0xfe, 0x9f,
	0x60, 0x37, 0x66, 0x5a, 0xb5, 0xbf, 0xf4, 0x37, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x74, 0xf3,
	0xa0, 0x53, 0x2f, 0x04, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalPeriod != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.ProposalPeriod))
		i--
		dAtA[i] = 0x28
	}
	if m.TimelockPeriod != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.TimelockPeriod))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.JudgeTrustLevel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.GuardianTrustLevel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.OperatorTrustLevel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProvisionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintFbridge(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintFbridge(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Seq != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsClaimed {
		i--
		if m.IsClaimed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ConfirmCounts != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.ConfirmCounts))
		i--
		dAtA[i] = 0x10
	}
	if m.TimelockEnd != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.TimelockEnd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Fraction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fraction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Fraction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Denominator != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Denominator))
		i--
		dAtA[i] = 0x10
	}
	if m.Numerator != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Numerator))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiredAt != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.ExpiredAt))
		i--
		dAtA[i] = 0x28
	}
	if m.Role != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintFbridge(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintFbridge(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFbridge(dAtA []byte, offset int, v uint64) int {
	offset -= sovFbridge(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OperatorTrustLevel.Size()
	n += 1 + l + sovFbridge(uint64(l))
	l = m.GuardianTrustLevel.Size()
	n += 1 + l + sovFbridge(uint64(l))
	l = m.JudgeTrustLevel.Size()
	n += 1 + l + sovFbridge(uint64(l))
	if m.TimelockPeriod != 0 {
		n += 1 + sovFbridge(uint64(m.TimelockPeriod))
	}
	if m.ProposalPeriod != 0 {
		n += 1 + sovFbridge(uint64(m.ProposalPeriod))
	}
	return n
}

func (m *ProvisionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovFbridge(uint64(m.Seq))
	}
	l = m.Amount.Size()
	n += 1 + l + sovFbridge(uint64(l))
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovFbridge(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovFbridge(uint64(l))
	}
	return n
}

func (m *ProvisionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimelockEnd != 0 {
		n += 1 + sovFbridge(uint64(m.TimelockEnd))
	}
	if m.ConfirmCounts != 0 {
		n += 1 + sovFbridge(uint64(m.ConfirmCounts))
	}
	if m.IsClaimed {
		n += 2
	}
	return n
}

func (m *Fraction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Numerator != 0 {
		n += 1 + sovFbridge(uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		n += 1 + sovFbridge(uint64(m.Denominator))
	}
	return n
}

func (m *RoleProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovFbridge(uint64(m.Id))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovFbridge(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovFbridge(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovFbridge(uint64(m.Role))
	}
	if m.ExpiredAt != 0 {
		n += 1 + sovFbridge(uint64(m.ExpiredAt))
	}
	return n
}

func sovFbridge(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFbridge(x uint64) (n int) {
	return sovFbridge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorTrustLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OperatorTrustLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardianTrustLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GuardianTrustLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JudgeTrustLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.JudgeTrustLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelockPeriod", wireType)
			}
			m.TimelockPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimelockPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalPeriod", wireType)
			}
			m.ProposalPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelockEnd", wireType)
			}
			m.TimelockEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimelockEnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmCounts", wireType)
			}
			m.ConfirmCounts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmCounts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClaimed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClaimed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fraction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fraction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fraction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numerator", wireType)
			}
			m.Numerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numerator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denominator", wireType)
			}
			m.Denominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Denominator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredAt", wireType)
			}
			m.ExpiredAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiredAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFbridge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFbridge
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFbridge
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFbridge
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFbridge        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFbridge          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFbridge = fmt.Errorf("proto: unexpected end of group")
)
