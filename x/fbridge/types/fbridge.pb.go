// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: lbm/fbridge/v1/fbridge.proto

package types

import (
	fmt "fmt"
	github_com_Finschia_finschia_sdk_types "github.com/Finschia/finschia-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Role defines the role of the operator, guardian, and judge.
type Role int32

const (
	RoleEmpty    Role = 0
	RoleGuardian Role = 1
	RoleOperator Role = 2
	RoleJudge    Role = 3
)

var Role_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "GUARDIAN",
	2: "OPERATOR",
	3: "JUDGE",
}

var Role_value = map[string]int32{
	"UNSPECIFIED": 0,
	"GUARDIAN":    1,
	"OPERATOR":    2,
	"JUDGE":       3,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}

func (Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{0}
}

// VoteOption enumerates the valid vote options for a given role proposal.
type VoteOption int32

const (
	// VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
	OptionEmpty VoteOption = 0
	// VOTE_OPTION_YES defines a yes vote option.
	OptionYes VoteOption = 1
	// VOTE_OPTION_NO defines a no vote option.
	OptionNo VoteOption = 2
)

var VoteOption_name = map[int32]string{
	0: "VOTE_OPTION_UNSPECIFIED",
	1: "VOTE_OPTION_YES",
	2: "VOTE_OPTION_NO",
}

var VoteOption_value = map[string]int32{
	"VOTE_OPTION_UNSPECIFIED": 0,
	"VOTE_OPTION_YES":         1,
	"VOTE_OPTION_NO":          2,
}

func (x VoteOption) String() string {
	return proto.EnumName(VoteOption_name, int32(x))
}

func (VoteOption) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{1}
}

type BridgeStatus int32

const (
	// BRIDGE_STATUS_UNSPECIFIED defines an unspecified bridge status.
	StatusEmpty BridgeStatus = 0
	// BRIDGE_STATUS_ACTIVE defines an active bridge status.
	StatusActive BridgeStatus = 1
	// BRIDGE_STATUS_INACTIVE defines an inactive bridge status.
	StatusInactive BridgeStatus = 2
)

var BridgeStatus_name = map[int32]string{
	0: "BRIDGE_STATUS_UNSPECIFIED",
	1: "BRIDGE_STATUS_ACTIVE",
	2: "BRIDGE_STATUS_INACTIVE",
}

var BridgeStatus_value = map[string]int32{
	"BRIDGE_STATUS_UNSPECIFIED": 0,
	"BRIDGE_STATUS_ACTIVE":      1,
	"BRIDGE_STATUS_INACTIVE":    2,
}

func (x BridgeStatus) String() string {
	return proto.EnumName(BridgeStatus_name, int32(x))
}

func (BridgeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{2}
}

type Params struct {
	// ratio of how many operators' confirmations are needed to be valid.
	OperatorTrustLevel Fraction `protobuf:"bytes,1,opt,name=operator_trust_level,json=operatorTrustLevel,proto3" json:"operator_trust_level"`
	// ratio of how many guardians' confirmations are needed to be valid.
	GuardianTrustLevel Fraction `protobuf:"bytes,2,opt,name=guardian_trust_level,json=guardianTrustLevel,proto3" json:"guardian_trust_level"`
	// ratio of how many judges' confirmations are needed to be valid.
	JudgeTrustLevel Fraction `protobuf:"bytes,3,opt,name=judge_trust_level,json=judgeTrustLevel,proto3" json:"judge_trust_level"`
	// default timelock period for each provision (unix timestamp)
	TimelockPeriod uint64 `protobuf:"varint,4,opt,name=timelock_period,json=timelockPeriod,proto3" json:"timelock_period,omitempty"`
	// default period of the proposal to update the role
	ProposalPeriod uint64 `protobuf:"varint,5,opt,name=proposal_period,json=proposalPeriod,proto3" json:"proposal_period,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetOperatorTrustLevel() Fraction {
	if m != nil {
		return m.OperatorTrustLevel
	}
	return Fraction{}
}

func (m *Params) GetGuardianTrustLevel() Fraction {
	if m != nil {
		return m.GuardianTrustLevel
	}
	return Fraction{}
}

func (m *Params) GetJudgeTrustLevel() Fraction {
	if m != nil {
		return m.JudgeTrustLevel
	}
	return Fraction{}
}

func (m *Params) GetTimelockPeriod() uint64 {
	if m != nil {
		return m.TimelockPeriod
	}
	return 0
}

func (m *Params) GetProposalPeriod() uint64 {
	if m != nil {
		return m.ProposalPeriod
	}
	return 0
}

// Provision is a struct that represents a provision internally.
type ProvisionData struct {
	// the sequence number of the bridge request
	Seq uint64 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	// the amount of token to be claimed
	Amount github_com_Finschia_finschia_sdk_types.Int `protobuf:"bytes,2,opt,name=amount,proto3,customtype=github.com/Finschia/finschia-sdk/types.Int" json:"amount"`
	// the sender address on the source chain
	Sender string `protobuf:"bytes,3,opt,name=sender,proto3" json:"sender,omitempty"`
	// the recipient address on the destination chain
	Receiver string `protobuf:"bytes,4,opt,name=receiver,proto3" json:"receiver,omitempty"`
}

func (m *ProvisionData) Reset()         { *m = ProvisionData{} }
func (m *ProvisionData) String() string { return proto.CompactTextString(m) }
func (*ProvisionData) ProtoMessage()    {}
func (*ProvisionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{1}
}
func (m *ProvisionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionData.Merge(m, src)
}
func (m *ProvisionData) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionData) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionData.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionData proto.InternalMessageInfo

func (m *ProvisionData) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ProvisionData) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *ProvisionData) GetReceiver() string {
	if m != nil {
		return m.Receiver
	}
	return ""
}

// ProvisionStatus is a struct that represents the status of a provision.
// To optimize computational cost, we have collected frequently changing values from provision.
type ProvisionStatus struct {
	// the unix timestamp the provision will be able to be claimed (unix timestamp)
	TimelockEnd uint64 `protobuf:"varint,1,opt,name=timelock_end,json=timelockEnd,proto3" json:"timelock_end,omitempty"`
	// a value that tells how many operators have submitted this provision
	ConfirmCounts int32 `protobuf:"varint,2,opt,name=confirm_counts,json=confirmCounts,proto3" json:"confirm_counts,omitempty"`
	// whether the provision has been claimed
	IsClaimed bool `protobuf:"varint,3,opt,name=is_claimed,json=isClaimed,proto3" json:"is_claimed,omitempty"`
}

func (m *ProvisionStatus) Reset()         { *m = ProvisionStatus{} }
func (m *ProvisionStatus) String() string { return proto.CompactTextString(m) }
func (*ProvisionStatus) ProtoMessage()    {}
func (*ProvisionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{2}
}
func (m *ProvisionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionStatus.Merge(m, src)
}
func (m *ProvisionStatus) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionStatus proto.InternalMessageInfo

func (m *ProvisionStatus) GetTimelockEnd() uint64 {
	if m != nil {
		return m.TimelockEnd
	}
	return 0
}

func (m *ProvisionStatus) GetConfirmCounts() int32 {
	if m != nil {
		return m.ConfirmCounts
	}
	return 0
}

func (m *ProvisionStatus) GetIsClaimed() bool {
	if m != nil {
		return m.IsClaimed
	}
	return false
}

// Fraction defines the protobuf message type for tmmath.Fraction that only
// supports positive values.
type Fraction struct {
	Numerator   uint64 `protobuf:"varint,1,opt,name=numerator,proto3" json:"numerator,omitempty"`
	Denominator uint64 `protobuf:"varint,2,opt,name=denominator,proto3" json:"denominator,omitempty"`
}

func (m *Fraction) Reset()         { *m = Fraction{} }
func (m *Fraction) String() string { return proto.CompactTextString(m) }
func (*Fraction) ProtoMessage()    {}
func (*Fraction) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{3}
}
func (m *Fraction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fraction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fraction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fraction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fraction.Merge(m, src)
}
func (m *Fraction) XXX_Size() int {
	return m.Size()
}
func (m *Fraction) XXX_DiscardUnknown() {
	xxx_messageInfo_Fraction.DiscardUnknown(m)
}

var xxx_messageInfo_Fraction proto.InternalMessageInfo

func (m *Fraction) GetNumerator() uint64 {
	if m != nil {
		return m.Numerator
	}
	return 0
}

func (m *Fraction) GetDenominator() uint64 {
	if m != nil {
		return m.Denominator
	}
	return 0
}

type RolePair struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Role    Role   `protobuf:"varint,2,opt,name=role,proto3,enum=lbm.fbridge.v1.Role" json:"role,omitempty"`
}

func (m *RolePair) Reset()         { *m = RolePair{} }
func (m *RolePair) String() string { return proto.CompactTextString(m) }
func (*RolePair) ProtoMessage()    {}
func (*RolePair) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{4}
}
func (m *RolePair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RolePair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RolePair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RolePair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RolePair.Merge(m, src)
}
func (m *RolePair) XXX_Size() int {
	return m.Size()
}
func (m *RolePair) XXX_DiscardUnknown() {
	xxx_messageInfo_RolePair.DiscardUnknown(m)
}

var xxx_messageInfo_RolePair proto.InternalMessageInfo

func (m *RolePair) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RolePair) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return RoleEmpty
}

type RoleProposal struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// the proposer address
	Proposer string `protobuf:"bytes,2,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// the address to update the role
	Target string `protobuf:"bytes,3,opt,name=target,proto3" json:"target,omitempty"`
	// the role to be updated
	// - unspecified : 0, used to remove the address from a group
	// - guardian : 1
	// - operator : 2
	// - judge : 3
	Role Role `protobuf:"varint,4,opt,name=role,proto3,enum=lbm.fbridge.v1.Role" json:"role,omitempty"`
	// the unix timestamp the proposal will be expired (unix timestamp)
	ExpiredAt time.Time `protobuf:"bytes,5,opt,name=expired_at,json=expiredAt,proto3,stdtime" json:"expired_at"`
}

func (m *RoleProposal) Reset()         { *m = RoleProposal{} }
func (m *RoleProposal) String() string { return proto.CompactTextString(m) }
func (*RoleProposal) ProtoMessage()    {}
func (*RoleProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{5}
}
func (m *RoleProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleProposal.Merge(m, src)
}
func (m *RoleProposal) XXX_Size() int {
	return m.Size()
}
func (m *RoleProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleProposal.DiscardUnknown(m)
}

var xxx_messageInfo_RoleProposal proto.InternalMessageInfo

func (m *RoleProposal) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoleProposal) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *RoleProposal) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *RoleProposal) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return RoleEmpty
}

func (m *RoleProposal) GetExpiredAt() time.Time {
	if m != nil {
		return m.ExpiredAt
	}
	return time.Time{}
}

// Vote defines a vote on a role proposal.
type Vote struct {
	ProposalId uint64     `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	Voter      string     `protobuf:"bytes,2,opt,name=voter,proto3" json:"voter,omitempty"`
	Option     VoteOption `protobuf:"varint,3,opt,name=option,proto3,enum=lbm.fbridge.v1.VoteOption" json:"option,omitempty"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{6}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *Vote) GetVoter() string {
	if m != nil {
		return m.Voter
	}
	return ""
}

func (m *Vote) GetOption() VoteOption {
	if m != nil {
		return m.Option
	}
	return OptionEmpty
}

// RoleMetadata defines the metadata of the role.
type RoleMetadata struct {
	// the number of registered guardians
	Guardian uint64 `protobuf:"varint,1,opt,name=guardian,proto3" json:"guardian,omitempty"`
	// the number of the operators
	Operator uint64 `protobuf:"varint,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// the number of the judges
	Judge uint64 `protobuf:"varint,3,opt,name=judge,proto3" json:"judge,omitempty"`
}

func (m *RoleMetadata) Reset()         { *m = RoleMetadata{} }
func (m *RoleMetadata) String() string { return proto.CompactTextString(m) }
func (*RoleMetadata) ProtoMessage()    {}
func (*RoleMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{7}
}
func (m *RoleMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleMetadata.Merge(m, src)
}
func (m *RoleMetadata) XXX_Size() int {
	return m.Size()
}
func (m *RoleMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_RoleMetadata proto.InternalMessageInfo

func (m *RoleMetadata) GetGuardian() uint64 {
	if m != nil {
		return m.Guardian
	}
	return 0
}

func (m *RoleMetadata) GetOperator() uint64 {
	if m != nil {
		return m.Operator
	}
	return 0
}

func (m *RoleMetadata) GetJudge() uint64 {
	if m != nil {
		return m.Judge
	}
	return 0
}

// BridgeStatusMetadata defines the metadata of the bridge status.
type BridgeStatusMetadata struct {
	// the number of inactived bridge switch
	Inactive uint64 `protobuf:"varint,1,opt,name=inactive,proto3" json:"inactive,omitempty"`
	// the number of activated bridge switch
	Active uint64 `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *BridgeStatusMetadata) Reset()         { *m = BridgeStatusMetadata{} }
func (m *BridgeStatusMetadata) String() string { return proto.CompactTextString(m) }
func (*BridgeStatusMetadata) ProtoMessage()    {}
func (*BridgeStatusMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_62374d75fc6aa1ba, []int{8}
}
func (m *BridgeStatusMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BridgeStatusMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BridgeStatusMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BridgeStatusMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BridgeStatusMetadata.Merge(m, src)
}
func (m *BridgeStatusMetadata) XXX_Size() int {
	return m.Size()
}
func (m *BridgeStatusMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_BridgeStatusMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_BridgeStatusMetadata proto.InternalMessageInfo

func (m *BridgeStatusMetadata) GetInactive() uint64 {
	if m != nil {
		return m.Inactive
	}
	return 0
}

func (m *BridgeStatusMetadata) GetActive() uint64 {
	if m != nil {
		return m.Active
	}
	return 0
}

func init() {
	proto.RegisterEnum("lbm.fbridge.v1.Role", Role_name, Role_value)
	proto.RegisterEnum("lbm.fbridge.v1.VoteOption", VoteOption_name, VoteOption_value)
	proto.RegisterEnum("lbm.fbridge.v1.BridgeStatus", BridgeStatus_name, BridgeStatus_value)
	proto.RegisterType((*Params)(nil), "lbm.fbridge.v1.Params")
	proto.RegisterType((*ProvisionData)(nil), "lbm.fbridge.v1.ProvisionData")
	proto.RegisterType((*ProvisionStatus)(nil), "lbm.fbridge.v1.ProvisionStatus")
	proto.RegisterType((*Fraction)(nil), "lbm.fbridge.v1.Fraction")
	proto.RegisterType((*RolePair)(nil), "lbm.fbridge.v1.RolePair")
	proto.RegisterType((*RoleProposal)(nil), "lbm.fbridge.v1.RoleProposal")
	proto.RegisterType((*Vote)(nil), "lbm.fbridge.v1.Vote")
	proto.RegisterType((*RoleMetadata)(nil), "lbm.fbridge.v1.RoleMetadata")
	proto.RegisterType((*BridgeStatusMetadata)(nil), "lbm.fbridge.v1.BridgeStatusMetadata")
}

func init() { proto.RegisterFile("lbm/fbridge/v1/fbridge.proto", fileDescriptor_62374d75fc6aa1ba) }

var fileDescriptor_62374d75fc6aa1ba = []byte{
	// 973 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0x4f, 0x6f, 0xe3, 0x44,
	0x14, 0x8f, 0xb3, 0x6e, 0x49, 0x5e, 0xda, 0x34, 0x8c, 0xa2, 0xa5, 0x58, 0x4b, 0x12, 0x22, 0x21,
	0xaa, 0x0a, 0x1c, 0x36, 0xdc, 0xb8, 0x25, 0xad, 0x5b, 0x39, 0x82, 0x24, 0x72, 0xd3, 0x4a, 0x8b,
	0x90, 0x22, 0x27, 0x9e, 0x66, 0x87, 0xb5, 0x3d, 0x66, 0x3c, 0x09, 0xbb, 0x7c, 0x00, 0x84, 0x7a,
	0xda, 0x2f, 0x50, 0x69, 0x11, 0x9f, 0x84, 0xdb, 0x8a, 0xd3, 0x1e, 0x11, 0x87, 0x05, 0xb5, 0x17,
	0x3e, 0x06, 0x9a, 0x19, 0x8f, 0x9b, 0xac, 0x90, 0x76, 0x6f, 0xf3, 0xde, 0xfc, 0xde, 0xef, 0xfd,
	0xde, 0x9f, 0xb1, 0xe1, 0x41, 0x38, 0x8b, 0x3a, 0x97, 0x33, 0x46, 0x82, 0x05, 0xee, 0xac, 0x1e,
	0xea, 0xa3, 0x9d, 0x30, 0xca, 0x29, 0xaa, 0x86, 0xb3, 0xc8, 0xd6, 0xae, 0xd5, 0x43, 0xab, 0xb9,
	0xa0, 0x74, 0x11, 0xe2, 0x8e, 0xbc, 0x9d, 0x2d, 0x2f, 0x3b, 0x9c, 0x44, 0x38, 0xe5, 0x7e, 0x94,
	0xa8, 0x00, 0xab, 0xbe, 0xa0, 0x0b, 0x2a, 0x8f, 0x1d, 0x71, 0x52, 0xde, 0xf6, 0x1f, 0x45, 0xd8,
	0x1e, 0xfb, 0xcc, 0x8f, 0x52, 0x34, 0x86, 0x3a, 0x4d, 0x30, 0xf3, 0x39, 0x65, 0x53, 0xce, 0x96,
	0x29, 0x9f, 0x86, 0x78, 0x85, 0xc3, 0x7d, 0xa3, 0x65, 0x1c, 0x54, 0xba, 0xfb, 0xf6, 0x66, 0x42,
	0xfb, 0x84, 0xf9, 0x73, 0x4e, 0x68, 0xdc, 0x37, 0x5f, 0xbe, 0x6e, 0x16, 0x3c, 0xa4, 0x63, 0x27,
	0x22, 0xf4, 0x6b, 0x11, 0x29, 0x18, 0x17, 0x4b, 0x9f, 0x05, 0xc4, 0x8f, 0x37, 0x18, 0x8b, 0xef,
	0xc6, 0xa8, 0x63, 0xd7, 0x18, 0x07, 0xf0, 0xfe, 0xf7, 0xcb, 0x60, 0x81, 0x37, 0xe8, 0xee, 0xbd,
	0x13, 0xdd, 0x9e, 0x0c, 0x5c, 0xe3, 0xfa, 0x14, 0xf6, 0x44, 0x8f, 0x42, 0x3a, 0x7f, 0x32, 0x4d,
	0x30, 0x23, 0x34, 0xd8, 0x37, 0x5b, 0xc6, 0x81, 0xe9, 0x55, 0xb5, 0x7b, 0x2c, 0xbd, 0x02, 0x98,
	0x30, 0x9a, 0xd0, 0xd4, 0x0f, 0x35, 0x70, 0x4b, 0x01, 0xb5, 0x5b, 0x01, 0xdb, 0xbf, 0x1a, 0xb0,
	0x3b, 0x66, 0x74, 0x45, 0x52, 0x42, 0xe3, 0x63, 0x9f, 0xfb, 0xa8, 0x06, 0xf7, 0x52, 0xfc, 0x83,
	0x6c, 0xa1, 0xe9, 0x89, 0x23, 0x1a, 0xc0, 0xb6, 0x1f, 0xd1, 0x65, 0xcc, 0x65, 0x17, 0xca, 0xfd,
	0xae, 0x10, 0xf7, 0xd7, 0xeb, 0xe6, 0xe1, 0x82, 0xf0, 0xc7, 0xcb, 0x99, 0x3d, 0xa7, 0x51, 0xe7,
	0x84, 0xc4, 0xe9, 0xfc, 0x31, 0xf1, 0x3b, 0x97, 0xd9, 0xe1, 0xf3, 0x34, 0x78, 0xd2, 0xe1, 0xcf,
	0x12, 0x9c, 0xda, 0x6e, 0xcc, 0xbd, 0x8c, 0x01, 0xdd, 0x87, 0xed, 0x14, 0xc7, 0x01, 0x66, 0xb2,
	0x05, 0x65, 0x2f, 0xb3, 0x90, 0x05, 0x25, 0x86, 0xe7, 0x98, 0xac, 0x30, 0x93, 0x25, 0x95, 0xbd,
	0xdc, 0x6e, 0xff, 0x04, 0x7b, 0xb9, 0xc4, 0x33, 0xee, 0xf3, 0x65, 0x8a, 0x3e, 0x86, 0x9d, 0xbc,
	0x11, 0x38, 0x0e, 0x32, 0xb5, 0x15, 0xed, 0x73, 0xe2, 0x00, 0x7d, 0x02, 0xd5, 0x39, 0x8d, 0x2f,
	0x09, 0x8b, 0xa6, 0x73, 0x91, 0x3a, 0x95, 0xea, 0xb7, 0xbc, 0xdd, 0xcc, 0x7b, 0x24, 0x9d, 0xe8,
	0x23, 0x00, 0x92, 0x4e, 0xe7, 0xa1, 0x4f, 0x22, 0x1c, 0x48, 0x51, 0x25, 0xaf, 0x4c, 0xd2, 0x23,
	0xe5, 0x68, 0x0f, 0xa0, 0xa4, 0x87, 0x82, 0x1e, 0x40, 0x39, 0x5e, 0x46, 0x6a, 0x65, 0xb2, 0x8c,
	0x77, 0x0e, 0xd4, 0x82, 0x4a, 0x80, 0x63, 0x1a, 0x91, 0x58, 0xde, 0x17, 0x95, 0xa2, 0x35, 0x57,
	0x7b, 0x08, 0x25, 0x8f, 0x86, 0x78, 0xec, 0x13, 0x86, 0xf6, 0xe1, 0x3d, 0x3f, 0x08, 0x18, 0x4e,
	0x53, 0xc9, 0x54, 0xf6, 0xb4, 0x89, 0x0e, 0xc0, 0x64, 0x34, 0xc4, 0x92, 0xa0, 0xda, 0xad, 0xbf,
	0xb9, 0x22, 0x82, 0xc1, 0x93, 0x88, 0xf6, 0xef, 0x06, 0xec, 0x48, 0xc2, 0x6c, 0xa4, 0xa8, 0x0a,
	0x45, 0xa2, 0x7b, 0x51, 0x24, 0x81, 0x68, 0xaa, 0x1a, 0x37, 0x56, 0x7a, 0xca, 0x5e, 0x6e, 0x8b,
	0x41, 0x70, 0x9f, 0x2d, 0x30, 0xd7, 0x83, 0x50, 0x56, 0x9e, 0xde, 0x7c, 0x5b, 0x7a, 0x74, 0x04,
	0x80, 0x9f, 0x26, 0x84, 0xe1, 0x60, 0xea, 0x73, 0xb9, 0x5e, 0x95, 0xae, 0x65, 0xab, 0x37, 0x6d,
	0xeb, 0x37, 0x6d, 0x4f, 0xf4, 0x9b, 0xee, 0x97, 0xc4, 0xda, 0x3c, 0xff, 0xbb, 0x69, 0x78, 0xe5,
	0x2c, 0xae, 0xc7, 0xdb, 0x3f, 0x82, 0x79, 0x41, 0x39, 0x46, 0x4d, 0xa8, 0xe4, 0x0b, 0x9b, 0xd7,
	0x00, 0xda, 0xe5, 0x06, 0xa8, 0x0e, 0x5b, 0x2b, 0xca, 0xf3, 0x42, 0x94, 0x81, 0xba, 0xb0, 0x4d,
	0x13, 0x31, 0x1c, 0x59, 0x45, 0xb5, 0x6b, 0xbd, 0xa9, 0x57, 0x90, 0x8f, 0x24, 0xc2, 0xcb, 0x90,
	0x5f, 0x99, 0xff, 0xbe, 0x68, 0x16, 0xda, 0xdf, 0xa9, 0xde, 0x7d, 0x83, 0xb9, 0x1f, 0x88, 0xb5,
	0xb7, 0xa0, 0xa4, 0x1f, 0x6f, 0x96, 0x3d, 0xb7, 0xc5, 0x9d, 0xfe, 0x54, 0x64, 0x73, 0xcd, 0x6d,
	0xa1, 0x4b, 0xbe, 0x52, 0x29, 0xc0, 0xf4, 0x94, 0xd1, 0x1e, 0x40, 0xbd, 0x2f, 0x35, 0xa8, 0x7d,
	0x5d, 0xcf, 0x42, 0x62, 0xb1, 0x4e, 0x2b, 0xac, 0xb3, 0x68, 0x5b, 0x4c, 0x24, 0xbb, 0x51, 0x39,
	0x32, 0xeb, 0xf0, 0x67, 0x03, 0x4c, 0x21, 0x15, 0x35, 0xa0, 0x72, 0x3e, 0x3c, 0x1b, 0x3b, 0x47,
	0xee, 0x89, 0xeb, 0x1c, 0xd7, 0x0a, 0xd6, 0xee, 0xd5, 0x75, 0xab, 0x2c, 0xae, 0x9c, 0x28, 0xe1,
	0xcf, 0x50, 0x03, 0x4a, 0xa7, 0xe7, 0x3d, 0xef, 0xd8, 0xed, 0x0d, 0x6b, 0x86, 0x55, 0xbb, 0xba,
	0x6e, 0xc9, 0x12, 0x4f, 0x75, 0x19, 0x0d, 0x28, 0x8d, 0xc6, 0x8e, 0xd7, 0x9b, 0x8c, 0xbc, 0x5a,
	0xf1, 0xee, 0x7e, 0xa4, 0x4b, 0xd9, 0x87, 0xad, 0xc1, 0xf9, 0xf1, 0xa9, 0x53, 0xbb, 0x77, 0xc7,
	0x3c, 0x10, 0xe5, 0x58, 0xe6, 0x2f, 0xbf, 0x35, 0x0a, 0x42, 0x08, 0xdc, 0xf5, 0x13, 0x7d, 0x06,
	0x1f, 0x5c, 0x8c, 0x26, 0xce, 0x74, 0x34, 0x9e, 0xb8, 0xa3, 0xe1, 0x74, 0x53, 0xda, 0xde, 0xd5,
	0x75, 0xab, 0xa2, 0x80, 0x4a, 0x5c, 0x1b, 0xf6, 0xd6, 0xd1, 0x8f, 0x9c, 0xb3, 0x9a, 0xa1, 0xd2,
	0x28, 0xd4, 0x23, 0x9c, 0xa2, 0x16, 0x54, 0xd7, 0x31, 0xc3, 0x51, 0xad, 0x68, 0xed, 0x5c, 0x5d,
	0xb7, 0x4a, 0x0a, 0x32, 0xa4, 0x99, 0x90, 0x17, 0x06, 0xec, 0xac, 0xb7, 0x17, 0xd9, 0xf0, 0x61,
	0xdf, 0x73, 0x8f, 0x4f, 0x9d, 0xe9, 0xd9, 0xa4, 0x37, 0x39, 0x3f, 0xfb, 0x3f, 0x31, 0x0a, 0xaa,
	0xc4, 0x1c, 0x42, 0x7d, 0x13, 0xdf, 0x3b, 0x9a, 0xb8, 0x17, 0x8e, 0xee, 0x9a, 0x82, 0xf6, 0xd4,
	0x58, 0x6c, 0xb8, 0xbf, 0x89, 0x75, 0x87, 0x19, 0xba, 0x68, 0xa1, 0xab, 0xeb, 0x56, 0x55, 0xa1,
	0xdd, 0x6c, 0x8c, 0x4a, 0x62, 0x7f, 0xf0, 0xf2, 0xa6, 0x61, 0xbc, 0xba, 0x69, 0x18, 0xff, 0xdc,
	0x34, 0x8c, 0xe7, 0xb7, 0x8d, 0xc2, 0xab, 0xdb, 0x46, 0xe1, 0xcf, 0xdb, 0x46, 0xe1, 0xdb, 0x2f,
	0xde, 0xfa, 0xd5, 0x7c, 0x9a, 0xff, 0x42, 0xe5, 0xf7, 0x73, 0xb6, 0x2d, 0x1f, 0xd3, 0x97, 0xff,
	0x05, 0x00, 0x00, 0xff, 0xff, 0xfa, 0x2c, 0x09, 0x1f, 0x5e, 0x07, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalPeriod != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.ProposalPeriod))
		i--
		dAtA[i] = 0x28
	}
	if m.TimelockPeriod != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.TimelockPeriod))
		i--
		dAtA[i] = 0x20
	}
	{
		size, err := m.JudgeTrustLevel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.GuardianTrustLevel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.OperatorTrustLevel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ProvisionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Receiver) > 0 {
		i -= len(m.Receiver)
		copy(dAtA[i:], m.Receiver)
		i = encodeVarintFbridge(dAtA, i, uint64(len(m.Receiver)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintFbridge(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintFbridge(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.Seq != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsClaimed {
		i--
		if m.IsClaimed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ConfirmCounts != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.ConfirmCounts))
		i--
		dAtA[i] = 0x10
	}
	if m.TimelockEnd != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.TimelockEnd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Fraction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fraction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Fraction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Denominator != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Denominator))
		i--
		dAtA[i] = 0x10
	}
	if m.Numerator != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Numerator))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RolePair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RolePair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RolePair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Role != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintFbridge(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RoleProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.ExpiredAt, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.ExpiredAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintFbridge(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x2a
	if m.Role != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintFbridge(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintFbridge(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Option != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Option))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Voter) > 0 {
		i -= len(m.Voter)
		copy(dAtA[i:], m.Voter)
		i = encodeVarintFbridge(dAtA, i, uint64(len(m.Voter)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalId != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Judge != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Judge))
		i--
		dAtA[i] = 0x18
	}
	if m.Operator != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Operator))
		i--
		dAtA[i] = 0x10
	}
	if m.Guardian != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Guardian))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BridgeStatusMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BridgeStatusMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BridgeStatusMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Active))
		i--
		dAtA[i] = 0x10
	}
	if m.Inactive != 0 {
		i = encodeVarintFbridge(dAtA, i, uint64(m.Inactive))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFbridge(dAtA []byte, offset int, v uint64) int {
	offset -= sovFbridge(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.OperatorTrustLevel.Size()
	n += 1 + l + sovFbridge(uint64(l))
	l = m.GuardianTrustLevel.Size()
	n += 1 + l + sovFbridge(uint64(l))
	l = m.JudgeTrustLevel.Size()
	n += 1 + l + sovFbridge(uint64(l))
	if m.TimelockPeriod != 0 {
		n += 1 + sovFbridge(uint64(m.TimelockPeriod))
	}
	if m.ProposalPeriod != 0 {
		n += 1 + sovFbridge(uint64(m.ProposalPeriod))
	}
	return n
}

func (m *ProvisionData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovFbridge(uint64(m.Seq))
	}
	l = m.Amount.Size()
	n += 1 + l + sovFbridge(uint64(l))
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovFbridge(uint64(l))
	}
	l = len(m.Receiver)
	if l > 0 {
		n += 1 + l + sovFbridge(uint64(l))
	}
	return n
}

func (m *ProvisionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TimelockEnd != 0 {
		n += 1 + sovFbridge(uint64(m.TimelockEnd))
	}
	if m.ConfirmCounts != 0 {
		n += 1 + sovFbridge(uint64(m.ConfirmCounts))
	}
	if m.IsClaimed {
		n += 2
	}
	return n
}

func (m *Fraction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Numerator != 0 {
		n += 1 + sovFbridge(uint64(m.Numerator))
	}
	if m.Denominator != 0 {
		n += 1 + sovFbridge(uint64(m.Denominator))
	}
	return n
}

func (m *RolePair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovFbridge(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovFbridge(uint64(m.Role))
	}
	return n
}

func (m *RoleProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovFbridge(uint64(m.Id))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovFbridge(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovFbridge(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovFbridge(uint64(m.Role))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.ExpiredAt)
	n += 1 + l + sovFbridge(uint64(l))
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovFbridge(uint64(m.ProposalId))
	}
	l = len(m.Voter)
	if l > 0 {
		n += 1 + l + sovFbridge(uint64(l))
	}
	if m.Option != 0 {
		n += 1 + sovFbridge(uint64(m.Option))
	}
	return n
}

func (m *RoleMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Guardian != 0 {
		n += 1 + sovFbridge(uint64(m.Guardian))
	}
	if m.Operator != 0 {
		n += 1 + sovFbridge(uint64(m.Operator))
	}
	if m.Judge != 0 {
		n += 1 + sovFbridge(uint64(m.Judge))
	}
	return n
}

func (m *BridgeStatusMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inactive != 0 {
		n += 1 + sovFbridge(uint64(m.Inactive))
	}
	if m.Active != 0 {
		n += 1 + sovFbridge(uint64(m.Active))
	}
	return n
}

func sovFbridge(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFbridge(x uint64) (n int) {
	return sovFbridge(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorTrustLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OperatorTrustLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuardianTrustLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GuardianTrustLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JudgeTrustLevel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.JudgeTrustLevel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelockPeriod", wireType)
			}
			m.TimelockPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimelockPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalPeriod", wireType)
			}
			m.ProposalPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receiver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receiver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimelockEnd", wireType)
			}
			m.TimelockEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimelockEnd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfirmCounts", wireType)
			}
			m.ConfirmCounts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfirmCounts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClaimed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClaimed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fraction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fraction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fraction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Numerator", wireType)
			}
			m.Numerator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Numerator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denominator", wireType)
			}
			m.Denominator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Denominator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RolePair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RolePair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RolePair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.ExpiredAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFbridge
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFbridge
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Option", wireType)
			}
			m.Option = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Option |= VoteOption(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guardian", wireType)
			}
			m.Guardian = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Guardian |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			m.Operator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operator |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Judge", wireType)
			}
			m.Judge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Judge |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BridgeStatusMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BridgeStatusMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BridgeStatusMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inactive", wireType)
			}
			m.Inactive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inactive |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			m.Active = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Active |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFbridge(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFbridge
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFbridge(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFbridge
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFbridge
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFbridge
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFbridge
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFbridge
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFbridge        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFbridge          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFbridge = fmt.Errorf("proto: unexpected end of group")
)
