// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: lbm/collection/v1/tx.proto

package collectionv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Msg_SendFT_FullMethodName            = "/lbm.collection.v1.Msg/SendFT"
	Msg_OperatorSendFT_FullMethodName    = "/lbm.collection.v1.Msg/OperatorSendFT"
	Msg_SendNFT_FullMethodName           = "/lbm.collection.v1.Msg/SendNFT"
	Msg_OperatorSendNFT_FullMethodName   = "/lbm.collection.v1.Msg/OperatorSendNFT"
	Msg_AuthorizeOperator_FullMethodName = "/lbm.collection.v1.Msg/AuthorizeOperator"
	Msg_RevokeOperator_FullMethodName    = "/lbm.collection.v1.Msg/RevokeOperator"
	Msg_CreateContract_FullMethodName    = "/lbm.collection.v1.Msg/CreateContract"
	Msg_IssueFT_FullMethodName           = "/lbm.collection.v1.Msg/IssueFT"
	Msg_IssueNFT_FullMethodName          = "/lbm.collection.v1.Msg/IssueNFT"
	Msg_MintFT_FullMethodName            = "/lbm.collection.v1.Msg/MintFT"
	Msg_MintNFT_FullMethodName           = "/lbm.collection.v1.Msg/MintNFT"
	Msg_BurnFT_FullMethodName            = "/lbm.collection.v1.Msg/BurnFT"
	Msg_OperatorBurnFT_FullMethodName    = "/lbm.collection.v1.Msg/OperatorBurnFT"
	Msg_BurnNFT_FullMethodName           = "/lbm.collection.v1.Msg/BurnNFT"
	Msg_OperatorBurnNFT_FullMethodName   = "/lbm.collection.v1.Msg/OperatorBurnNFT"
	Msg_Modify_FullMethodName            = "/lbm.collection.v1.Msg/Modify"
	Msg_GrantPermission_FullMethodName   = "/lbm.collection.v1.Msg/GrantPermission"
	Msg_RevokePermission_FullMethodName  = "/lbm.collection.v1.Msg/RevokePermission"
	Msg_Attach_FullMethodName            = "/lbm.collection.v1.Msg/Attach"
	Msg_Detach_FullMethodName            = "/lbm.collection.v1.Msg/Detach"
	Msg_OperatorAttach_FullMethodName    = "/lbm.collection.v1.Msg/OperatorAttach"
	Msg_OperatorDetach_FullMethodName    = "/lbm.collection.v1.Msg/OperatorDetach"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MsgClient interface {
	// SendFT defines a method to send fungible tokens from one account to another account.
	// Fires:
	// - EventSent
	SendFT(ctx context.Context, in *MsgSendFT, opts ...grpc.CallOption) (*MsgSendFTResponse, error)
	// OperatorSendFT defines a method to send fungible tokens from one account to another account by the operator.
	// Fires:
	// - EventSent
	OperatorSendFT(ctx context.Context, in *MsgOperatorSendFT, opts ...grpc.CallOption) (*MsgOperatorSendFTResponse, error)
	// SendNFT defines a method to send non-fungible tokens from one account to another account.
	// Fires:
	// - EventSent
	SendNFT(ctx context.Context, in *MsgSendNFT, opts ...grpc.CallOption) (*MsgSendNFTResponse, error)
	// OperatorSendNFT defines a method to send non-fungible tokens from one account to another account by the operator.
	// Fires:
	// - EventSent
	OperatorSendNFT(ctx context.Context, in *MsgOperatorSendNFT, opts ...grpc.CallOption) (*MsgOperatorSendNFTResponse, error)
	// AuthorizeOperator allows one to send tokens on behalf of the holder.
	// Fires:
	// - EventAuthorizedOperator
	AuthorizeOperator(ctx context.Context, in *MsgAuthorizeOperator, opts ...grpc.CallOption) (*MsgAuthorizeOperatorResponse, error)
	// RevokeOperator revokes the authorization of the operator to send the holder's token.
	// Fires:
	// - EventRevokedOperator
	RevokeOperator(ctx context.Context, in *MsgRevokeOperator, opts ...grpc.CallOption) (*MsgRevokeOperatorResponse, error)
	// CreateContract defines a method to create a contract for collection.
	// it grants `mint`, `burn`, `modify` and `issue` permissions on the contract to its creator.
	// Fires:
	// - EventCreatedContract
	CreateContract(ctx context.Context, in *MsgCreateContract, opts ...grpc.CallOption) (*MsgCreateContractResponse, error)
	// IssueFT defines a method to create a class of fungible token.
	// Fires:
	// - EventCreatedFTClass
	// - EventMintedFT
	// Note: it does not grant any permissions to its issuer.
	IssueFT(ctx context.Context, in *MsgIssueFT, opts ...grpc.CallOption) (*MsgIssueFTResponse, error)
	// IssueNFT defines a method to create a class of non-fungible token.
	// Fires:
	// - EventCreatedNFTClass
	// Note: it DOES grant `mint` and `burn` permissions to its issuer.
	IssueNFT(ctx context.Context, in *MsgIssueNFT, opts ...grpc.CallOption) (*MsgIssueNFTResponse, error)
	// MintFT defines a method to mint fungible tokens.
	// Fires:
	// - EventMintedFT
	MintFT(ctx context.Context, in *MsgMintFT, opts ...grpc.CallOption) (*MsgMintFTResponse, error)
	// MintNFT defines a method to mint non-fungible tokens.
	// Fires:
	// - EventMintedNFT
	MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error)
	// BurnFT defines a method to burn fungible tokens.
	// Fires:
	// - EventBurned
	BurnFT(ctx context.Context, in *MsgBurnFT, opts ...grpc.CallOption) (*MsgBurnFTResponse, error)
	// OperatorBurnFT defines a method to burn fungible tokens of the holder by the operator.
	// Fires:
	// - EventBurned
	OperatorBurnFT(ctx context.Context, in *MsgOperatorBurnFT, opts ...grpc.CallOption) (*MsgOperatorBurnFTResponse, error)
	// BurnNFT defines a method to burn non-fungible tokens.
	// Fires:
	// - EventBurned
	BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error)
	// OperatorBurnNFT defines a method to burn non-fungible tokens of the holder by the operator.
	// Fires:
	// - EventBurned
	OperatorBurnNFT(ctx context.Context, in *MsgOperatorBurnNFT, opts ...grpc.CallOption) (*MsgOperatorBurnNFTResponse, error)
	// Modify defines a method to modify metadata.
	// Fires:
	// - EventModifiedContract
	// - EventModifiedTokenClass
	// - EventModifiedNFT
	Modify(ctx context.Context, in *MsgModify, opts ...grpc.CallOption) (*MsgModifyResponse, error)
	// GrantPermission allows one to mint or burn tokens or modify metadata.
	// Fires:
	// - EventGranted
	GrantPermission(ctx context.Context, in *MsgGrantPermission, opts ...grpc.CallOption) (*MsgGrantPermissionResponse, error)
	// RevokePermission abandons a permission.
	// Fires:
	// - EventRenounced
	RevokePermission(ctx context.Context, in *MsgRevokePermission, opts ...grpc.CallOption) (*MsgRevokePermissionResponse, error)
	// Attach defines a method to attach a token to another token.
	// Fires:
	// - EventAttach
	// - attach (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	Attach(ctx context.Context, in *MsgAttach, opts ...grpc.CallOption) (*MsgAttachResponse, error)
	// Detach defines a method to detach a token from another token.
	// Fires:
	// - EventDetach
	// - detach (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	Detach(ctx context.Context, in *MsgDetach, opts ...grpc.CallOption) (*MsgDetachResponse, error)
	// OperatorAttach defines a method to attach a token to another token by operator.
	// Fires:
	// - EventAttach
	// - attach_from (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	OperatorAttach(ctx context.Context, in *MsgOperatorAttach, opts ...grpc.CallOption) (*MsgOperatorAttachResponse, error)
	// OperatorDetach defines a method to detach a token from another token by operator.
	// Fires:
	// - EventDetach
	// - detach_from (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	OperatorDetach(ctx context.Context, in *MsgOperatorDetach, opts ...grpc.CallOption) (*MsgOperatorDetachResponse, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) SendFT(ctx context.Context, in *MsgSendFT, opts ...grpc.CallOption) (*MsgSendFTResponse, error) {
	out := new(MsgSendFTResponse)
	err := c.cc.Invoke(ctx, Msg_SendFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorSendFT(ctx context.Context, in *MsgOperatorSendFT, opts ...grpc.CallOption) (*MsgOperatorSendFTResponse, error) {
	out := new(MsgOperatorSendFTResponse)
	err := c.cc.Invoke(ctx, Msg_OperatorSendFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SendNFT(ctx context.Context, in *MsgSendNFT, opts ...grpc.CallOption) (*MsgSendNFTResponse, error) {
	out := new(MsgSendNFTResponse)
	err := c.cc.Invoke(ctx, Msg_SendNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorSendNFT(ctx context.Context, in *MsgOperatorSendNFT, opts ...grpc.CallOption) (*MsgOperatorSendNFTResponse, error) {
	out := new(MsgOperatorSendNFTResponse)
	err := c.cc.Invoke(ctx, Msg_OperatorSendNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AuthorizeOperator(ctx context.Context, in *MsgAuthorizeOperator, opts ...grpc.CallOption) (*MsgAuthorizeOperatorResponse, error) {
	out := new(MsgAuthorizeOperatorResponse)
	err := c.cc.Invoke(ctx, Msg_AuthorizeOperator_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevokeOperator(ctx context.Context, in *MsgRevokeOperator, opts ...grpc.CallOption) (*MsgRevokeOperatorResponse, error) {
	out := new(MsgRevokeOperatorResponse)
	err := c.cc.Invoke(ctx, Msg_RevokeOperator_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateContract(ctx context.Context, in *MsgCreateContract, opts ...grpc.CallOption) (*MsgCreateContractResponse, error) {
	out := new(MsgCreateContractResponse)
	err := c.cc.Invoke(ctx, Msg_CreateContract_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IssueFT(ctx context.Context, in *MsgIssueFT, opts ...grpc.CallOption) (*MsgIssueFTResponse, error) {
	out := new(MsgIssueFTResponse)
	err := c.cc.Invoke(ctx, Msg_IssueFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IssueNFT(ctx context.Context, in *MsgIssueNFT, opts ...grpc.CallOption) (*MsgIssueNFTResponse, error) {
	out := new(MsgIssueNFTResponse)
	err := c.cc.Invoke(ctx, Msg_IssueNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintFT(ctx context.Context, in *MsgMintFT, opts ...grpc.CallOption) (*MsgMintFTResponse, error) {
	out := new(MsgMintFTResponse)
	err := c.cc.Invoke(ctx, Msg_MintFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error) {
	out := new(MsgMintNFTResponse)
	err := c.cc.Invoke(ctx, Msg_MintNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnFT(ctx context.Context, in *MsgBurnFT, opts ...grpc.CallOption) (*MsgBurnFTResponse, error) {
	out := new(MsgBurnFTResponse)
	err := c.cc.Invoke(ctx, Msg_BurnFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorBurnFT(ctx context.Context, in *MsgOperatorBurnFT, opts ...grpc.CallOption) (*MsgOperatorBurnFTResponse, error) {
	out := new(MsgOperatorBurnFTResponse)
	err := c.cc.Invoke(ctx, Msg_OperatorBurnFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error) {
	out := new(MsgBurnNFTResponse)
	err := c.cc.Invoke(ctx, Msg_BurnNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorBurnNFT(ctx context.Context, in *MsgOperatorBurnNFT, opts ...grpc.CallOption) (*MsgOperatorBurnNFTResponse, error) {
	out := new(MsgOperatorBurnNFTResponse)
	err := c.cc.Invoke(ctx, Msg_OperatorBurnNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Modify(ctx context.Context, in *MsgModify, opts ...grpc.CallOption) (*MsgModifyResponse, error) {
	out := new(MsgModifyResponse)
	err := c.cc.Invoke(ctx, Msg_Modify_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) GrantPermission(ctx context.Context, in *MsgGrantPermission, opts ...grpc.CallOption) (*MsgGrantPermissionResponse, error) {
	out := new(MsgGrantPermissionResponse)
	err := c.cc.Invoke(ctx, Msg_GrantPermission_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevokePermission(ctx context.Context, in *MsgRevokePermission, opts ...grpc.CallOption) (*MsgRevokePermissionResponse, error) {
	out := new(MsgRevokePermissionResponse)
	err := c.cc.Invoke(ctx, Msg_RevokePermission_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Attach(ctx context.Context, in *MsgAttach, opts ...grpc.CallOption) (*MsgAttachResponse, error) {
	out := new(MsgAttachResponse)
	err := c.cc.Invoke(ctx, Msg_Attach_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Detach(ctx context.Context, in *MsgDetach, opts ...grpc.CallOption) (*MsgDetachResponse, error) {
	out := new(MsgDetachResponse)
	err := c.cc.Invoke(ctx, Msg_Detach_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorAttach(ctx context.Context, in *MsgOperatorAttach, opts ...grpc.CallOption) (*MsgOperatorAttachResponse, error) {
	out := new(MsgOperatorAttachResponse)
	err := c.cc.Invoke(ctx, Msg_OperatorAttach_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorDetach(ctx context.Context, in *MsgOperatorDetach, opts ...grpc.CallOption) (*MsgOperatorDetachResponse, error) {
	out := new(MsgOperatorDetachResponse)
	err := c.cc.Invoke(ctx, Msg_OperatorDetach_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility
type MsgServer interface {
	// SendFT defines a method to send fungible tokens from one account to another account.
	// Fires:
	// - EventSent
	SendFT(context.Context, *MsgSendFT) (*MsgSendFTResponse, error)
	// OperatorSendFT defines a method to send fungible tokens from one account to another account by the operator.
	// Fires:
	// - EventSent
	OperatorSendFT(context.Context, *MsgOperatorSendFT) (*MsgOperatorSendFTResponse, error)
	// SendNFT defines a method to send non-fungible tokens from one account to another account.
	// Fires:
	// - EventSent
	SendNFT(context.Context, *MsgSendNFT) (*MsgSendNFTResponse, error)
	// OperatorSendNFT defines a method to send non-fungible tokens from one account to another account by the operator.
	// Fires:
	// - EventSent
	OperatorSendNFT(context.Context, *MsgOperatorSendNFT) (*MsgOperatorSendNFTResponse, error)
	// AuthorizeOperator allows one to send tokens on behalf of the holder.
	// Fires:
	// - EventAuthorizedOperator
	AuthorizeOperator(context.Context, *MsgAuthorizeOperator) (*MsgAuthorizeOperatorResponse, error)
	// RevokeOperator revokes the authorization of the operator to send the holder's token.
	// Fires:
	// - EventRevokedOperator
	RevokeOperator(context.Context, *MsgRevokeOperator) (*MsgRevokeOperatorResponse, error)
	// CreateContract defines a method to create a contract for collection.
	// it grants `mint`, `burn`, `modify` and `issue` permissions on the contract to its creator.
	// Fires:
	// - EventCreatedContract
	CreateContract(context.Context, *MsgCreateContract) (*MsgCreateContractResponse, error)
	// IssueFT defines a method to create a class of fungible token.
	// Fires:
	// - EventCreatedFTClass
	// - EventMintedFT
	// Note: it does not grant any permissions to its issuer.
	IssueFT(context.Context, *MsgIssueFT) (*MsgIssueFTResponse, error)
	// IssueNFT defines a method to create a class of non-fungible token.
	// Fires:
	// - EventCreatedNFTClass
	// Note: it DOES grant `mint` and `burn` permissions to its issuer.
	IssueNFT(context.Context, *MsgIssueNFT) (*MsgIssueNFTResponse, error)
	// MintFT defines a method to mint fungible tokens.
	// Fires:
	// - EventMintedFT
	MintFT(context.Context, *MsgMintFT) (*MsgMintFTResponse, error)
	// MintNFT defines a method to mint non-fungible tokens.
	// Fires:
	// - EventMintedNFT
	MintNFT(context.Context, *MsgMintNFT) (*MsgMintNFTResponse, error)
	// BurnFT defines a method to burn fungible tokens.
	// Fires:
	// - EventBurned
	BurnFT(context.Context, *MsgBurnFT) (*MsgBurnFTResponse, error)
	// OperatorBurnFT defines a method to burn fungible tokens of the holder by the operator.
	// Fires:
	// - EventBurned
	OperatorBurnFT(context.Context, *MsgOperatorBurnFT) (*MsgOperatorBurnFTResponse, error)
	// BurnNFT defines a method to burn non-fungible tokens.
	// Fires:
	// - EventBurned
	BurnNFT(context.Context, *MsgBurnNFT) (*MsgBurnNFTResponse, error)
	// OperatorBurnNFT defines a method to burn non-fungible tokens of the holder by the operator.
	// Fires:
	// - EventBurned
	OperatorBurnNFT(context.Context, *MsgOperatorBurnNFT) (*MsgOperatorBurnNFTResponse, error)
	// Modify defines a method to modify metadata.
	// Fires:
	// - EventModifiedContract
	// - EventModifiedTokenClass
	// - EventModifiedNFT
	Modify(context.Context, *MsgModify) (*MsgModifyResponse, error)
	// GrantPermission allows one to mint or burn tokens or modify metadata.
	// Fires:
	// - EventGranted
	GrantPermission(context.Context, *MsgGrantPermission) (*MsgGrantPermissionResponse, error)
	// RevokePermission abandons a permission.
	// Fires:
	// - EventRenounced
	RevokePermission(context.Context, *MsgRevokePermission) (*MsgRevokePermissionResponse, error)
	// Attach defines a method to attach a token to another token.
	// Fires:
	// - EventAttach
	// - attach (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	Attach(context.Context, *MsgAttach) (*MsgAttachResponse, error)
	// Detach defines a method to detach a token from another token.
	// Fires:
	// - EventDetach
	// - detach (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	Detach(context.Context, *MsgDetach) (*MsgDetachResponse, error)
	// OperatorAttach defines a method to attach a token to another token by operator.
	// Fires:
	// - EventAttach
	// - attach_from (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	OperatorAttach(context.Context, *MsgOperatorAttach) (*MsgOperatorAttachResponse, error)
	// OperatorDetach defines a method to detach a token from another token by operator.
	// Fires:
	// - EventDetach
	// - detach_from (deprecated, not typed)
	// - operation_root_changed (deprecated, not typed)
	OperatorDetach(context.Context, *MsgOperatorDetach) (*MsgOperatorDetachResponse, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (UnimplementedMsgServer) SendFT(context.Context, *MsgSendFT) (*MsgSendFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendFT not implemented")
}
func (UnimplementedMsgServer) OperatorSendFT(context.Context, *MsgOperatorSendFT) (*MsgOperatorSendFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorSendFT not implemented")
}
func (UnimplementedMsgServer) SendNFT(context.Context, *MsgSendNFT) (*MsgSendNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendNFT not implemented")
}
func (UnimplementedMsgServer) OperatorSendNFT(context.Context, *MsgOperatorSendNFT) (*MsgOperatorSendNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorSendNFT not implemented")
}
func (UnimplementedMsgServer) AuthorizeOperator(context.Context, *MsgAuthorizeOperator) (*MsgAuthorizeOperatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthorizeOperator not implemented")
}
func (UnimplementedMsgServer) RevokeOperator(context.Context, *MsgRevokeOperator) (*MsgRevokeOperatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeOperator not implemented")
}
func (UnimplementedMsgServer) CreateContract(context.Context, *MsgCreateContract) (*MsgCreateContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContract not implemented")
}
func (UnimplementedMsgServer) IssueFT(context.Context, *MsgIssueFT) (*MsgIssueFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IssueFT not implemented")
}
func (UnimplementedMsgServer) IssueNFT(context.Context, *MsgIssueNFT) (*MsgIssueNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IssueNFT not implemented")
}
func (UnimplementedMsgServer) MintFT(context.Context, *MsgMintFT) (*MsgMintFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintFT not implemented")
}
func (UnimplementedMsgServer) MintNFT(context.Context, *MsgMintNFT) (*MsgMintNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintNFT not implemented")
}
func (UnimplementedMsgServer) BurnFT(context.Context, *MsgBurnFT) (*MsgBurnFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnFT not implemented")
}
func (UnimplementedMsgServer) OperatorBurnFT(context.Context, *MsgOperatorBurnFT) (*MsgOperatorBurnFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorBurnFT not implemented")
}
func (UnimplementedMsgServer) BurnNFT(context.Context, *MsgBurnNFT) (*MsgBurnNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnNFT not implemented")
}
func (UnimplementedMsgServer) OperatorBurnNFT(context.Context, *MsgOperatorBurnNFT) (*MsgOperatorBurnNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorBurnNFT not implemented")
}
func (UnimplementedMsgServer) Modify(context.Context, *MsgModify) (*MsgModifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Modify not implemented")
}
func (UnimplementedMsgServer) GrantPermission(context.Context, *MsgGrantPermission) (*MsgGrantPermissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantPermission not implemented")
}
func (UnimplementedMsgServer) RevokePermission(context.Context, *MsgRevokePermission) (*MsgRevokePermissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokePermission not implemented")
}
func (UnimplementedMsgServer) Attach(context.Context, *MsgAttach) (*MsgAttachResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Attach not implemented")
}
func (UnimplementedMsgServer) Detach(context.Context, *MsgDetach) (*MsgDetachResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detach not implemented")
}
func (UnimplementedMsgServer) OperatorAttach(context.Context, *MsgOperatorAttach) (*MsgOperatorAttachResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorAttach not implemented")
}
func (UnimplementedMsgServer) OperatorDetach(context.Context, *MsgOperatorDetach) (*MsgOperatorDetachResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorDetach not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_SendFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SendFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SendFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SendFT(ctx, req.(*MsgSendFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorSendFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorSendFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorSendFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_OperatorSendFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorSendFT(ctx, req.(*MsgOperatorSendFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SendNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SendNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SendNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SendNFT(ctx, req.(*MsgSendNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorSendNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorSendNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorSendNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_OperatorSendNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorSendNFT(ctx, req.(*MsgOperatorSendNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AuthorizeOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAuthorizeOperator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AuthorizeOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AuthorizeOperator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AuthorizeOperator(ctx, req.(*MsgAuthorizeOperator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevokeOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevokeOperator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevokeOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RevokeOperator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevokeOperator(ctx, req.(*MsgRevokeOperator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateContract(ctx, req.(*MsgCreateContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IssueFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIssueFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IssueFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_IssueFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IssueFT(ctx, req.(*MsgIssueFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IssueNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIssueNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IssueNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_IssueNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IssueNFT(ctx, req.(*MsgIssueNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_MintFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintFT(ctx, req.(*MsgMintFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_MintNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintNFT(ctx, req.(*MsgMintNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BurnFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnFT(ctx, req.(*MsgBurnFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorBurnFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorBurnFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorBurnFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_OperatorBurnFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorBurnFT(ctx, req.(*MsgOperatorBurnFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BurnNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnNFT(ctx, req.(*MsgBurnNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorBurnNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorBurnNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorBurnNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_OperatorBurnNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorBurnNFT(ctx, req.(*MsgOperatorBurnNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Modify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgModify)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Modify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Modify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Modify(ctx, req.(*MsgModify))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_GrantPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGrantPermission)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).GrantPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_GrantPermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).GrantPermission(ctx, req.(*MsgGrantPermission))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevokePermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevokePermission)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevokePermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RevokePermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevokePermission(ctx, req.(*MsgRevokePermission))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Attach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAttach)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Attach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Attach_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Attach(ctx, req.(*MsgAttach))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Detach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDetach)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Detach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Detach_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Detach(ctx, req.(*MsgDetach))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorAttach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorAttach)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorAttach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_OperatorAttach_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorAttach(ctx, req.(*MsgOperatorAttach))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorDetach_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorDetach)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorDetach(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_OperatorDetach_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorDetach(ctx, req.(*MsgOperatorDetach))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lbm.collection.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendFT",
			Handler:    _Msg_SendFT_Handler,
		},
		{
			MethodName: "OperatorSendFT",
			Handler:    _Msg_OperatorSendFT_Handler,
		},
		{
			MethodName: "SendNFT",
			Handler:    _Msg_SendNFT_Handler,
		},
		{
			MethodName: "OperatorSendNFT",
			Handler:    _Msg_OperatorSendNFT_Handler,
		},
		{
			MethodName: "AuthorizeOperator",
			Handler:    _Msg_AuthorizeOperator_Handler,
		},
		{
			MethodName: "RevokeOperator",
			Handler:    _Msg_RevokeOperator_Handler,
		},
		{
			MethodName: "CreateContract",
			Handler:    _Msg_CreateContract_Handler,
		},
		{
			MethodName: "IssueFT",
			Handler:    _Msg_IssueFT_Handler,
		},
		{
			MethodName: "IssueNFT",
			Handler:    _Msg_IssueNFT_Handler,
		},
		{
			MethodName: "MintFT",
			Handler:    _Msg_MintFT_Handler,
		},
		{
			MethodName: "MintNFT",
			Handler:    _Msg_MintNFT_Handler,
		},
		{
			MethodName: "BurnFT",
			Handler:    _Msg_BurnFT_Handler,
		},
		{
			MethodName: "OperatorBurnFT",
			Handler:    _Msg_OperatorBurnFT_Handler,
		},
		{
			MethodName: "BurnNFT",
			Handler:    _Msg_BurnNFT_Handler,
		},
		{
			MethodName: "OperatorBurnNFT",
			Handler:    _Msg_OperatorBurnNFT_Handler,
		},
		{
			MethodName: "Modify",
			Handler:    _Msg_Modify_Handler,
		},
		{
			MethodName: "GrantPermission",
			Handler:    _Msg_GrantPermission_Handler,
		},
		{
			MethodName: "RevokePermission",
			Handler:    _Msg_RevokePermission_Handler,
		},
		{
			MethodName: "Attach",
			Handler:    _Msg_Attach_Handler,
		},
		{
			MethodName: "Detach",
			Handler:    _Msg_Detach_Handler,
		},
		{
			MethodName: "OperatorAttach",
			Handler:    _Msg_OperatorAttach_Handler,
		},
		{
			MethodName: "OperatorDetach",
			Handler:    _Msg_OperatorDetach_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lbm/collection/v1/tx.proto",
}
