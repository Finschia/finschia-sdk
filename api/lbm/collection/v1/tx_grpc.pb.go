// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: lbm/collection/v1/tx.proto

package collectionv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Msg_SendNFT_FullMethodName           = "/lbm.collection.v1.Msg/SendNFT"
	Msg_OperatorSendNFT_FullMethodName   = "/lbm.collection.v1.Msg/OperatorSendNFT"
	Msg_AuthorizeOperator_FullMethodName = "/lbm.collection.v1.Msg/AuthorizeOperator"
	Msg_RevokeOperator_FullMethodName    = "/lbm.collection.v1.Msg/RevokeOperator"
	Msg_CreateContract_FullMethodName    = "/lbm.collection.v1.Msg/CreateContract"
	Msg_IssueNFT_FullMethodName          = "/lbm.collection.v1.Msg/IssueNFT"
	Msg_MintNFT_FullMethodName           = "/lbm.collection.v1.Msg/MintNFT"
	Msg_BurnNFT_FullMethodName           = "/lbm.collection.v1.Msg/BurnNFT"
	Msg_OperatorBurnNFT_FullMethodName   = "/lbm.collection.v1.Msg/OperatorBurnNFT"
	Msg_Modify_FullMethodName            = "/lbm.collection.v1.Msg/Modify"
	Msg_GrantPermission_FullMethodName   = "/lbm.collection.v1.Msg/GrantPermission"
	Msg_RevokePermission_FullMethodName  = "/lbm.collection.v1.Msg/RevokePermission"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MsgClient interface {
	// SendNFT defines a method to send non-fungible tokens from one account to another account.
	// Fires:
	// - EventSent
	SendNFT(ctx context.Context, in *MsgSendNFT, opts ...grpc.CallOption) (*MsgSendNFTResponse, error)
	// OperatorSendNFT defines a method to send non-fungible tokens from one account to another account by the operator.
	// Fires:
	// - EventSent
	OperatorSendNFT(ctx context.Context, in *MsgOperatorSendNFT, opts ...grpc.CallOption) (*MsgOperatorSendNFTResponse, error)
	// AuthorizeOperator allows one to send tokens on behalf of the holder.
	// Fires:
	// - EventAuthorizedOperator
	AuthorizeOperator(ctx context.Context, in *MsgAuthorizeOperator, opts ...grpc.CallOption) (*MsgAuthorizeOperatorResponse, error)
	// RevokeOperator revokes the authorization of the operator to send the holder's token.
	// Fires:
	// - EventRevokedOperator
	RevokeOperator(ctx context.Context, in *MsgRevokeOperator, opts ...grpc.CallOption) (*MsgRevokeOperatorResponse, error)
	// CreateContract defines a method to create a contract for collection.
	// it grants `mint`, `burn`, `modify` and `issue` permissions on the contract to its creator.
	// Fires:
	// - EventCreatedContract
	CreateContract(ctx context.Context, in *MsgCreateContract, opts ...grpc.CallOption) (*MsgCreateContractResponse, error)
	// IssueNFT defines a method to create a class of non-fungible token.
	// Fires:
	// - EventCreatedNFTClass
	// Note: it DOES grant `mint` and `burn` permissions to its issuer.
	IssueNFT(ctx context.Context, in *MsgIssueNFT, opts ...grpc.CallOption) (*MsgIssueNFTResponse, error)
	// MintNFT defines a method to mint non-fungible tokens.
	// Fires:
	// - EventMintedNFT
	MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error)
	// BurnNFT defines a method to burn non-fungible tokens.
	// Fires:
	// - EventBurned
	BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error)
	// OperatorBurnNFT defines a method to burn non-fungible tokens of the holder by the operator.
	// Fires:
	// - EventBurned
	OperatorBurnNFT(ctx context.Context, in *MsgOperatorBurnNFT, opts ...grpc.CallOption) (*MsgOperatorBurnNFTResponse, error)
	// Modify defines a method to modify metadata.
	// Fires:
	// - EventModifiedContract
	// - EventModifiedTokenClass
	// - EventModifiedNFT
	Modify(ctx context.Context, in *MsgModify, opts ...grpc.CallOption) (*MsgModifyResponse, error)
	// GrantPermission allows one to mint or burn tokens or modify metadata.
	// Fires:
	// - EventGranted
	GrantPermission(ctx context.Context, in *MsgGrantPermission, opts ...grpc.CallOption) (*MsgGrantPermissionResponse, error)
	// RevokePermission abandons a permission.
	// Fires:
	// - EventRenounced
	RevokePermission(ctx context.Context, in *MsgRevokePermission, opts ...grpc.CallOption) (*MsgRevokePermissionResponse, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) SendNFT(ctx context.Context, in *MsgSendNFT, opts ...grpc.CallOption) (*MsgSendNFTResponse, error) {
	out := new(MsgSendNFTResponse)
	err := c.cc.Invoke(ctx, Msg_SendNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorSendNFT(ctx context.Context, in *MsgOperatorSendNFT, opts ...grpc.CallOption) (*MsgOperatorSendNFTResponse, error) {
	out := new(MsgOperatorSendNFTResponse)
	err := c.cc.Invoke(ctx, Msg_OperatorSendNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AuthorizeOperator(ctx context.Context, in *MsgAuthorizeOperator, opts ...grpc.CallOption) (*MsgAuthorizeOperatorResponse, error) {
	out := new(MsgAuthorizeOperatorResponse)
	err := c.cc.Invoke(ctx, Msg_AuthorizeOperator_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevokeOperator(ctx context.Context, in *MsgRevokeOperator, opts ...grpc.CallOption) (*MsgRevokeOperatorResponse, error) {
	out := new(MsgRevokeOperatorResponse)
	err := c.cc.Invoke(ctx, Msg_RevokeOperator_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateContract(ctx context.Context, in *MsgCreateContract, opts ...grpc.CallOption) (*MsgCreateContractResponse, error) {
	out := new(MsgCreateContractResponse)
	err := c.cc.Invoke(ctx, Msg_CreateContract_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) IssueNFT(ctx context.Context, in *MsgIssueNFT, opts ...grpc.CallOption) (*MsgIssueNFTResponse, error) {
	out := new(MsgIssueNFTResponse)
	err := c.cc.Invoke(ctx, Msg_IssueNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) MintNFT(ctx context.Context, in *MsgMintNFT, opts ...grpc.CallOption) (*MsgMintNFTResponse, error) {
	out := new(MsgMintNFTResponse)
	err := c.cc.Invoke(ctx, Msg_MintNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) BurnNFT(ctx context.Context, in *MsgBurnNFT, opts ...grpc.CallOption) (*MsgBurnNFTResponse, error) {
	out := new(MsgBurnNFTResponse)
	err := c.cc.Invoke(ctx, Msg_BurnNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) OperatorBurnNFT(ctx context.Context, in *MsgOperatorBurnNFT, opts ...grpc.CallOption) (*MsgOperatorBurnNFTResponse, error) {
	out := new(MsgOperatorBurnNFTResponse)
	err := c.cc.Invoke(ctx, Msg_OperatorBurnNFT_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Modify(ctx context.Context, in *MsgModify, opts ...grpc.CallOption) (*MsgModifyResponse, error) {
	out := new(MsgModifyResponse)
	err := c.cc.Invoke(ctx, Msg_Modify_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) GrantPermission(ctx context.Context, in *MsgGrantPermission, opts ...grpc.CallOption) (*MsgGrantPermissionResponse, error) {
	out := new(MsgGrantPermissionResponse)
	err := c.cc.Invoke(ctx, Msg_GrantPermission_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevokePermission(ctx context.Context, in *MsgRevokePermission, opts ...grpc.CallOption) (*MsgRevokePermissionResponse, error) {
	out := new(MsgRevokePermissionResponse)
	err := c.cc.Invoke(ctx, Msg_RevokePermission_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility
type MsgServer interface {
	// SendNFT defines a method to send non-fungible tokens from one account to another account.
	// Fires:
	// - EventSent
	SendNFT(context.Context, *MsgSendNFT) (*MsgSendNFTResponse, error)
	// OperatorSendNFT defines a method to send non-fungible tokens from one account to another account by the operator.
	// Fires:
	// - EventSent
	OperatorSendNFT(context.Context, *MsgOperatorSendNFT) (*MsgOperatorSendNFTResponse, error)
	// AuthorizeOperator allows one to send tokens on behalf of the holder.
	// Fires:
	// - EventAuthorizedOperator
	AuthorizeOperator(context.Context, *MsgAuthorizeOperator) (*MsgAuthorizeOperatorResponse, error)
	// RevokeOperator revokes the authorization of the operator to send the holder's token.
	// Fires:
	// - EventRevokedOperator
	RevokeOperator(context.Context, *MsgRevokeOperator) (*MsgRevokeOperatorResponse, error)
	// CreateContract defines a method to create a contract for collection.
	// it grants `mint`, `burn`, `modify` and `issue` permissions on the contract to its creator.
	// Fires:
	// - EventCreatedContract
	CreateContract(context.Context, *MsgCreateContract) (*MsgCreateContractResponse, error)
	// IssueNFT defines a method to create a class of non-fungible token.
	// Fires:
	// - EventCreatedNFTClass
	// Note: it DOES grant `mint` and `burn` permissions to its issuer.
	IssueNFT(context.Context, *MsgIssueNFT) (*MsgIssueNFTResponse, error)
	// MintNFT defines a method to mint non-fungible tokens.
	// Fires:
	// - EventMintedNFT
	MintNFT(context.Context, *MsgMintNFT) (*MsgMintNFTResponse, error)
	// BurnNFT defines a method to burn non-fungible tokens.
	// Fires:
	// - EventBurned
	BurnNFT(context.Context, *MsgBurnNFT) (*MsgBurnNFTResponse, error)
	// OperatorBurnNFT defines a method to burn non-fungible tokens of the holder by the operator.
	// Fires:
	// - EventBurned
	OperatorBurnNFT(context.Context, *MsgOperatorBurnNFT) (*MsgOperatorBurnNFTResponse, error)
	// Modify defines a method to modify metadata.
	// Fires:
	// - EventModifiedContract
	// - EventModifiedTokenClass
	// - EventModifiedNFT
	Modify(context.Context, *MsgModify) (*MsgModifyResponse, error)
	// GrantPermission allows one to mint or burn tokens or modify metadata.
	// Fires:
	// - EventGranted
	GrantPermission(context.Context, *MsgGrantPermission) (*MsgGrantPermissionResponse, error)
	// RevokePermission abandons a permission.
	// Fires:
	// - EventRenounced
	RevokePermission(context.Context, *MsgRevokePermission) (*MsgRevokePermissionResponse, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (UnimplementedMsgServer) SendNFT(context.Context, *MsgSendNFT) (*MsgSendNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendNFT not implemented")
}
func (UnimplementedMsgServer) OperatorSendNFT(context.Context, *MsgOperatorSendNFT) (*MsgOperatorSendNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorSendNFT not implemented")
}
func (UnimplementedMsgServer) AuthorizeOperator(context.Context, *MsgAuthorizeOperator) (*MsgAuthorizeOperatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthorizeOperator not implemented")
}
func (UnimplementedMsgServer) RevokeOperator(context.Context, *MsgRevokeOperator) (*MsgRevokeOperatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeOperator not implemented")
}
func (UnimplementedMsgServer) CreateContract(context.Context, *MsgCreateContract) (*MsgCreateContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateContract not implemented")
}
func (UnimplementedMsgServer) IssueNFT(context.Context, *MsgIssueNFT) (*MsgIssueNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IssueNFT not implemented")
}
func (UnimplementedMsgServer) MintNFT(context.Context, *MsgMintNFT) (*MsgMintNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MintNFT not implemented")
}
func (UnimplementedMsgServer) BurnNFT(context.Context, *MsgBurnNFT) (*MsgBurnNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BurnNFT not implemented")
}
func (UnimplementedMsgServer) OperatorBurnNFT(context.Context, *MsgOperatorBurnNFT) (*MsgOperatorBurnNFTResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperatorBurnNFT not implemented")
}
func (UnimplementedMsgServer) Modify(context.Context, *MsgModify) (*MsgModifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Modify not implemented")
}
func (UnimplementedMsgServer) GrantPermission(context.Context, *MsgGrantPermission) (*MsgGrantPermissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrantPermission not implemented")
}
func (UnimplementedMsgServer) RevokePermission(context.Context, *MsgRevokePermission) (*MsgRevokePermissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokePermission not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_SendNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SendNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_SendNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SendNFT(ctx, req.(*MsgSendNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorSendNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorSendNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorSendNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_OperatorSendNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorSendNFT(ctx, req.(*MsgOperatorSendNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AuthorizeOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAuthorizeOperator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AuthorizeOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AuthorizeOperator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AuthorizeOperator(ctx, req.(*MsgAuthorizeOperator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevokeOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevokeOperator)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevokeOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RevokeOperator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevokeOperator(ctx, req.(*MsgRevokeOperator))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateContract)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_CreateContract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateContract(ctx, req.(*MsgCreateContract))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_IssueNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgIssueNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).IssueNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_IssueNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).IssueNFT(ctx, req.(*MsgIssueNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_MintNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgMintNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).MintNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_MintNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).MintNFT(ctx, req.(*MsgMintNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_BurnNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgBurnNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).BurnNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_BurnNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).BurnNFT(ctx, req.(*MsgBurnNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_OperatorBurnNFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOperatorBurnNFT)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).OperatorBurnNFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_OperatorBurnNFT_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).OperatorBurnNFT(ctx, req.(*MsgOperatorBurnNFT))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Modify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgModify)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Modify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_Modify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Modify(ctx, req.(*MsgModify))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_GrantPermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGrantPermission)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).GrantPermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_GrantPermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).GrantPermission(ctx, req.(*MsgGrantPermission))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevokePermission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevokePermission)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevokePermission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RevokePermission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevokePermission(ctx, req.(*MsgRevokePermission))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lbm.collection.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendNFT",
			Handler:    _Msg_SendNFT_Handler,
		},
		{
			MethodName: "OperatorSendNFT",
			Handler:    _Msg_OperatorSendNFT_Handler,
		},
		{
			MethodName: "AuthorizeOperator",
			Handler:    _Msg_AuthorizeOperator_Handler,
		},
		{
			MethodName: "RevokeOperator",
			Handler:    _Msg_RevokeOperator_Handler,
		},
		{
			MethodName: "CreateContract",
			Handler:    _Msg_CreateContract_Handler,
		},
		{
			MethodName: "IssueNFT",
			Handler:    _Msg_IssueNFT_Handler,
		},
		{
			MethodName: "MintNFT",
			Handler:    _Msg_MintNFT_Handler,
		},
		{
			MethodName: "BurnNFT",
			Handler:    _Msg_BurnNFT_Handler,
		},
		{
			MethodName: "OperatorBurnNFT",
			Handler:    _Msg_OperatorBurnNFT_Handler,
		},
		{
			MethodName: "Modify",
			Handler:    _Msg_Modify_Handler,
		},
		{
			MethodName: "GrantPermission",
			Handler:    _Msg_GrantPermission_Handler,
		},
		{
			MethodName: "RevokePermission",
			Handler:    _Msg_RevokePermission_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lbm/collection/v1/tx.proto",
}
