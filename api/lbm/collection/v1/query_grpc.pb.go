// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: lbm/collection/v1/query.proto

package collectionv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Query_Balance_FullMethodName            = "/lbm.collection.v1.Query/Balance"
	Query_AllBalances_FullMethodName        = "/lbm.collection.v1.Query/AllBalances"
	Query_FTSupply_FullMethodName           = "/lbm.collection.v1.Query/FTSupply"
	Query_FTMinted_FullMethodName           = "/lbm.collection.v1.Query/FTMinted"
	Query_FTBurnt_FullMethodName            = "/lbm.collection.v1.Query/FTBurnt"
	Query_NFTSupply_FullMethodName          = "/lbm.collection.v1.Query/NFTSupply"
	Query_NFTMinted_FullMethodName          = "/lbm.collection.v1.Query/NFTMinted"
	Query_NFTBurnt_FullMethodName           = "/lbm.collection.v1.Query/NFTBurnt"
	Query_Contract_FullMethodName           = "/lbm.collection.v1.Query/Contract"
	Query_TokenClassTypeName_FullMethodName = "/lbm.collection.v1.Query/TokenClassTypeName"
	Query_TokenType_FullMethodName          = "/lbm.collection.v1.Query/TokenType"
	Query_Token_FullMethodName              = "/lbm.collection.v1.Query/Token"
	Query_Root_FullMethodName               = "/lbm.collection.v1.Query/Root"
	Query_HasParent_FullMethodName          = "/lbm.collection.v1.Query/HasParent"
	Query_Parent_FullMethodName             = "/lbm.collection.v1.Query/Parent"
	Query_Children_FullMethodName           = "/lbm.collection.v1.Query/Children"
	Query_GranteeGrants_FullMethodName      = "/lbm.collection.v1.Query/GranteeGrants"
	Query_IsOperatorFor_FullMethodName      = "/lbm.collection.v1.Query/IsOperatorFor"
	Query_HoldersByOperator_FullMethodName  = "/lbm.collection.v1.Query/HoldersByOperator"
)

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type QueryClient interface {
	// Balance queries the balance of a single token class for a single account.
	Balance(ctx context.Context, in *QueryBalanceRequest, opts ...grpc.CallOption) (*QueryBalanceResponse, error)
	// AllBalances queries the balance of all token classes for a single account.
	AllBalances(ctx context.Context, in *QueryAllBalancesRequest, opts ...grpc.CallOption) (*QueryAllBalancesResponse, error)
	// FTSupply queries the number of tokens from a given contract id and token id.
	FTSupply(ctx context.Context, in *QueryFTSupplyRequest, opts ...grpc.CallOption) (*QueryFTSupplyResponse, error)
	// FTMinted queries the number of minted tokens from a given contract id and token id.
	FTMinted(ctx context.Context, in *QueryFTMintedRequest, opts ...grpc.CallOption) (*QueryFTMintedResponse, error)
	// FTBurnt queries the number of burnt tokens from a given contract id and token id.
	FTBurnt(ctx context.Context, in *QueryFTBurntRequest, opts ...grpc.CallOption) (*QueryFTBurntResponse, error)
	// NFTSupply queries the number of tokens from a given contract id and token type.
	NFTSupply(ctx context.Context, in *QueryNFTSupplyRequest, opts ...grpc.CallOption) (*QueryNFTSupplyResponse, error)
	// NFTMinted queries the number of minted tokens from a given contract id and token type.
	NFTMinted(ctx context.Context, in *QueryNFTMintedRequest, opts ...grpc.CallOption) (*QueryNFTMintedResponse, error)
	// NFTBurnt queries the number of burnt tokens from a given contract id and token type.
	NFTBurnt(ctx context.Context, in *QueryNFTBurntRequest, opts ...grpc.CallOption) (*QueryNFTBurntResponse, error)
	// Contract queries a contract metadata based on its contract id.
	Contract(ctx context.Context, in *QueryContractRequest, opts ...grpc.CallOption) (*QueryContractResponse, error)
	// TokenClassTypeName queries the fully qualified message type name of a token class from its class id.
	//
	// Since: 0.46.0 (finschia)
	TokenClassTypeName(ctx context.Context, in *QueryTokenClassTypeNameRequest, opts ...grpc.CallOption) (*QueryTokenClassTypeNameResponse, error)
	// TokenType queries metadata of a token type.
	TokenType(ctx context.Context, in *QueryTokenTypeRequest, opts ...grpc.CallOption) (*QueryTokenTypeResponse, error)
	// Token queries a metadata of a token from its token id.
	Token(ctx context.Context, in *QueryTokenRequest, opts ...grpc.CallOption) (*QueryTokenResponse, error)
	// Root queries the root of a given nft.
	Root(ctx context.Context, in *QueryRootRequest, opts ...grpc.CallOption) (*QueryRootResponse, error)
	// HasParent queries whether a given nft has its parent.
	HasParent(ctx context.Context, in *QueryHasParentRequest, opts ...grpc.CallOption) (*QueryHasParentResponse, error)
	// Parent queries the parent of a given nft.
	Parent(ctx context.Context, in *QueryParentRequest, opts ...grpc.CallOption) (*QueryParentResponse, error)
	// Children queries the children of a given nft.
	Children(ctx context.Context, in *QueryChildrenRequest, opts ...grpc.CallOption) (*QueryChildrenResponse, error)
	// GranteeGrants queries all permissions on a given grantee.
	GranteeGrants(ctx context.Context, in *QueryGranteeGrantsRequest, opts ...grpc.CallOption) (*QueryGranteeGrantsResponse, error)
	// IsOperatorFor queries whether the operator is authorized by the holder.
	IsOperatorFor(ctx context.Context, in *QueryIsOperatorForRequest, opts ...grpc.CallOption) (*QueryIsOperatorForResponse, error)
	// HoldersByOperator queries holders of a given operator.
	HoldersByOperator(ctx context.Context, in *QueryHoldersByOperatorRequest, opts ...grpc.CallOption) (*QueryHoldersByOperatorResponse, error)
}

type queryClient struct {
	cc grpc.ClientConnInterface
}

func NewQueryClient(cc grpc.ClientConnInterface) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Balance(ctx context.Context, in *QueryBalanceRequest, opts ...grpc.CallOption) (*QueryBalanceResponse, error) {
	out := new(QueryBalanceResponse)
	err := c.cc.Invoke(ctx, Query_Balance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AllBalances(ctx context.Context, in *QueryAllBalancesRequest, opts ...grpc.CallOption) (*QueryAllBalancesResponse, error) {
	out := new(QueryAllBalancesResponse)
	err := c.cc.Invoke(ctx, Query_AllBalances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) FTSupply(ctx context.Context, in *QueryFTSupplyRequest, opts ...grpc.CallOption) (*QueryFTSupplyResponse, error) {
	out := new(QueryFTSupplyResponse)
	err := c.cc.Invoke(ctx, Query_FTSupply_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) FTMinted(ctx context.Context, in *QueryFTMintedRequest, opts ...grpc.CallOption) (*QueryFTMintedResponse, error) {
	out := new(QueryFTMintedResponse)
	err := c.cc.Invoke(ctx, Query_FTMinted_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) FTBurnt(ctx context.Context, in *QueryFTBurntRequest, opts ...grpc.CallOption) (*QueryFTBurntResponse, error) {
	out := new(QueryFTBurntResponse)
	err := c.cc.Invoke(ctx, Query_FTBurnt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) NFTSupply(ctx context.Context, in *QueryNFTSupplyRequest, opts ...grpc.CallOption) (*QueryNFTSupplyResponse, error) {
	out := new(QueryNFTSupplyResponse)
	err := c.cc.Invoke(ctx, Query_NFTSupply_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) NFTMinted(ctx context.Context, in *QueryNFTMintedRequest, opts ...grpc.CallOption) (*QueryNFTMintedResponse, error) {
	out := new(QueryNFTMintedResponse)
	err := c.cc.Invoke(ctx, Query_NFTMinted_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) NFTBurnt(ctx context.Context, in *QueryNFTBurntRequest, opts ...grpc.CallOption) (*QueryNFTBurntResponse, error) {
	out := new(QueryNFTBurntResponse)
	err := c.cc.Invoke(ctx, Query_NFTBurnt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Contract(ctx context.Context, in *QueryContractRequest, opts ...grpc.CallOption) (*QueryContractResponse, error) {
	out := new(QueryContractResponse)
	err := c.cc.Invoke(ctx, Query_Contract_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TokenClassTypeName(ctx context.Context, in *QueryTokenClassTypeNameRequest, opts ...grpc.CallOption) (*QueryTokenClassTypeNameResponse, error) {
	out := new(QueryTokenClassTypeNameResponse)
	err := c.cc.Invoke(ctx, Query_TokenClassTypeName_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) TokenType(ctx context.Context, in *QueryTokenTypeRequest, opts ...grpc.CallOption) (*QueryTokenTypeResponse, error) {
	out := new(QueryTokenTypeResponse)
	err := c.cc.Invoke(ctx, Query_TokenType_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Token(ctx context.Context, in *QueryTokenRequest, opts ...grpc.CallOption) (*QueryTokenResponse, error) {
	out := new(QueryTokenResponse)
	err := c.cc.Invoke(ctx, Query_Token_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Root(ctx context.Context, in *QueryRootRequest, opts ...grpc.CallOption) (*QueryRootResponse, error) {
	out := new(QueryRootResponse)
	err := c.cc.Invoke(ctx, Query_Root_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) HasParent(ctx context.Context, in *QueryHasParentRequest, opts ...grpc.CallOption) (*QueryHasParentResponse, error) {
	out := new(QueryHasParentResponse)
	err := c.cc.Invoke(ctx, Query_HasParent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Parent(ctx context.Context, in *QueryParentRequest, opts ...grpc.CallOption) (*QueryParentResponse, error) {
	out := new(QueryParentResponse)
	err := c.cc.Invoke(ctx, Query_Parent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Children(ctx context.Context, in *QueryChildrenRequest, opts ...grpc.CallOption) (*QueryChildrenResponse, error) {
	out := new(QueryChildrenResponse)
	err := c.cc.Invoke(ctx, Query_Children_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) GranteeGrants(ctx context.Context, in *QueryGranteeGrantsRequest, opts ...grpc.CallOption) (*QueryGranteeGrantsResponse, error) {
	out := new(QueryGranteeGrantsResponse)
	err := c.cc.Invoke(ctx, Query_GranteeGrants_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) IsOperatorFor(ctx context.Context, in *QueryIsOperatorForRequest, opts ...grpc.CallOption) (*QueryIsOperatorForResponse, error) {
	out := new(QueryIsOperatorForResponse)
	err := c.cc.Invoke(ctx, Query_IsOperatorFor_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) HoldersByOperator(ctx context.Context, in *QueryHoldersByOperatorRequest, opts ...grpc.CallOption) (*QueryHoldersByOperatorResponse, error) {
	out := new(QueryHoldersByOperatorResponse)
	err := c.cc.Invoke(ctx, Query_HoldersByOperator_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
// All implementations must embed UnimplementedQueryServer
// for forward compatibility
type QueryServer interface {
	// Balance queries the balance of a single token class for a single account.
	Balance(context.Context, *QueryBalanceRequest) (*QueryBalanceResponse, error)
	// AllBalances queries the balance of all token classes for a single account.
	AllBalances(context.Context, *QueryAllBalancesRequest) (*QueryAllBalancesResponse, error)
	// FTSupply queries the number of tokens from a given contract id and token id.
	FTSupply(context.Context, *QueryFTSupplyRequest) (*QueryFTSupplyResponse, error)
	// FTMinted queries the number of minted tokens from a given contract id and token id.
	FTMinted(context.Context, *QueryFTMintedRequest) (*QueryFTMintedResponse, error)
	// FTBurnt queries the number of burnt tokens from a given contract id and token id.
	FTBurnt(context.Context, *QueryFTBurntRequest) (*QueryFTBurntResponse, error)
	// NFTSupply queries the number of tokens from a given contract id and token type.
	NFTSupply(context.Context, *QueryNFTSupplyRequest) (*QueryNFTSupplyResponse, error)
	// NFTMinted queries the number of minted tokens from a given contract id and token type.
	NFTMinted(context.Context, *QueryNFTMintedRequest) (*QueryNFTMintedResponse, error)
	// NFTBurnt queries the number of burnt tokens from a given contract id and token type.
	NFTBurnt(context.Context, *QueryNFTBurntRequest) (*QueryNFTBurntResponse, error)
	// Contract queries a contract metadata based on its contract id.
	Contract(context.Context, *QueryContractRequest) (*QueryContractResponse, error)
	// TokenClassTypeName queries the fully qualified message type name of a token class from its class id.
	//
	// Since: 0.46.0 (finschia)
	TokenClassTypeName(context.Context, *QueryTokenClassTypeNameRequest) (*QueryTokenClassTypeNameResponse, error)
	// TokenType queries metadata of a token type.
	TokenType(context.Context, *QueryTokenTypeRequest) (*QueryTokenTypeResponse, error)
	// Token queries a metadata of a token from its token id.
	Token(context.Context, *QueryTokenRequest) (*QueryTokenResponse, error)
	// Root queries the root of a given nft.
	Root(context.Context, *QueryRootRequest) (*QueryRootResponse, error)
	// HasParent queries whether a given nft has its parent.
	HasParent(context.Context, *QueryHasParentRequest) (*QueryHasParentResponse, error)
	// Parent queries the parent of a given nft.
	Parent(context.Context, *QueryParentRequest) (*QueryParentResponse, error)
	// Children queries the children of a given nft.
	Children(context.Context, *QueryChildrenRequest) (*QueryChildrenResponse, error)
	// GranteeGrants queries all permissions on a given grantee.
	GranteeGrants(context.Context, *QueryGranteeGrantsRequest) (*QueryGranteeGrantsResponse, error)
	// IsOperatorFor queries whether the operator is authorized by the holder.
	IsOperatorFor(context.Context, *QueryIsOperatorForRequest) (*QueryIsOperatorForResponse, error)
	// HoldersByOperator queries holders of a given operator.
	HoldersByOperator(context.Context, *QueryHoldersByOperatorRequest) (*QueryHoldersByOperatorResponse, error)
	mustEmbedUnimplementedQueryServer()
}

// UnimplementedQueryServer must be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (UnimplementedQueryServer) Balance(context.Context, *QueryBalanceRequest) (*QueryBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Balance not implemented")
}
func (UnimplementedQueryServer) AllBalances(context.Context, *QueryAllBalancesRequest) (*QueryAllBalancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllBalances not implemented")
}
func (UnimplementedQueryServer) FTSupply(context.Context, *QueryFTSupplyRequest) (*QueryFTSupplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FTSupply not implemented")
}
func (UnimplementedQueryServer) FTMinted(context.Context, *QueryFTMintedRequest) (*QueryFTMintedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FTMinted not implemented")
}
func (UnimplementedQueryServer) FTBurnt(context.Context, *QueryFTBurntRequest) (*QueryFTBurntResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FTBurnt not implemented")
}
func (UnimplementedQueryServer) NFTSupply(context.Context, *QueryNFTSupplyRequest) (*QueryNFTSupplyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NFTSupply not implemented")
}
func (UnimplementedQueryServer) NFTMinted(context.Context, *QueryNFTMintedRequest) (*QueryNFTMintedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NFTMinted not implemented")
}
func (UnimplementedQueryServer) NFTBurnt(context.Context, *QueryNFTBurntRequest) (*QueryNFTBurntResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NFTBurnt not implemented")
}
func (UnimplementedQueryServer) Contract(context.Context, *QueryContractRequest) (*QueryContractResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Contract not implemented")
}
func (UnimplementedQueryServer) TokenClassTypeName(context.Context, *QueryTokenClassTypeNameRequest) (*QueryTokenClassTypeNameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenClassTypeName not implemented")
}
func (UnimplementedQueryServer) TokenType(context.Context, *QueryTokenTypeRequest) (*QueryTokenTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TokenType not implemented")
}
func (UnimplementedQueryServer) Token(context.Context, *QueryTokenRequest) (*QueryTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Token not implemented")
}
func (UnimplementedQueryServer) Root(context.Context, *QueryRootRequest) (*QueryRootResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Root not implemented")
}
func (UnimplementedQueryServer) HasParent(context.Context, *QueryHasParentRequest) (*QueryHasParentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasParent not implemented")
}
func (UnimplementedQueryServer) Parent(context.Context, *QueryParentRequest) (*QueryParentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Parent not implemented")
}
func (UnimplementedQueryServer) Children(context.Context, *QueryChildrenRequest) (*QueryChildrenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Children not implemented")
}
func (UnimplementedQueryServer) GranteeGrants(context.Context, *QueryGranteeGrantsRequest) (*QueryGranteeGrantsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GranteeGrants not implemented")
}
func (UnimplementedQueryServer) IsOperatorFor(context.Context, *QueryIsOperatorForRequest) (*QueryIsOperatorForResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsOperatorFor not implemented")
}
func (UnimplementedQueryServer) HoldersByOperator(context.Context, *QueryHoldersByOperatorRequest) (*QueryHoldersByOperatorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HoldersByOperator not implemented")
}
func (UnimplementedQueryServer) mustEmbedUnimplementedQueryServer() {}

// UnsafeQueryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QueryServer will
// result in compilation errors.
type UnsafeQueryServer interface {
	mustEmbedUnimplementedQueryServer()
}

func RegisterQueryServer(s grpc.ServiceRegistrar, srv QueryServer) {
	s.RegisterService(&Query_ServiceDesc, srv)
}

func _Query_Balance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Balance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Balance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Balance(ctx, req.(*QueryBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AllBalances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllBalancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AllBalances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_AllBalances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AllBalances(ctx, req.(*QueryAllBalancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_FTSupply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFTSupplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).FTSupply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_FTSupply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).FTSupply(ctx, req.(*QueryFTSupplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_FTMinted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFTMintedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).FTMinted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_FTMinted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).FTMinted(ctx, req.(*QueryFTMintedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_FTBurnt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFTBurntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).FTBurnt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_FTBurnt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).FTBurnt(ctx, req.(*QueryFTBurntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_NFTSupply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNFTSupplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).NFTSupply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_NFTSupply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).NFTSupply(ctx, req.(*QueryNFTSupplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_NFTMinted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNFTMintedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).NFTMinted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_NFTMinted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).NFTMinted(ctx, req.(*QueryNFTMintedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_NFTBurnt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNFTBurntRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).NFTBurnt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_NFTBurnt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).NFTBurnt(ctx, req.(*QueryNFTBurntRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Contract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Contract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Contract_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Contract(ctx, req.(*QueryContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TokenClassTypeName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTokenClassTypeNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TokenClassTypeName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_TokenClassTypeName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TokenClassTypeName(ctx, req.(*QueryTokenClassTypeNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_TokenType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTokenTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).TokenType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_TokenType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).TokenType(ctx, req.(*QueryTokenTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Token_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Token(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Token_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Token(ctx, req.(*QueryTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Root_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRootRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Root(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Root_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Root(ctx, req.(*QueryRootRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_HasParent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHasParentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).HasParent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_HasParent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).HasParent(ctx, req.(*QueryHasParentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Parent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Parent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Parent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Parent(ctx, req.(*QueryParentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Children_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryChildrenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Children(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_Children_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Children(ctx, req.(*QueryChildrenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_GranteeGrants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryGranteeGrantsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).GranteeGrants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_GranteeGrants_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).GranteeGrants(ctx, req.(*QueryGranteeGrantsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_IsOperatorFor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryIsOperatorForRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).IsOperatorFor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_IsOperatorFor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).IsOperatorFor(ctx, req.(*QueryIsOperatorForRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_HoldersByOperator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHoldersByOperatorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).HoldersByOperator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Query_HoldersByOperator_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).HoldersByOperator(ctx, req.(*QueryHoldersByOperatorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Query_ServiceDesc is the grpc.ServiceDesc for Query service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Query_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lbm.collection.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Balance",
			Handler:    _Query_Balance_Handler,
		},
		{
			MethodName: "AllBalances",
			Handler:    _Query_AllBalances_Handler,
		},
		{
			MethodName: "FTSupply",
			Handler:    _Query_FTSupply_Handler,
		},
		{
			MethodName: "FTMinted",
			Handler:    _Query_FTMinted_Handler,
		},
		{
			MethodName: "FTBurnt",
			Handler:    _Query_FTBurnt_Handler,
		},
		{
			MethodName: "NFTSupply",
			Handler:    _Query_NFTSupply_Handler,
		},
		{
			MethodName: "NFTMinted",
			Handler:    _Query_NFTMinted_Handler,
		},
		{
			MethodName: "NFTBurnt",
			Handler:    _Query_NFTBurnt_Handler,
		},
		{
			MethodName: "Contract",
			Handler:    _Query_Contract_Handler,
		},
		{
			MethodName: "TokenClassTypeName",
			Handler:    _Query_TokenClassTypeName_Handler,
		},
		{
			MethodName: "TokenType",
			Handler:    _Query_TokenType_Handler,
		},
		{
			MethodName: "Token",
			Handler:    _Query_Token_Handler,
		},
		{
			MethodName: "Root",
			Handler:    _Query_Root_Handler,
		},
		{
			MethodName: "HasParent",
			Handler:    _Query_HasParent_Handler,
		},
		{
			MethodName: "Parent",
			Handler:    _Query_Parent_Handler,
		},
		{
			MethodName: "Children",
			Handler:    _Query_Children_Handler,
		},
		{
			MethodName: "GranteeGrants",
			Handler:    _Query_GranteeGrants_Handler,
		},
		{
			MethodName: "IsOperatorFor",
			Handler:    _Query_IsOperatorFor_Handler,
		},
		{
			MethodName: "HoldersByOperator",
			Handler:    _Query_HoldersByOperator_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lbm/collection/v1/query.proto",
}
